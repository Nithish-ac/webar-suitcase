import {
  __commonJS,
  __export,
  __toESM,
  three_module_exports
} from "./chunk-XDB65PGV.js";

// node_modules/ua-parser-js/src/ua-parser.js
var require_ua_parser = __commonJS({
  "node_modules/ua-parser-js/src/ua-parser.js"(exports, module) {
    (function(window2, undefined2) {
      "use strict";
      var LIBVERSION = "1.0.33", EMPTY = "", UNKNOWN = "?", FUNC_TYPE = "function", UNDEF_TYPE = "undefined", OBJ_TYPE = "object", STR_TYPE = "string", MAJOR = "major", MODEL = "model", NAME = "name", TYPE = "type", VENDOR = "vendor", VERSION4 = "version", ARCHITECTURE = "architecture", CONSOLE = "console", MOBILE = "mobile", TABLET = "tablet", SMARTTV = "smarttv", WEARABLE = "wearable", EMBEDDED = "embedded", UA_MAX_LENGTH = 350;
      var AMAZON = "Amazon", APPLE = "Apple", ASUS = "ASUS", BLACKBERRY = "BlackBerry", BROWSER = "Browser", CHROME = "Chrome", EDGE = "Edge", FIREFOX = "Firefox", GOOGLE = "Google", HUAWEI = "Huawei", LG = "LG", MICROSOFT = "Microsoft", MOTOROLA = "Motorola", OPERA = "Opera", SAMSUNG = "Samsung", SHARP = "Sharp", SONY = "Sony", XIAOMI = "Xiaomi", ZEBRA = "Zebra", FACEBOOK = "Facebook";
      var extend = function(regexes2, extensions) {
        var mergedRegexes = {};
        for (var i in regexes2) {
          if (extensions[i] && extensions[i].length % 2 === 0) {
            mergedRegexes[i] = extensions[i].concat(regexes2[i]);
          } else {
            mergedRegexes[i] = regexes2[i];
          }
        }
        return mergedRegexes;
      }, enumerize = function(arr) {
        var enums = {};
        for (var i = 0; i < arr.length; i++) {
          enums[arr[i].toUpperCase()] = arr[i];
        }
        return enums;
      }, has = function(str1, str22) {
        return typeof str1 === STR_TYPE ? lowerize(str22).indexOf(lowerize(str1)) !== -1 : false;
      }, lowerize = function(str4) {
        return str4.toLowerCase();
      }, majorize = function(version) {
        return typeof version === STR_TYPE ? version.replace(/[^\d\.]/g, EMPTY).split(".")[0] : undefined2;
      }, trim = function(str4, len3) {
        if (typeof str4 === STR_TYPE) {
          str4 = str4.replace(/^\s\s*/, EMPTY);
          return typeof len3 === UNDEF_TYPE ? str4 : str4.substring(0, UA_MAX_LENGTH);
        }
      };
      var rgxMapper = function(ua, arrays) {
        var i = 0, j, k, p, q, matches, match;
        while (i < arrays.length && !matches) {
          var regex = arrays[i], props = arrays[i + 1];
          j = k = 0;
          while (j < regex.length && !matches) {
            matches = regex[j++].exec(ua);
            if (!!matches) {
              for (p = 0; p < props.length; p++) {
                match = matches[++k];
                q = props[p];
                if (typeof q === OBJ_TYPE && q.length > 0) {
                  if (q.length === 2) {
                    if (typeof q[1] == FUNC_TYPE) {
                      this[q[0]] = q[1].call(this, match);
                    } else {
                      this[q[0]] = q[1];
                    }
                  } else if (q.length === 3) {
                    if (typeof q[1] === FUNC_TYPE && !(q[1].exec && q[1].test)) {
                      this[q[0]] = match ? q[1].call(this, match, q[2]) : undefined2;
                    } else {
                      this[q[0]] = match ? match.replace(q[1], q[2]) : undefined2;
                    }
                  } else if (q.length === 4) {
                    this[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined2;
                  }
                } else {
                  this[q] = match ? match : undefined2;
                }
              }
            }
          }
          i += 2;
        }
      }, strMapper = function(str4, map) {
        for (var i in map) {
          if (typeof map[i] === OBJ_TYPE && map[i].length > 0) {
            for (var j = 0; j < map[i].length; j++) {
              if (has(map[i][j], str4)) {
                return i === UNKNOWN ? undefined2 : i;
              }
            }
          } else if (has(map[i], str4)) {
            return i === UNKNOWN ? undefined2 : i;
          }
        }
        return str4;
      };
      var oldSafariMap = {
        "1.0": "/8",
        "1.2": "/1",
        "1.3": "/3",
        "2.0": "/412",
        "2.0.2": "/416",
        "2.0.3": "/417",
        "2.0.4": "/419",
        "?": "/"
      }, windowsVersionMap = {
        "ME": "4.90",
        "NT 3.11": "NT3.51",
        "NT 4.0": "NT4.0",
        "2000": "NT 5.0",
        "XP": ["NT 5.1", "NT 5.2"],
        "Vista": "NT 6.0",
        "7": "NT 6.1",
        "8": "NT 6.2",
        "8.1": "NT 6.3",
        "10": ["NT 6.4", "NT 10.0"],
        "RT": "ARM"
      };
      var regexes = {
        browser: [
          [
            /\b(?:crmo|crios)\/([\w\.]+)/i
            // Chrome for Android/iOS
          ],
          [VERSION4, [NAME, "Chrome"]],
          [
            /edg(?:e|ios|a)?\/([\w\.]+)/i
            // Microsoft Edge
          ],
          [VERSION4, [NAME, "Edge"]],
          [
            // Presto based
            /(opera mini)\/([-\w\.]+)/i,
            // Opera Mini
            /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i,
            // Opera Mobi/Tablet
            /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i
            // Opera
          ],
          [NAME, VERSION4],
          [
            /opios[\/ ]+([\w\.]+)/i
            // Opera mini on iphone >= 8.0
          ],
          [VERSION4, [NAME, OPERA + " Mini"]],
          [
            /\bopr\/([\w\.]+)/i
            // Opera Webkit
          ],
          [VERSION4, [NAME, OPERA]],
          [
            // Mixed
            /(kindle)\/([\w\.]+)/i,
            // Kindle
            /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i,
            // Lunascape/Maxthon/Netfront/Jasmine/Blazer
            // Trident based
            /(avant |iemobile|slim)(?:browser)?[\/ ]?([\w\.]*)/i,
            // Avant/IEMobile/SlimBrowser
            /(ba?idubrowser)[\/ ]?([\w\.]+)/i,
            // Baidu Browser
            /(?:ms|\()(ie) ([\w\.]+)/i,
            // Internet Explorer
            // Webkit/KHTML based                                               // Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS/Bowser/QupZilla/Falkon
            /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i,
            // Rekonq/Puffin/Brave/Whale/QQBrowserLite/QQ, aka ShouQ
            /(weibo)__([\d\.]+)/i
            // Weibo
          ],
          [NAME, VERSION4],
          [
            /(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i
            // UCBrowser
          ],
          [VERSION4, [NAME, "UC" + BROWSER]],
          [
            /microm.+\bqbcore\/([\w\.]+)/i,
            // WeChat Desktop for Windows Built-in Browser
            /\bqbcore\/([\w\.]+).+microm/i
          ],
          [VERSION4, [NAME, "WeChat(Win) Desktop"]],
          [
            /micromessenger\/([\w\.]+)/i
            // WeChat
          ],
          [VERSION4, [NAME, "WeChat"]],
          [
            /konqueror\/([\w\.]+)/i
            // Konqueror
          ],
          [VERSION4, [NAME, "Konqueror"]],
          [
            /trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i
            // IE11
          ],
          [VERSION4, [NAME, "IE"]],
          [
            /yabrowser\/([\w\.]+)/i
            // Yandex
          ],
          [VERSION4, [NAME, "Yandex"]],
          [
            /(avast|avg)\/([\w\.]+)/i
            // Avast/AVG Secure Browser
          ],
          [[NAME, /(.+)/, "$1 Secure " + BROWSER], VERSION4],
          [
            /\bfocus\/([\w\.]+)/i
            // Firefox Focus
          ],
          [VERSION4, [NAME, FIREFOX + " Focus"]],
          [
            /\bopt\/([\w\.]+)/i
            // Opera Touch
          ],
          [VERSION4, [NAME, OPERA + " Touch"]],
          [
            /coc_coc\w+\/([\w\.]+)/i
            // Coc Coc Browser
          ],
          [VERSION4, [NAME, "Coc Coc"]],
          [
            /dolfin\/([\w\.]+)/i
            // Dolphin
          ],
          [VERSION4, [NAME, "Dolphin"]],
          [
            /coast\/([\w\.]+)/i
            // Opera Coast
          ],
          [VERSION4, [NAME, OPERA + " Coast"]],
          [
            /miuibrowser\/([\w\.]+)/i
            // MIUI Browser
          ],
          [VERSION4, [NAME, "MIUI " + BROWSER]],
          [
            /fxios\/([-\w\.]+)/i
            // Firefox for iOS
          ],
          [VERSION4, [NAME, FIREFOX]],
          [
            /\bqihu|(qi?ho?o?|360)browser/i
            // 360
          ],
          [[NAME, "360 " + BROWSER]],
          [
            /(oculus|samsung|sailfish|huawei)browser\/([\w\.]+)/i
          ],
          [[NAME, /(.+)/, "$1 " + BROWSER], VERSION4],
          [
            // Oculus/Samsung/Sailfish/Huawei Browser
            /(comodo_dragon)\/([\w\.]+)/i
            // Comodo Dragon
          ],
          [[NAME, /_/g, " "], VERSION4],
          [
            /(electron)\/([\w\.]+) safari/i,
            // Electron-based App
            /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i,
            // Tesla
            /m?(qqbrowser|baiduboxapp|2345Explorer)[\/ ]?([\w\.]+)/i
            // QQBrowser/Baidu App/2345 Browser
          ],
          [NAME, VERSION4],
          [
            /(metasr)[\/ ]?([\w\.]+)/i,
            // SouGouBrowser
            /(lbbrowser)/i,
            // LieBao Browser
            /\[(linkedin)app\]/i
            // LinkedIn App for iOS & Android
          ],
          [NAME],
          [
            // WebView
            /((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i
            // Facebook App for iOS & Android
          ],
          [[NAME, FACEBOOK], VERSION4],
          [
            /safari (line)\/([\w\.]+)/i,
            // Line App for iOS
            /\b(line)\/([\w\.]+)\/iab/i,
            // Line App for Android
            /(chromium|instagram)[\/ ]([-\w\.]+)/i
            // Chromium/Instagram
          ],
          [NAME, VERSION4],
          [
            /\bgsa\/([\w\.]+) .*safari\//i
            // Google Search Appliance on iOS
          ],
          [VERSION4, [NAME, "GSA"]],
          [
            /headlesschrome(?:\/([\w\.]+)| )/i
            // Chrome Headless
          ],
          [VERSION4, [NAME, CHROME + " Headless"]],
          [
            / wv\).+(chrome)\/([\w\.]+)/i
            // Chrome WebView
          ],
          [[NAME, CHROME + " WebView"], VERSION4],
          [
            /droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i
            // Android Browser
          ],
          [VERSION4, [NAME, "Android " + BROWSER]],
          [
            /(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i
            // Chrome/OmniWeb/Arora/Tizen/Nokia
          ],
          [NAME, VERSION4],
          [
            /version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i
            // Mobile Safari
          ],
          [VERSION4, [NAME, "Mobile Safari"]],
          [
            /version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i
            // Safari & Safari Mobile
          ],
          [VERSION4, NAME],
          [
            /webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i
            // Safari < 3.0
          ],
          [NAME, [VERSION4, strMapper, oldSafariMap]],
          [
            /(webkit|khtml)\/([\w\.]+)/i
          ],
          [NAME, VERSION4],
          [
            // Gecko based
            /(navigator|netscape\d?)\/([-\w\.]+)/i
            // Netscape
          ],
          [[NAME, "Netscape"], VERSION4],
          [
            /mobile vr; rv:([\w\.]+)\).+firefox/i
            // Firefox Reality
          ],
          [VERSION4, [NAME, FIREFOX + " Reality"]],
          [
            /ekiohf.+(flow)\/([\w\.]+)/i,
            // Flow
            /(swiftfox)/i,
            // Swiftfox
            /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i,
            // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror/Klar
            /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i,
            // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
            /(firefox)\/([\w\.]+)/i,
            // Other Firefox-based
            /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i,
            // Mozilla
            // Other
            /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i,
            // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Sleipnir/Obigo/Mosaic/Go/ICE/UP.Browser
            /(links) \(([\w\.]+)/i
            // Links
          ],
          [NAME, VERSION4],
          [
            /(cobalt)\/([\w\.]+)/i
            // Cobalt
          ],
          [NAME, [VERSION4, /master.|lts./, ""]]
        ],
        cpu: [
          [
            /(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i
            // AMD64 (x64)
          ],
          [[ARCHITECTURE, "amd64"]],
          [
            /(ia32(?=;))/i
            // IA32 (quicktime)
          ],
          [[ARCHITECTURE, lowerize]],
          [
            /((?:i[346]|x)86)[;\)]/i
            // IA32 (x86)
          ],
          [[ARCHITECTURE, "ia32"]],
          [
            /\b(aarch64|arm(v?8e?l?|_?64))\b/i
            // ARM64
          ],
          [[ARCHITECTURE, "arm64"]],
          [
            /\b(arm(?:v[67])?ht?n?[fl]p?)\b/i
            // ARMHF
          ],
          [[ARCHITECTURE, "armhf"]],
          [
            // PocketPC mistakenly identified as PowerPC
            /windows (ce|mobile); ppc;/i
          ],
          [[ARCHITECTURE, "arm"]],
          [
            /((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i
            // PowerPC
          ],
          [[ARCHITECTURE, /ower/, EMPTY, lowerize]],
          [
            /(sun4\w)[;\)]/i
            // SPARC
          ],
          [[ARCHITECTURE, "sparc"]],
          [
            /((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i
            // IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC
          ],
          [[ARCHITECTURE, lowerize]]
        ],
        device: [
          [
            //////////////////////////
            // MOBILES & TABLETS
            // Ordered by popularity
            /////////////////////////
            // Samsung
            /\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i
          ],
          [MODEL, [VENDOR, SAMSUNG], [TYPE, TABLET]],
          [
            /\b((?:s[cgp]h|gt|sm)-\w+|galaxy nexus)/i,
            /samsung[- ]([-\w]+)/i,
            /sec-(sgh\w+)/i
          ],
          [MODEL, [VENDOR, SAMSUNG], [TYPE, MOBILE]],
          [
            // Apple
            /\((ip(?:hone|od)[\w ]*);/i
            // iPod/iPhone
          ],
          [MODEL, [VENDOR, APPLE], [TYPE, MOBILE]],
          [
            /\((ipad);[-\w\),; ]+apple/i,
            // iPad
            /applecoremedia\/[\w\.]+ \((ipad)/i,
            /\b(ipad)\d\d?,\d\d?[;\]].+ios/i
          ],
          [MODEL, [VENDOR, APPLE], [TYPE, TABLET]],
          [
            /(macintosh);/i
          ],
          [MODEL, [VENDOR, APPLE]],
          [
            // Huawei
            /\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i
          ],
          [MODEL, [VENDOR, HUAWEI], [TYPE, TABLET]],
          [
            /(?:huawei|honor)([-\w ]+)[;\)]/i,
            /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i
          ],
          [MODEL, [VENDOR, HUAWEI], [TYPE, MOBILE]],
          [
            // Xiaomi
            /\b(poco[\w ]+)(?: bui|\))/i,
            // Xiaomi POCO
            /\b; (\w+) build\/hm\1/i,
            // Xiaomi Hongmi 'numeric' models
            /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i,
            // Xiaomi Hongmi
            /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i,
            // Xiaomi Redmi
            /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i
            // Xiaomi Mi
          ],
          [[MODEL, /_/g, " "], [VENDOR, XIAOMI], [TYPE, MOBILE]],
          [
            /\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i
            // Mi Pad tablets
          ],
          [[MODEL, /_/g, " "], [VENDOR, XIAOMI], [TYPE, TABLET]],
          [
            // OPPO
            /; (\w+) bui.+ oppo/i,
            /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i
          ],
          [MODEL, [VENDOR, "OPPO"], [TYPE, MOBILE]],
          [
            // Vivo
            /vivo (\w+)(?: bui|\))/i,
            /\b(v[12]\d{3}\w?[at])(?: bui|;)/i
          ],
          [MODEL, [VENDOR, "Vivo"], [TYPE, MOBILE]],
          [
            // Realme
            /\b(rmx[12]\d{3})(?: bui|;|\))/i
          ],
          [MODEL, [VENDOR, "Realme"], [TYPE, MOBILE]],
          [
            // Motorola
            /\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i,
            /\bmot(?:orola)?[- ](\w*)/i,
            /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i
          ],
          [MODEL, [VENDOR, MOTOROLA], [TYPE, MOBILE]],
          [
            /\b(mz60\d|xoom[2 ]{0,2}) build\//i
          ],
          [MODEL, [VENDOR, MOTOROLA], [TYPE, TABLET]],
          [
            // LG
            /((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i
          ],
          [MODEL, [VENDOR, LG], [TYPE, TABLET]],
          [
            /(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i,
            /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i,
            /\blg-?([\d\w]+) bui/i
          ],
          [MODEL, [VENDOR, LG], [TYPE, MOBILE]],
          [
            // Lenovo
            /(ideatab[-\w ]+)/i,
            /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i
          ],
          [MODEL, [VENDOR, "Lenovo"], [TYPE, TABLET]],
          [
            // Nokia
            /(?:maemo|nokia).*(n900|lumia \d+)/i,
            /nokia[-_ ]?([-\w\.]*)/i
          ],
          [[MODEL, /_/g, " "], [VENDOR, "Nokia"], [TYPE, MOBILE]],
          [
            // Google
            /(pixel c)\b/i
            // Google Pixel C
          ],
          [MODEL, [VENDOR, GOOGLE], [TYPE, TABLET]],
          [
            /droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i
            // Google Pixel
          ],
          [MODEL, [VENDOR, GOOGLE], [TYPE, MOBILE]],
          [
            // Sony
            /droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i
          ],
          [MODEL, [VENDOR, SONY], [TYPE, MOBILE]],
          [
            /sony tablet [ps]/i,
            /\b(?:sony)?sgp\w+(?: bui|\))/i
          ],
          [[MODEL, "Xperia Tablet"], [VENDOR, SONY], [TYPE, TABLET]],
          [
            // OnePlus
            / (kb2005|in20[12]5|be20[12][59])\b/i,
            /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i
          ],
          [MODEL, [VENDOR, "OnePlus"], [TYPE, MOBILE]],
          [
            // Amazon
            /(alexa)webm/i,
            /(kf[a-z]{2}wi)( bui|\))/i,
            // Kindle Fire without Silk
            /(kf[a-z]+)( bui|\)).+silk\//i
            // Kindle Fire HD
          ],
          [MODEL, [VENDOR, AMAZON], [TYPE, TABLET]],
          [
            /((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i
            // Fire Phone
          ],
          [[MODEL, /(.+)/g, "Fire Phone $1"], [VENDOR, AMAZON], [TYPE, MOBILE]],
          [
            // BlackBerry
            /(playbook);[-\w\),; ]+(rim)/i
            // BlackBerry PlayBook
          ],
          [MODEL, VENDOR, [TYPE, TABLET]],
          [
            /\b((?:bb[a-f]|st[hv])100-\d)/i,
            /\(bb10; (\w+)/i
            // BlackBerry 10
          ],
          [MODEL, [VENDOR, BLACKBERRY], [TYPE, MOBILE]],
          [
            // Asus
            /(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i
          ],
          [MODEL, [VENDOR, ASUS], [TYPE, TABLET]],
          [
            / (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i
          ],
          [MODEL, [VENDOR, ASUS], [TYPE, MOBILE]],
          [
            // HTC
            /(nexus 9)/i
            // HTC Nexus 9
          ],
          [MODEL, [VENDOR, "HTC"], [TYPE, TABLET]],
          [
            /(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i,
            // HTC
            // ZTE
            /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i,
            /(alcatel|geeksphone|nexian|panasonic|sony(?!-bra))[-_ ]?([-\w]*)/i
            // Alcatel/GeeksPhone/Nexian/Panasonic/Sony
          ],
          [VENDOR, [MODEL, /_/g, " "], [TYPE, MOBILE]],
          [
            // Acer
            /droid.+; ([ab][1-7]-?[0178a]\d\d?)/i
          ],
          [MODEL, [VENDOR, "Acer"], [TYPE, TABLET]],
          [
            // Meizu
            /droid.+; (m[1-5] note) bui/i,
            /\bmz-([-\w]{2,})/i
          ],
          [MODEL, [VENDOR, "Meizu"], [TYPE, MOBILE]],
          [
            // Sharp
            /\b(sh-?[altvz]?\d\d[a-ekm]?)/i
          ],
          [MODEL, [VENDOR, SHARP], [TYPE, MOBILE]],
          [
            // MIXED
            /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\w]*)/i,
            // BlackBerry/BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Meizu/Motorola/Polytron
            /(hp) ([\w ]+\w)/i,
            // HP iPAQ
            /(asus)-?(\w+)/i,
            // Asus
            /(microsoft); (lumia[\w ]+)/i,
            // Microsoft Lumia
            /(lenovo)[-_ ]?([-\w]+)/i,
            // Lenovo
            /(jolla)/i,
            // Jolla
            /(oppo) ?([\w ]+) bui/i
            // OPPO
          ],
          [VENDOR, MODEL, [TYPE, MOBILE]],
          [
            /(archos) (gamepad2?)/i,
            // Archos
            /(hp).+(touchpad(?!.+tablet)|tablet)/i,
            // HP TouchPad
            /(kindle)\/([\w\.]+)/i,
            // Kindle
            /(nook)[\w ]+build\/(\w+)/i,
            // Nook
            /(dell) (strea[kpr\d ]*[\dko])/i,
            // Dell Streak
            /(le[- ]+pan)[- ]+(\w{1,9}) bui/i,
            // Le Pan Tablets
            /(trinity)[- ]*(t\d{3}) bui/i,
            // Trinity Tablets
            /(gigaset)[- ]+(q\w{1,9}) bui/i,
            // Gigaset Tablets
            /(vodafone) ([\w ]+)(?:\)| bui)/i
            // Vodafone
          ],
          [VENDOR, MODEL, [TYPE, TABLET]],
          [
            /(surface duo)/i
            // Surface Duo
          ],
          [MODEL, [VENDOR, MICROSOFT], [TYPE, TABLET]],
          [
            /droid [\d\.]+; (fp\du?)(?: b|\))/i
            // Fairphone
          ],
          [MODEL, [VENDOR, "Fairphone"], [TYPE, MOBILE]],
          [
            /(u304aa)/i
            // AT&T
          ],
          [MODEL, [VENDOR, "AT&T"], [TYPE, MOBILE]],
          [
            /\bsie-(\w*)/i
            // Siemens
          ],
          [MODEL, [VENDOR, "Siemens"], [TYPE, MOBILE]],
          [
            /\b(rct\w+) b/i
            // RCA Tablets
          ],
          [MODEL, [VENDOR, "RCA"], [TYPE, TABLET]],
          [
            /\b(venue[\d ]{2,7}) b/i
            // Dell Venue Tablets
          ],
          [MODEL, [VENDOR, "Dell"], [TYPE, TABLET]],
          [
            /\b(q(?:mv|ta)\w+) b/i
            // Verizon Tablet
          ],
          [MODEL, [VENDOR, "Verizon"], [TYPE, TABLET]],
          [
            /\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i
            // Barnes & Noble Tablet
          ],
          [MODEL, [VENDOR, "Barnes & Noble"], [TYPE, TABLET]],
          [
            /\b(tm\d{3}\w+) b/i
          ],
          [MODEL, [VENDOR, "NuVision"], [TYPE, TABLET]],
          [
            /\b(k88) b/i
            // ZTE K Series Tablet
          ],
          [MODEL, [VENDOR, "ZTE"], [TYPE, TABLET]],
          [
            /\b(nx\d{3}j) b/i
            // ZTE Nubia
          ],
          [MODEL, [VENDOR, "ZTE"], [TYPE, MOBILE]],
          [
            /\b(gen\d{3}) b.+49h/i
            // Swiss GEN Mobile
          ],
          [MODEL, [VENDOR, "Swiss"], [TYPE, MOBILE]],
          [
            /\b(zur\d{3}) b/i
            // Swiss ZUR Tablet
          ],
          [MODEL, [VENDOR, "Swiss"], [TYPE, TABLET]],
          [
            /\b((zeki)?tb.*\b) b/i
            // Zeki Tablets
          ],
          [MODEL, [VENDOR, "Zeki"], [TYPE, TABLET]],
          [
            /\b([yr]\d{2}) b/i,
            /\b(dragon[- ]+touch |dt)(\w{5}) b/i
            // Dragon Touch Tablet
          ],
          [[VENDOR, "Dragon Touch"], MODEL, [TYPE, TABLET]],
          [
            /\b(ns-?\w{0,9}) b/i
            // Insignia Tablets
          ],
          [MODEL, [VENDOR, "Insignia"], [TYPE, TABLET]],
          [
            /\b((nxa|next)-?\w{0,9}) b/i
            // NextBook Tablets
          ],
          [MODEL, [VENDOR, "NextBook"], [TYPE, TABLET]],
          [
            /\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i
            // Voice Xtreme Phones
          ],
          [[VENDOR, "Voice"], MODEL, [TYPE, MOBILE]],
          [
            /\b(lvtel\-)?(v1[12]) b/i
            // LvTel Phones
          ],
          [[VENDOR, "LvTel"], MODEL, [TYPE, MOBILE]],
          [
            /\b(ph-1) /i
            // Essential PH-1
          ],
          [MODEL, [VENDOR, "Essential"], [TYPE, MOBILE]],
          [
            /\b(v(100md|700na|7011|917g).*\b) b/i
            // Envizen Tablets
          ],
          [MODEL, [VENDOR, "Envizen"], [TYPE, TABLET]],
          [
            /\b(trio[-\w\. ]+) b/i
            // MachSpeed Tablets
          ],
          [MODEL, [VENDOR, "MachSpeed"], [TYPE, TABLET]],
          [
            /\btu_(1491) b/i
            // Rotor Tablets
          ],
          [MODEL, [VENDOR, "Rotor"], [TYPE, TABLET]],
          [
            /(shield[\w ]+) b/i
            // Nvidia Shield Tablets
          ],
          [MODEL, [VENDOR, "Nvidia"], [TYPE, TABLET]],
          [
            /(sprint) (\w+)/i
            // Sprint Phones
          ],
          [VENDOR, MODEL, [TYPE, MOBILE]],
          [
            /(kin\.[onetw]{3})/i
            // Microsoft Kin
          ],
          [[MODEL, /\./g, " "], [VENDOR, MICROSOFT], [TYPE, MOBILE]],
          [
            /droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i
            // Zebra
          ],
          [MODEL, [VENDOR, ZEBRA], [TYPE, TABLET]],
          [
            /droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i
          ],
          [MODEL, [VENDOR, ZEBRA], [TYPE, MOBILE]],
          [
            ///////////////////
            // CONSOLES
            ///////////////////
            /(ouya)/i,
            // Ouya
            /(nintendo) ([wids3utch]+)/i
            // Nintendo
          ],
          [VENDOR, MODEL, [TYPE, CONSOLE]],
          [
            /droid.+; (shield) bui/i
            // Nvidia
          ],
          [MODEL, [VENDOR, "Nvidia"], [TYPE, CONSOLE]],
          [
            /(playstation [345portablevi]+)/i
            // Playstation
          ],
          [MODEL, [VENDOR, SONY], [TYPE, CONSOLE]],
          [
            /\b(xbox(?: one)?(?!; xbox))[\); ]/i
            // Microsoft Xbox
          ],
          [MODEL, [VENDOR, MICROSOFT], [TYPE, CONSOLE]],
          [
            ///////////////////
            // SMARTTVS
            ///////////////////
            /smart-tv.+(samsung)/i
            // Samsung
          ],
          [VENDOR, [TYPE, SMARTTV]],
          [
            /hbbtv.+maple;(\d+)/i
          ],
          [[MODEL, /^/, "SmartTV"], [VENDOR, SAMSUNG], [TYPE, SMARTTV]],
          [
            /(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i
            // LG SmartTV
          ],
          [[VENDOR, LG], [TYPE, SMARTTV]],
          [
            /(apple) ?tv/i
            // Apple TV
          ],
          [VENDOR, [MODEL, APPLE + " TV"], [TYPE, SMARTTV]],
          [
            /crkey/i
            // Google Chromecast
          ],
          [[MODEL, CHROME + "cast"], [VENDOR, GOOGLE], [TYPE, SMARTTV]],
          [
            /droid.+aft(\w)( bui|\))/i
            // Fire TV
          ],
          [MODEL, [VENDOR, AMAZON], [TYPE, SMARTTV]],
          [
            /\(dtv[\);].+(aquos)/i,
            /(aquos-tv[\w ]+)\)/i
            // Sharp
          ],
          [MODEL, [VENDOR, SHARP], [TYPE, SMARTTV]],
          [
            /(bravia[\w ]+)( bui|\))/i
            // Sony
          ],
          [MODEL, [VENDOR, SONY], [TYPE, SMARTTV]],
          [
            /(mitv-\w{5}) bui/i
            // Xiaomi
          ],
          [MODEL, [VENDOR, XIAOMI], [TYPE, SMARTTV]],
          [
            /\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i,
            // Roku
            /hbbtv\/\d+\.\d+\.\d+ +\([\w ]*; *(\w[^;]*);([^;]*)/i
            // HbbTV devices
          ],
          [[VENDOR, trim], [MODEL, trim], [TYPE, SMARTTV]],
          [
            /\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i
            // SmartTV from Unidentified Vendors
          ],
          [[TYPE, SMARTTV]],
          [
            ///////////////////
            // WEARABLES
            ///////////////////
            /((pebble))app/i
            // Pebble
          ],
          [VENDOR, MODEL, [TYPE, WEARABLE]],
          [
            /droid.+; (glass) \d/i
            // Google Glass
          ],
          [MODEL, [VENDOR, GOOGLE], [TYPE, WEARABLE]],
          [
            /droid.+; (wt63?0{2,3})\)/i
          ],
          [MODEL, [VENDOR, ZEBRA], [TYPE, WEARABLE]],
          [
            /(quest( 2)?)/i
            // Oculus Quest
          ],
          [MODEL, [VENDOR, FACEBOOK], [TYPE, WEARABLE]],
          [
            ///////////////////
            // EMBEDDED
            ///////////////////
            /(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i
            // Tesla
          ],
          [VENDOR, [TYPE, EMBEDDED]],
          [
            ////////////////////
            // MIXED (GENERIC)
            ///////////////////
            /droid .+?; ([^;]+?)(?: bui|\) applew).+? mobile safari/i
            // Android Phones from Unidentified Vendors
          ],
          [MODEL, [TYPE, MOBILE]],
          [
            /droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i
            // Android Tablets from Unidentified Vendors
          ],
          [MODEL, [TYPE, TABLET]],
          [
            /\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i
            // Unidentifiable Tablet
          ],
          [[TYPE, TABLET]],
          [
            /(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i
            // Unidentifiable Mobile
          ],
          [[TYPE, MOBILE]],
          [
            /(android[-\w\. ]{0,9});.+buil/i
            // Generic Android Device
          ],
          [MODEL, [VENDOR, "Generic"]]
        ],
        engine: [
          [
            /windows.+ edge\/([\w\.]+)/i
            // EdgeHTML
          ],
          [VERSION4, [NAME, EDGE + "HTML"]],
          [
            /webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i
            // Blink
          ],
          [VERSION4, [NAME, "Blink"]],
          [
            /(presto)\/([\w\.]+)/i,
            // Presto
            /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i,
            // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m/Goanna
            /ekioh(flow)\/([\w\.]+)/i,
            // Flow
            /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i,
            // KHTML/Tasman/Links
            /(icab)[\/ ]([23]\.[\d\.]+)/i
            // iCab
          ],
          [NAME, VERSION4],
          [
            /rv\:([\w\.]{1,9})\b.+(gecko)/i
            // Gecko
          ],
          [VERSION4, NAME]
        ],
        os: [
          [
            // Windows
            /microsoft (windows) (vista|xp)/i
            // Windows (iTunes)
          ],
          [NAME, VERSION4],
          [
            /(windows) nt 6\.2; (arm)/i,
            // Windows RT
            /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i,
            // Windows Phone
            /(windows)[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i
          ],
          [NAME, [VERSION4, strMapper, windowsVersionMap]],
          [
            /(win(?=3|9|n)|win 9x )([nt\d\.]+)/i
          ],
          [[NAME, "Windows"], [VERSION4, strMapper, windowsVersionMap]],
          [
            // iOS/macOS
            /ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i,
            // iOS
            /cfnetwork\/.+darwin/i
          ],
          [[VERSION4, /_/g, "."], [NAME, "iOS"]],
          [
            /(mac os x) ?([\w\. ]*)/i,
            /(macintosh|mac_powerpc\b)(?!.+haiku)/i
            // Mac OS
          ],
          [[NAME, "Mac OS"], [VERSION4, /_/g, "."]],
          [
            // Mobile OSes
            /droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i
            // Android-x86/HarmonyOS
          ],
          [VERSION4, NAME],
          [
            // Android/WebOS/QNX/Bada/RIM/Maemo/MeeGo/Sailfish OS
            /(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i,
            /(blackberry)\w*\/([\w\.]*)/i,
            // Blackberry
            /(tizen|kaios)[\/ ]([\w\.]+)/i,
            // Tizen/KaiOS
            /\((series40);/i
            // Series 40
          ],
          [NAME, VERSION4],
          [
            /\(bb(10);/i
            // BlackBerry 10
          ],
          [VERSION4, [NAME, BLACKBERRY]],
          [
            /(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i
            // Symbian
          ],
          [VERSION4, [NAME, "Symbian"]],
          [
            /mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i
            // Firefox OS
          ],
          [VERSION4, [NAME, FIREFOX + " OS"]],
          [
            /web0s;.+rt(tv)/i,
            /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i
            // WebOS
          ],
          [VERSION4, [NAME, "webOS"]],
          [
            // Google Chromecast
            /crkey\/([\d\.]+)/i
            // Google Chromecast
          ],
          [VERSION4, [NAME, CHROME + "cast"]],
          [
            /(cros) [\w]+ ([\w\.]+\w)/i
            // Chromium OS
          ],
          [[NAME, "Chromium OS"], VERSION4],
          [
            // Console
            /(nintendo|playstation) ([wids345portablevuch]+)/i,
            // Nintendo/Playstation
            /(xbox); +xbox ([^\);]+)/i,
            // Microsoft Xbox (360, One, X, S, Series X, Series S)
            // Other
            /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i,
            // Joli/Palm
            /(mint)[\/\(\) ]?(\w*)/i,
            // Mint
            /(mageia|vectorlinux)[; ]/i,
            // Mageia/VectorLinux
            /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i,
            // Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware/Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus/Raspbian/Plan9/Minix/RISCOS/Contiki/Deepin/Manjaro/elementary/Sabayon/Linspire
            /(hurd|linux) ?([\w\.]*)/i,
            // Hurd/Linux
            /(gnu) ?([\w\.]*)/i,
            // GNU
            /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i,
            // FreeBSD/NetBSD/OpenBSD/PC-BSD/GhostBSD/DragonFly
            /(haiku) (\w+)/i
            // Haiku
          ],
          [NAME, VERSION4],
          [
            /(sunos) ?([\w\.\d]*)/i
            // Solaris
          ],
          [[NAME, "Solaris"], VERSION4],
          [
            /((?:open)?solaris)[-\/ ]?([\w\.]*)/i,
            // Solaris
            /(aix) ((\d)(?=\.|\)| )[\w\.])*/i,
            // AIX
            /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux)/i,
            // BeOS/OS2/AmigaOS/MorphOS/OpenVMS/Fuchsia/HP-UX
            /(unix) ?([\w\.]*)/i
            // UNIX
          ],
          [NAME, VERSION4]
        ]
      };
      var UAParser4 = function(ua, extensions) {
        if (typeof ua === OBJ_TYPE) {
          extensions = ua;
          ua = undefined2;
        }
        if (!(this instanceof UAParser4)) {
          return new UAParser4(ua, extensions).getResult();
        }
        var _ua = ua || (typeof window2 !== UNDEF_TYPE && window2.navigator && window2.navigator.userAgent ? window2.navigator.userAgent : EMPTY);
        var _rgxmap = extensions ? extend(regexes, extensions) : regexes;
        this.getBrowser = function() {
          var _browser = {};
          _browser[NAME] = undefined2;
          _browser[VERSION4] = undefined2;
          rgxMapper.call(_browser, _ua, _rgxmap.browser);
          _browser.major = majorize(_browser.version);
          return _browser;
        };
        this.getCPU = function() {
          var _cpu = {};
          _cpu[ARCHITECTURE] = undefined2;
          rgxMapper.call(_cpu, _ua, _rgxmap.cpu);
          return _cpu;
        };
        this.getDevice = function() {
          var _device = {};
          _device[VENDOR] = undefined2;
          _device[MODEL] = undefined2;
          _device[TYPE] = undefined2;
          rgxMapper.call(_device, _ua, _rgxmap.device);
          return _device;
        };
        this.getEngine = function() {
          var _engine = {};
          _engine[NAME] = undefined2;
          _engine[VERSION4] = undefined2;
          rgxMapper.call(_engine, _ua, _rgxmap.engine);
          return _engine;
        };
        this.getOS = function() {
          var _os = {};
          _os[NAME] = undefined2;
          _os[VERSION4] = undefined2;
          rgxMapper.call(_os, _ua, _rgxmap.os);
          return _os;
        };
        this.getResult = function() {
          return {
            ua: this.getUA(),
            browser: this.getBrowser(),
            engine: this.getEngine(),
            os: this.getOS(),
            device: this.getDevice(),
            cpu: this.getCPU()
          };
        };
        this.getUA = function() {
          return _ua;
        };
        this.setUA = function(ua2) {
          _ua = typeof ua2 === STR_TYPE && ua2.length > UA_MAX_LENGTH ? trim(ua2, UA_MAX_LENGTH) : ua2;
          return this;
        };
        this.setUA(_ua);
        return this;
      };
      UAParser4.VERSION = LIBVERSION;
      UAParser4.BROWSER = enumerize([NAME, VERSION4, MAJOR]);
      UAParser4.CPU = enumerize([ARCHITECTURE]);
      UAParser4.DEVICE = enumerize([MODEL, VENDOR, TYPE, CONSOLE, MOBILE, SMARTTV, TABLET, WEARABLE, EMBEDDED]);
      UAParser4.ENGINE = UAParser4.OS = enumerize([NAME, VERSION4]);
      if (typeof exports !== UNDEF_TYPE) {
        if (typeof module !== UNDEF_TYPE && module.exports) {
          exports = module.exports = UAParser4;
        }
        exports.UAParser = UAParser4;
      } else {
        if (typeof define === FUNC_TYPE && define.amd) {
          define(function() {
            return UAParser4;
          });
        } else if (typeof window2 !== UNDEF_TYPE) {
          window2.UAParser = UAParser4;
        }
      }
      var $ = typeof window2 !== UNDEF_TYPE && (window2.jQuery || window2.Zepto);
      if ($ && !$.ua) {
        var parser2 = new UAParser4();
        $.ua = parser2.getResult();
        $.ua.get = function() {
          return parser2.getUA();
        };
        $.ua.set = function(ua) {
          parser2.setUA(ua);
          var result = parser2.getResult();
          for (var prop in result) {
            $.ua[prop] = result[prop];
          }
        };
      }
    })(typeof window === "object" ? window : exports);
  }
});

// node_modules/@zappar/zappar-threejs/lib/version.js
var VERSION = "2.5.2";

// node_modules/@zappar/zappar/lib/event.js
var Event = class {
  constructor() {
    this._funcs = [];
  }
  /**
   * Bind new handler function.
   * @param f - The callback function to be bound.
   */
  bind(f) {
    this._funcs.push(f);
  }
  /**
   * Unbind an existing handler function.
   * @param f - The callback function to be unbound.
   */
  unbind(f) {
    const indx = this._funcs.indexOf(f);
    if (indx > -1) {
      this._funcs.splice(indx, 1);
    }
  }
  /**
   * Emit an event, calling the bound handler functions.
   */
  emit() {
    for (let i = 0, total = this._funcs.length; i < total; i++) {
      this._funcs[i]();
    }
  }
};
var Event1 = class {
  constructor() {
    this._funcs = [];
  }
  /**
   * Bind new handler function.
   * @param f - The callback function to be bound.
  */
  bind(f) {
    this._funcs.push(f);
  }
  /**
   * Unbind an existing function.
   * @param f - The callback function to be unbound.
   */
  unbind(f) {
    const indx = this._funcs.indexOf(f);
    if (indx > -1) {
      this._funcs.splice(indx, 1);
    }
  }
  /**
   * Emit an event.
   *
   * @param a - The argument to pass to handler functions.
   */
  emit(a) {
    for (let i = 0, total = this._funcs.length; i < total; i++) {
      this._funcs[i](a);
    }
  }
};

// node_modules/@zappar/zappar-cv/lib/gen/zappar-native.js
var barcode_format_t;
(function(barcode_format_t2) {
  barcode_format_t2[barcode_format_t2["UNKNOWN"] = 131072] = "UNKNOWN";
  barcode_format_t2[barcode_format_t2["AZTEC"] = 1] = "AZTEC";
  barcode_format_t2[barcode_format_t2["CODABAR"] = 2] = "CODABAR";
  barcode_format_t2[barcode_format_t2["CODE_39"] = 4] = "CODE_39";
  barcode_format_t2[barcode_format_t2["CODE_93"] = 8] = "CODE_93";
  barcode_format_t2[barcode_format_t2["CODE_128"] = 16] = "CODE_128";
  barcode_format_t2[barcode_format_t2["DATA_MATRIX"] = 32] = "DATA_MATRIX";
  barcode_format_t2[barcode_format_t2["EAN_8"] = 64] = "EAN_8";
  barcode_format_t2[barcode_format_t2["EAN_13"] = 128] = "EAN_13";
  barcode_format_t2[barcode_format_t2["ITF"] = 256] = "ITF";
  barcode_format_t2[barcode_format_t2["MAXICODE"] = 512] = "MAXICODE";
  barcode_format_t2[barcode_format_t2["PDF_417"] = 1024] = "PDF_417";
  barcode_format_t2[barcode_format_t2["QR_CODE"] = 2048] = "QR_CODE";
  barcode_format_t2[barcode_format_t2["RSS_14"] = 4096] = "RSS_14";
  barcode_format_t2[barcode_format_t2["RSS_EXPANDED"] = 8192] = "RSS_EXPANDED";
  barcode_format_t2[barcode_format_t2["UPC_A"] = 16384] = "UPC_A";
  barcode_format_t2[barcode_format_t2["UPC_E"] = 32768] = "UPC_E";
  barcode_format_t2[barcode_format_t2["UPC_EAN_EXTENSION"] = 65536] = "UPC_EAN_EXTENSION";
  barcode_format_t2[barcode_format_t2["ALL"] = 131071] = "ALL";
})(barcode_format_t || (barcode_format_t = {}));
var face_landmark_name_t;
(function(face_landmark_name_t2) {
  face_landmark_name_t2[face_landmark_name_t2["EYE_LEFT"] = 0] = "EYE_LEFT";
  face_landmark_name_t2[face_landmark_name_t2["EYE_RIGHT"] = 1] = "EYE_RIGHT";
  face_landmark_name_t2[face_landmark_name_t2["EAR_LEFT"] = 2] = "EAR_LEFT";
  face_landmark_name_t2[face_landmark_name_t2["EAR_RIGHT"] = 3] = "EAR_RIGHT";
  face_landmark_name_t2[face_landmark_name_t2["NOSE_BRIDGE"] = 4] = "NOSE_BRIDGE";
  face_landmark_name_t2[face_landmark_name_t2["NOSE_TIP"] = 5] = "NOSE_TIP";
  face_landmark_name_t2[face_landmark_name_t2["NOSE_BASE"] = 6] = "NOSE_BASE";
  face_landmark_name_t2[face_landmark_name_t2["LIP_TOP"] = 7] = "LIP_TOP";
  face_landmark_name_t2[face_landmark_name_t2["LIP_BOTTOM"] = 8] = "LIP_BOTTOM";
  face_landmark_name_t2[face_landmark_name_t2["MOUTH_CENTER"] = 9] = "MOUTH_CENTER";
  face_landmark_name_t2[face_landmark_name_t2["CHIN"] = 10] = "CHIN";
  face_landmark_name_t2[face_landmark_name_t2["EYEBROW_LEFT"] = 11] = "EYEBROW_LEFT";
  face_landmark_name_t2[face_landmark_name_t2["EYEBROW_RIGHT"] = 12] = "EYEBROW_RIGHT";
})(face_landmark_name_t || (face_landmark_name_t = {}));
var instant_world_tracker_transform_orientation_t;
(function(instant_world_tracker_transform_orientation_t2) {
  instant_world_tracker_transform_orientation_t2[instant_world_tracker_transform_orientation_t2["WORLD"] = 3] = "WORLD";
  instant_world_tracker_transform_orientation_t2[instant_world_tracker_transform_orientation_t2["MINUS_Z_AWAY_FROM_USER"] = 4] = "MINUS_Z_AWAY_FROM_USER";
  instant_world_tracker_transform_orientation_t2[instant_world_tracker_transform_orientation_t2["MINUS_Z_HEADING"] = 5] = "MINUS_Z_HEADING";
  instant_world_tracker_transform_orientation_t2[instant_world_tracker_transform_orientation_t2["UNCHANGED"] = 6] = "UNCHANGED";
})(instant_world_tracker_transform_orientation_t || (instant_world_tracker_transform_orientation_t = {}));
var log_level_t;
(function(log_level_t2) {
  log_level_t2[log_level_t2["LOG_LEVEL_NONE"] = 0] = "LOG_LEVEL_NONE";
  log_level_t2[log_level_t2["LOG_LEVEL_ERROR"] = 1] = "LOG_LEVEL_ERROR";
  log_level_t2[log_level_t2["LOG_LEVEL_WARNING"] = 2] = "LOG_LEVEL_WARNING";
  log_level_t2[log_level_t2["LOG_LEVEL_VERBOSE"] = 3] = "LOG_LEVEL_VERBOSE";
})(log_level_t || (log_level_t = {}));
var frame_pixel_format_t;
(function(frame_pixel_format_t2) {
  frame_pixel_format_t2[frame_pixel_format_t2["FRAME_PIXEL_FORMAT_I420"] = 0] = "FRAME_PIXEL_FORMAT_I420";
  frame_pixel_format_t2[frame_pixel_format_t2["FRAME_PIXEL_FORMAT_I420A"] = 1] = "FRAME_PIXEL_FORMAT_I420A";
  frame_pixel_format_t2[frame_pixel_format_t2["FRAME_PIXEL_FORMAT_I422"] = 2] = "FRAME_PIXEL_FORMAT_I422";
  frame_pixel_format_t2[frame_pixel_format_t2["FRAME_PIXEL_FORMAT_I444"] = 3] = "FRAME_PIXEL_FORMAT_I444";
  frame_pixel_format_t2[frame_pixel_format_t2["FRAME_PIXEL_FORMAT_NV12"] = 4] = "FRAME_PIXEL_FORMAT_NV12";
  frame_pixel_format_t2[frame_pixel_format_t2["FRAME_PIXEL_FORMAT_RGBA"] = 5] = "FRAME_PIXEL_FORMAT_RGBA";
  frame_pixel_format_t2[frame_pixel_format_t2["FRAME_PIXEL_FORMAT_BGRA"] = 6] = "FRAME_PIXEL_FORMAT_BGRA";
  frame_pixel_format_t2[frame_pixel_format_t2["FRAME_PIXEL_FORMAT_Y"] = 7] = "FRAME_PIXEL_FORMAT_Y";
})(frame_pixel_format_t || (frame_pixel_format_t = {}));
var image_target_type_t;
(function(image_target_type_t2) {
  image_target_type_t2[image_target_type_t2["IMAGE_TRACKER_TYPE_PLANAR"] = 0] = "IMAGE_TRACKER_TYPE_PLANAR";
  image_target_type_t2[image_target_type_t2["IMAGE_TRACKER_TYPE_CYLINDRICAL"] = 1] = "IMAGE_TRACKER_TYPE_CYLINDRICAL";
  image_target_type_t2[image_target_type_t2["IMAGE_TRACKER_TYPE_CONICAL"] = 2] = "IMAGE_TRACKER_TYPE_CONICAL";
})(image_target_type_t || (image_target_type_t = {}));

// node_modules/@zappar/zappar-cv/lib/serializer.js
var MessageSerializer = class {
  constructor(_messageSender) {
    this._messageSender = _messageSender;
    this._freeBufferPool = [];
    this._buffer = new ArrayBuffer(16);
    this._i32View = new Int32Array(this._buffer);
    this._f32View = new Float32Array(this._buffer);
    this._f64View = new Float64Array(this._buffer);
    this._u8View = new Uint8Array(this._buffer);
    this._u8cView = new Uint8ClampedArray(this._buffer);
    this._u16View = new Uint16Array(this._buffer);
    this._u32View = new Uint32Array(this._buffer);
    this._offset = 1;
    this._startOffset = -1;
    this._timeoutSet = false;
    this._appender = {
      int: (i) => this.int(i),
      bool: (i) => this.int(i ? 1 : 0),
      float: (i) => this.float(i),
      string: (i) => this.string(i),
      dataWithLength: (i) => this.arrayBuffer(i),
      type: (i) => this.int(i),
      matrix4x4: (i) => this.float32ArrayBuffer(i),
      matrix3x3: (i) => this.float32ArrayBuffer(i),
      identityCoefficients: (i) => this.float32ArrayBuffer(i),
      expressionCoefficients: (i) => this.float32ArrayBuffer(i),
      cameraModel: (i) => this.float32ArrayBuffer(i),
      timestamp: (i) => this.double(i),
      barcodeFormat: (i) => this.int(i),
      faceLandmarkName: (i) => this.int(i),
      instantTrackerTransformOrientation: (i) => this.int(i),
      logLevel: (i) => this.int(i)
    };
    this._freeBufferPool.push(new ArrayBuffer(16));
    this._freeBufferPool.push(new ArrayBuffer(16));
  }
  bufferReturn(ab) {
    this._freeBufferPool.push(ab);
  }
  // public copySerializedData(): ArrayBuffer {
  //     let data = this._buffer.slice(0, this._offset * Int32Array.BYTES_PER_ELEMENT);
  //     this._offset = 0;
  //     this._startOffset = -1;
  //     return data;
  // }
  _ensureArrayBuffer(incremental) {
    let requirement = (this._offset + incremental + 8) * 4;
    if (this._buffer && this._buffer.byteLength >= requirement)
      return;
    let newBuffer = void 0;
    if (!newBuffer) {
      let nextPow2 = requirement;
      nextPow2--;
      nextPow2 |= nextPow2 >> 1;
      nextPow2 |= nextPow2 >> 2;
      nextPow2 |= nextPow2 >> 4;
      nextPow2 |= nextPow2 >> 8;
      nextPow2 |= nextPow2 >> 16;
      nextPow2++;
      newBuffer = new ArrayBuffer(nextPow2);
    }
    let oldView = this._buffer ? this._i32View : void 0;
    this._buffer = newBuffer;
    this._i32View = new Int32Array(this._buffer);
    this._f32View = new Float32Array(this._buffer);
    this._f64View = new Float64Array(this._buffer);
    this._u8View = new Uint8Array(this._buffer);
    this._u8cView = new Uint8ClampedArray(this._buffer);
    this._u16View = new Uint16Array(this._buffer);
    this._u32View = new Uint32Array(this._buffer);
    if (oldView)
      this._i32View.set(oldView.subarray(0, this._offset));
  }
  sendMessage(messageId, cb) {
    this._ensureArrayBuffer(4);
    this._startOffset = this._offset;
    this._i32View[this._offset + 1] = messageId;
    this._offset += 2;
    cb(this._appender);
    this._i32View[this._startOffset] = this._offset - this._startOffset;
    this._startOffset = -1;
    this._sendOneTime();
  }
  _sendOneTime() {
    if (this._timeoutSet === false) {
      this._timeoutSet = true;
      setTimeout(() => {
        this._timeoutSet = false;
        this._send();
      }, 0);
    }
  }
  _send() {
    if (this._freeBufferPool.length === 0) {
      this._sendOneTime();
      return;
    }
    this._i32View[0] = this._offset;
    this._messageSender(this._buffer);
    this._buffer = void 0;
    this._buffer = this._freeBufferPool.pop();
    this._i32View = new Int32Array(this._buffer);
    this._f32View = new Float32Array(this._buffer);
    this._f64View = new Float64Array(this._buffer);
    this._u8View = new Uint8Array(this._buffer);
    this._u8cView = new Uint8ClampedArray(this._buffer);
    this._u16View = new Uint16Array(this._buffer);
    this._u32View = new Uint32Array(this._buffer);
    this._offset = 1;
    this._startOffset = -1;
  }
  int(arg) {
    this._ensureArrayBuffer(1);
    this._i32View[this._offset] = arg;
    this._offset++;
  }
  double(arg) {
    this._ensureArrayBuffer(2);
    if (this._offset % 2 === 1)
      this._offset++;
    this._f64View[this._offset / 2] = arg;
    this._offset += 2;
  }
  float(arg) {
    this._ensureArrayBuffer(1);
    this._f32View[this._offset] = arg;
    this._offset++;
  }
  int32Array(args) {
    this._ensureArrayBuffer(args.length);
    for (let i = 0; i < args.length; ++i) {
      this._i32View[this._offset + i] = args[i];
    }
    this._offset += args.length;
  }
  float32Array(args) {
    this._ensureArrayBuffer(args.length);
    for (let i = 0; i < args.length; ++i) {
      this._f32View[this._offset + i] = args[i];
    }
    this._offset += args.length;
  }
  booleanArray(args) {
    this._ensureArrayBuffer(args.length);
    for (let i = 0; i < args.length; ++i) {
      this._i32View[this._offset + i] = args[i] ? 1 : 0;
    }
    this._offset += args.length;
  }
  uint8ArrayBuffer(data) {
    this._ensureArrayBuffer(data.byteLength / 4);
    this._i32View[this._offset] = data.byteLength;
    this._offset++;
    this._u8View.set(data, this._offset * 4);
    this._offset += data.byteLength >> 2;
    if ((data.byteLength & 3) !== 0)
      this._offset++;
  }
  arrayBuffer(data) {
    let view = new Uint8Array(data);
    this.uint8ArrayBuffer(view);
  }
  uint8ClampedArrayBuffer(data) {
    this._ensureArrayBuffer(data.byteLength / 4);
    this._i32View[this._offset] = data.byteLength;
    this._offset++;
    this._u8cView.set(data, this._offset * 4);
    this._offset += data.byteLength >> 2;
    if ((data.byteLength & 3) !== 0)
      this._offset++;
  }
  float32ArrayBuffer(data) {
    this._ensureArrayBuffer(data.byteLength / 4);
    this._i32View[this._offset] = data.length;
    this._offset++;
    this._f32View.set(data, this._offset);
    this._offset += data.length;
  }
  uint16ArrayBuffer(data) {
    this._ensureArrayBuffer(data.byteLength / 4);
    this._i32View[this._offset] = data.length;
    this._offset++;
    let u16Offset = this._offset * 2;
    this._u16View.set(data, u16Offset);
    this._offset += data.length >> 1;
    if ((data.length & 1) !== 0)
      this._offset++;
  }
  int32ArrayBuffer(data) {
    this._ensureArrayBuffer(data.byteLength / 4);
    this._i32View[this._offset] = data.length;
    this._offset++;
    this._i32View.set(data, this._offset);
    this._offset += data.length;
  }
  uint32ArrayBuffer(data) {
    this._ensureArrayBuffer(data.byteLength / 4);
    this._i32View[this._offset] = data.length;
    this._offset++;
    this._u32View.set(data, this._offset);
    this._offset += data.length;
  }
  string(data) {
    let encoder = new TextEncoder();
    let res = encoder.encode(data);
    this._ensureArrayBuffer(res.byteLength / 4);
    this._i32View[this._offset] = res.byteLength;
    this._offset++;
    this._u8View.set(res, this._offset * 4);
    this._offset += res.byteLength >> 2;
    if ((res.byteLength & 3) !== 0)
      this._offset++;
  }
};

// node_modules/@zappar/zappar-cv/lib/deserializer.js
var MessageDeserializer = class {
  constructor() {
    this._buffer = new ArrayBuffer(0);
    this._i32View = new Int32Array(this._buffer);
    this._f32View = new Float32Array(this._buffer);
    this._f64View = new Float64Array(this._buffer);
    this._u8View = new Uint8Array(this._buffer);
    this._u16View = new Uint16Array(this._buffer);
    this._u32View = new Uint32Array(this._buffer);
    this._offset = 0;
    this._length = 0;
    this._startOffset = -1;
    this._processor = {
      int: () => this._i32View[this._startOffset++],
      bool: () => this._i32View[this._startOffset++] === 1,
      type: () => this._i32View[this._startOffset++],
      float: () => this._f32View[this._startOffset++],
      timestamp: () => {
        if (this._startOffset % 2 === 1)
          this._startOffset++;
        let ret = this._f64View[this._startOffset / 2];
        this._startOffset += 2;
        return ret;
      },
      string: () => {
        let len3 = this._i32View[this._startOffset++];
        let decoder3 = new TextDecoder();
        let res = decoder3.decode(new Uint8Array(this._buffer, this._startOffset * 4, len3));
        this._startOffset += len3 >> 2;
        if ((len3 & 3) !== 0)
          this._startOffset++;
        return res;
      },
      dataWithLength: () => {
        let len3 = this._i32View[this._startOffset++];
        let ret = new Uint8Array(len3);
        ret.set(this._u8View.subarray(this._startOffset * 4, this._startOffset * 4 + len3));
        this._startOffset += ret.byteLength >> 2;
        if ((ret.byteLength & 3) !== 0)
          this._startOffset++;
        return ret.buffer;
      },
      matrix4x4: () => {
        let len3 = this._i32View[this._startOffset++];
        let ret = new Float32Array(len3);
        ret.set(this._f32View.subarray(this._startOffset, this._startOffset + 16));
        this._startOffset += len3;
        return ret;
      },
      matrix3x3: () => {
        let len3 = this._i32View[this._startOffset++];
        let ret = new Float32Array(len3);
        ret.set(this._f32View.subarray(this._startOffset, this._startOffset + 9));
        this._startOffset += len3;
        return ret;
      },
      identityCoefficients: () => {
        let len3 = this._i32View[this._startOffset++];
        let ret = new Float32Array(len3);
        ret.set(this._f32View.subarray(this._startOffset, this._startOffset + 50));
        this._startOffset += len3;
        return ret;
      },
      expressionCoefficients: () => {
        let len3 = this._i32View[this._startOffset++];
        let ret = new Float32Array(len3);
        ret.set(this._f32View.subarray(this._startOffset, this._startOffset + 29));
        this._startOffset += len3;
        return ret;
      },
      cameraModel: () => {
        let len3 = this._i32View[this._startOffset++];
        let ret = new Float32Array(len3);
        ret.set(this._f32View.subarray(this._startOffset, this._startOffset + 6));
        this._startOffset += len3;
        return ret;
      },
      barcodeFormat: () => this._i32View[this._startOffset++],
      faceLandmarkName: () => this._i32View[this._startOffset++],
      instantTrackerTransformOrientation: () => this._i32View[this._startOffset++],
      logLevel: () => this._i32View[this._startOffset++]
    };
  }
  setData(data) {
    this._buffer = data;
    this._i32View = new Int32Array(this._buffer);
    this._f32View = new Float32Array(this._buffer);
    this._f64View = new Float64Array(this._buffer);
    this._u8View = new Uint8Array(this._buffer);
    this._u16View = new Uint16Array(this._buffer);
    this._u32View = new Uint32Array(this._buffer);
    this._offset = 0;
    this._length = 0;
    if (data.byteLength >= 4) {
      this._offset = 1;
      this._length = this._i32View[0];
    }
    this._startOffset = -1;
  }
  hasMessage() {
    return this._offset + 1 < this._length;
  }
  forMessages(cb) {
    while (this.hasMessage()) {
      let len3 = this._i32View[this._offset];
      let messageId = this._i32View[this._offset + 1];
      this._startOffset = this._offset + 2;
      this._offset += len3;
      cb(messageId, this._processor);
    }
  }
};

// node_modules/@zappar/zappar-cv/lib/gen/zappar-client.js
var zappar_client = class {
  constructor(_messageSender) {
    this._messageSender = _messageSender;
    this._globalState = {
      log_level: 1
    };
    this.serializer = new MessageSerializer((ab) => {
      this._messageSender(ab);
    });
    this.deserializer = new MessageDeserializer();
    this._latestId = 1;
    this._pipeline_state_by_instance = /* @__PURE__ */ new Map();
    this._camera_source_state_by_instance = /* @__PURE__ */ new Map();
    this._sequence_source_state_by_instance = /* @__PURE__ */ new Map();
    this._image_tracker_state_by_instance = /* @__PURE__ */ new Map();
    this._face_tracker_state_by_instance = /* @__PURE__ */ new Map();
    this._face_mesh_state_by_instance = /* @__PURE__ */ new Map();
    this._face_landmark_state_by_instance = /* @__PURE__ */ new Map();
    this._barcode_finder_state_by_instance = /* @__PURE__ */ new Map();
    this._instant_world_tracker_state_by_instance = /* @__PURE__ */ new Map();
    this.impl = {
      log_level: () => {
        return this._globalState.log_level;
      },
      log_level_set: (level) => {
        this.serializer.sendMessage(34, (m) => {
          m.logLevel(level);
        });
      },
      analytics_project_id_set: (id, uid) => {
        this.serializer.sendMessage(31, (m) => {
          m.string(id);
          m.string(uid);
        });
      },
      // ####pipeline####
      pipeline_create: () => {
        let newId = this._latestId++;
        let s = {
          current_frame_user_data: 0,
          camera_model: new Float32Array([300, 300, 160, 120, 0, 0]),
          camera_pose: new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
          camera_frame_camera_attitude: new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
          camera_frame_device_attitude: new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
          frame_number: 0
        };
        this._pipeline_state_by_instance.set(newId, s);
        this.serializer.sendMessage(27, (m) => {
          m.type(newId);
        });
        return newId;
      },
      pipeline_destroy: (o) => {
        let s = this._pipeline_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        this._pipeline_state_by_instance.delete(o);
        this.serializer.sendMessage(28, (m) => {
          m.type(o);
        });
      },
      pipeline_frame_update: (o) => {
        let s = this._pipeline_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        this.serializer.sendMessage(9, (m) => {
          m.type(o);
        });
      },
      pipeline_frame_number: (o) => {
        let s = this._pipeline_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        return s.frame_number;
      },
      pipeline_camera_model: (o) => {
        let s = this._pipeline_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        return s.camera_model;
      },
      pipeline_camera_frame_user_data: (o) => {
        let s = this._pipeline_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        return s.current_frame_user_data;
      },
      pipeline_camera_frame_submit: (o, data, width, height, user_data, camera_to_device_transform, camera_model, user_facing) => {
        let s = this._pipeline_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        this.serializer.sendMessage(8, (m) => {
          m.type(o);
          m.dataWithLength(data);
          m.int(width);
          m.int(height);
          m.int(user_data);
          m.matrix4x4(camera_to_device_transform);
          m.cameraModel(camera_model);
          m.bool(user_facing);
        });
      },
      pipeline_camera_frame_submit_raw_pointer: (o, data, dataLength, format, width, height, user_data, camera_to_device_transform, rotation, camera_model, user_facing) => {
        let s = this._pipeline_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
      },
      pipeline_camera_frame_camera_attitude: (o) => {
        let s = this._pipeline_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        return s.camera_frame_camera_attitude;
      },
      pipeline_camera_frame_device_attitude: (o) => {
        let s = this._pipeline_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        return s.camera_frame_device_attitude;
      },
      pipeline_motion_accelerometer_submit: (o, time, x, y, z2) => {
        let s = this._pipeline_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        this.serializer.sendMessage(10, (m) => {
          m.type(o);
          m.timestamp(time);
          m.float(x);
          m.float(y);
          m.float(z2);
        });
      },
      pipeline_motion_rotation_rate_submit: (o, time, x, y, z2) => {
        let s = this._pipeline_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        this.serializer.sendMessage(11, (m) => {
          m.type(o);
          m.timestamp(time);
          m.float(x);
          m.float(y);
          m.float(z2);
        });
      },
      pipeline_motion_attitude_submit: (o, time, x, y, z2) => {
        let s = this._pipeline_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        this.serializer.sendMessage(12, (m) => {
          m.type(o);
          m.timestamp(time);
          m.float(x);
          m.float(y);
          m.float(z2);
        });
      },
      pipeline_motion_attitude_matrix_submit: (o, mat) => {
        let s = this._pipeline_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        this.serializer.sendMessage(13, (m) => {
          m.type(o);
          m.matrix4x4(mat);
        });
      },
      // ####camera_source####
      camera_source_create: (pipeline, device_id) => {
        let newId = this._latestId++;
        let s = {};
        this._camera_source_state_by_instance.set(newId, s);
        this.serializer.sendMessage(29, (m) => {
          m.type(newId);
          m.type(pipeline);
          m.string(device_id);
        });
        return newId;
      },
      camera_source_destroy: (o) => {
        let s = this._camera_source_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        this._camera_source_state_by_instance.delete(o);
        this.serializer.sendMessage(30, (m) => {
          m.type(o);
        });
      },
      // ####sequence_source####
      sequence_source_create: (pipeline) => {
        let newId = this._latestId++;
        let s = {};
        this._sequence_source_state_by_instance.set(newId, s);
        this.serializer.sendMessage(35, (m) => {
          m.type(newId);
          m.type(pipeline);
        });
        return newId;
      },
      sequence_source_destroy: (o) => {
        let s = this._sequence_source_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        this._sequence_source_state_by_instance.delete(o);
        this.serializer.sendMessage(36, (m) => {
          m.type(o);
        });
      },
      // ####image_tracker####
      image_tracker_create: (pipeline) => {
        let newId = this._latestId++;
        let s = {
          enabled: true,
          target_loaded_version: -1,
          anchor_count: 0,
          anchor_id: [],
          anchor_pose: []
        };
        this._image_tracker_state_by_instance.set(newId, s);
        this.serializer.sendMessage(2, (m) => {
          m.type(newId);
          m.type(pipeline);
        });
        return newId;
      },
      image_tracker_destroy: (o) => {
        let s = this._image_tracker_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        this._image_tracker_state_by_instance.delete(o);
        this.serializer.sendMessage(14, (m) => {
          m.type(o);
        });
      },
      image_tracker_target_load_from_memory: (o, data) => {
        let s = this._image_tracker_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        this.serializer.sendMessage(4, (m) => {
          m.type(o);
          m.dataWithLength(data);
        });
      },
      image_tracker_target_loaded_version: (o) => {
        let s = this._image_tracker_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        return s.target_loaded_version;
      },
      image_tracker_enabled: (o) => {
        let s = this._image_tracker_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        return s.enabled;
      },
      image_tracker_enabled_set: (o, enabled) => {
        let s = this._image_tracker_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        this.serializer.sendMessage(3, (m) => {
          m.type(o);
          m.bool(enabled);
        });
      },
      image_tracker_anchor_count: (o) => {
        let s = this._image_tracker_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        return s.anchor_count;
      },
      image_tracker_anchor_id: (o, indx) => {
        let s = this._image_tracker_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        return s.anchor_id[indx];
      },
      image_tracker_anchor_pose_raw: (o, indx) => {
        let s = this._image_tracker_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        return s.anchor_pose[indx];
      },
      // ####face_tracker####
      face_tracker_create: (pipeline) => {
        let newId = this._latestId++;
        let s = {
          enabled: true,
          model_loaded: -1,
          max_faces: 1,
          anchor_count: 0,
          anchor_id: [],
          anchor_pose: [],
          anchor_identity_coefficients: [],
          anchor_expression_coefficients: []
        };
        this._face_tracker_state_by_instance.set(newId, s);
        this.serializer.sendMessage(20, (m) => {
          m.type(newId);
          m.type(pipeline);
        });
        return newId;
      },
      face_tracker_destroy: (o) => {
        let s = this._face_tracker_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        this._face_tracker_state_by_instance.delete(o);
        this.serializer.sendMessage(21, (m) => {
          m.type(o);
        });
      },
      face_tracker_model_load_from_memory: (o, data) => {
        let s = this._face_tracker_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        this.serializer.sendMessage(22, (m) => {
          m.type(o);
          m.dataWithLength(data);
        });
      },
      face_tracker_model_loaded_version: (o) => {
        let s = this._face_tracker_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        return s.model_loaded;
      },
      face_tracker_enabled_set: (o, enabled) => {
        let s = this._face_tracker_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        this.serializer.sendMessage(23, (m) => {
          m.type(o);
          m.bool(enabled);
        });
      },
      face_tracker_enabled: (o) => {
        let s = this._face_tracker_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        return s.enabled;
      },
      face_tracker_max_faces_set: (o, num) => {
        let s = this._face_tracker_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        this.serializer.sendMessage(24, (m) => {
          m.type(o);
          m.int(num);
        });
      },
      face_tracker_max_faces: (o) => {
        let s = this._face_tracker_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        return s.max_faces;
      },
      face_tracker_anchor_count: (o) => {
        let s = this._face_tracker_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        return s.anchor_count;
      },
      face_tracker_anchor_id: (o, indx) => {
        let s = this._face_tracker_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        return s.anchor_id[indx];
      },
      face_tracker_anchor_pose_raw: (o, indx) => {
        let s = this._face_tracker_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        return s.anchor_pose[indx];
      },
      face_tracker_anchor_identity_coefficients: (o, indx) => {
        let s = this._face_tracker_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        return s.anchor_identity_coefficients[indx];
      },
      face_tracker_anchor_expression_coefficients: (o, indx) => {
        let s = this._face_tracker_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        return s.anchor_expression_coefficients[indx];
      },
      // ####face_mesh####
      face_mesh_create: () => {
        let newId = this._latestId++;
        let s = {};
        this._face_mesh_state_by_instance.set(newId, s);
        this.serializer.sendMessage(25, (m) => {
          m.type(newId);
        });
        return newId;
      },
      face_mesh_destroy: (o) => {
        let s = this._face_mesh_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        this._face_mesh_state_by_instance.delete(o);
        this.serializer.sendMessage(26, (m) => {
          m.type(o);
        });
      },
      // ####face_landmark####
      face_landmark_create: (landmark) => {
        let newId = this._latestId++;
        let s = {};
        this._face_landmark_state_by_instance.set(newId, s);
        this.serializer.sendMessage(32, (m) => {
          m.type(newId);
          m.faceLandmarkName(landmark);
        });
        return newId;
      },
      face_landmark_destroy: (o) => {
        let s = this._face_landmark_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        this._face_landmark_state_by_instance.delete(o);
        this.serializer.sendMessage(33, (m) => {
          m.type(o);
        });
      },
      // ####barcode_finder####
      barcode_finder_create: (pipeline) => {
        let newId = this._latestId++;
        let s = {
          enabled: true,
          number_found: 0,
          found_text: [],
          found_format: [],
          formats: (1 << 17) - 1
        };
        this._barcode_finder_state_by_instance.set(newId, s);
        this.serializer.sendMessage(16, (m) => {
          m.type(newId);
          m.type(pipeline);
        });
        return newId;
      },
      barcode_finder_destroy: (o) => {
        let s = this._barcode_finder_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        this._barcode_finder_state_by_instance.delete(o);
        this.serializer.sendMessage(17, (m) => {
          m.type(o);
        });
      },
      barcode_finder_enabled_set: (o, enabled) => {
        let s = this._barcode_finder_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        this.serializer.sendMessage(18, (m) => {
          m.type(o);
          m.bool(enabled);
        });
      },
      barcode_finder_enabled: (o) => {
        let s = this._barcode_finder_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        return s.enabled;
      },
      barcode_finder_found_number: (o) => {
        let s = this._barcode_finder_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        return s.number_found;
      },
      barcode_finder_found_text: (o, indx) => {
        let s = this._barcode_finder_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        return s.found_text[indx];
      },
      barcode_finder_found_format: (o, indx) => {
        let s = this._barcode_finder_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        return s.found_format[indx];
      },
      barcode_finder_formats: (o) => {
        let s = this._barcode_finder_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        return s.formats;
      },
      barcode_finder_formats_set: (o, f) => {
        let s = this._barcode_finder_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        this.serializer.sendMessage(19, (m) => {
          m.type(o);
          m.barcodeFormat(f);
        });
      },
      // ####instant_world_tracker####
      instant_world_tracker_create: (pipeline) => {
        let newId = this._latestId++;
        let s = {
          enabled: true,
          pose: new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])
        };
        this._instant_world_tracker_state_by_instance.set(newId, s);
        this.serializer.sendMessage(5, (m) => {
          m.type(newId);
          m.type(pipeline);
        });
        return newId;
      },
      instant_world_tracker_destroy: (o) => {
        let s = this._instant_world_tracker_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        this._instant_world_tracker_state_by_instance.delete(o);
        this.serializer.sendMessage(15, (m) => {
          m.type(o);
        });
      },
      instant_world_tracker_enabled_set: (o, enabled) => {
        let s = this._instant_world_tracker_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        this.serializer.sendMessage(6, (m) => {
          m.type(o);
          m.bool(enabled);
        });
      },
      instant_world_tracker_enabled: (o) => {
        let s = this._instant_world_tracker_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        return s.enabled;
      },
      instant_world_tracker_anchor_pose_raw: (o) => {
        let s = this._instant_world_tracker_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        return s.pose;
      },
      instant_world_tracker_anchor_pose_set_from_camera_offset_raw: (o, x, y, z2, orientation) => {
        let s = this._instant_world_tracker_state_by_instance.get(o);
        if (!s)
          throw new Error("This object has been destroyed");
        this.serializer.sendMessage(7, (m) => {
          m.type(o);
          m.float(x);
          m.float(y);
          m.float(z2);
          m.instantTrackerTransformOrientation(orientation);
        });
      }
    };
  }
  processMessages(a) {
    this.deserializer.setData(a);
    this.deserializer.forMessages((messageId, msg) => {
      switch (messageId) {
        case 7: {
          let handle = msg.type();
          let inst = this._pipeline_state_by_instance.get(handle);
          if (!inst)
            return;
          inst.frame_number = msg.int();
          break;
        }
        case 6: {
          let handle = msg.type();
          let inst = this._pipeline_state_by_instance.get(handle);
          if (!inst)
            return;
          inst.camera_model = msg.cameraModel();
          break;
        }
        case 5: {
          let handle = msg.type();
          let inst = this._pipeline_state_by_instance.get(handle);
          if (!inst)
            return;
          inst.current_frame_user_data = msg.int();
          break;
        }
        case 11: {
          let handle = msg.type();
          let inst = this._pipeline_state_by_instance.get(handle);
          if (!inst)
            return;
          inst.camera_frame_camera_attitude = msg.matrix4x4();
          break;
        }
        case 12: {
          let handle = msg.type();
          let inst = this._pipeline_state_by_instance.get(handle);
          if (!inst)
            return;
          inst.camera_frame_device_attitude = msg.matrix4x4();
          break;
        }
        case 19: {
          let handle = msg.type();
          let inst = this._image_tracker_state_by_instance.get(handle);
          if (!inst)
            return;
          inst.target_loaded_version = msg.int();
          break;
        }
        case 1: {
          let handle = msg.type();
          let inst = this._image_tracker_state_by_instance.get(handle);
          if (!inst)
            return;
          inst.anchor_count = msg.int();
          break;
        }
        case 2: {
          let handle = msg.type();
          let inst = this._image_tracker_state_by_instance.get(handle);
          if (!inst)
            return;
          let indx = msg.int();
          inst.anchor_id[indx] = msg.string();
          break;
        }
        case 3: {
          let handle = msg.type();
          let inst = this._image_tracker_state_by_instance.get(handle);
          if (!inst)
            return;
          let indx = msg.int();
          inst.anchor_pose[indx] = msg.matrix4x4();
          break;
        }
        case 18: {
          let handle = msg.type();
          let inst = this._face_tracker_state_by_instance.get(handle);
          if (!inst)
            return;
          inst.model_loaded = msg.int();
          break;
        }
        case 13: {
          let handle = msg.type();
          let inst = this._face_tracker_state_by_instance.get(handle);
          if (!inst)
            return;
          inst.anchor_count = msg.int();
          break;
        }
        case 14: {
          let handle = msg.type();
          let inst = this._face_tracker_state_by_instance.get(handle);
          if (!inst)
            return;
          let indx = msg.int();
          inst.anchor_id[indx] = msg.string();
          break;
        }
        case 15: {
          let handle = msg.type();
          let inst = this._face_tracker_state_by_instance.get(handle);
          if (!inst)
            return;
          let indx = msg.int();
          inst.anchor_pose[indx] = msg.matrix4x4();
          break;
        }
        case 16: {
          let handle = msg.type();
          let inst = this._face_tracker_state_by_instance.get(handle);
          if (!inst)
            return;
          let indx = msg.int();
          inst.anchor_identity_coefficients[indx] = msg.identityCoefficients();
          break;
        }
        case 17: {
          let handle = msg.type();
          let inst = this._face_tracker_state_by_instance.get(handle);
          if (!inst)
            return;
          let indx = msg.int();
          inst.anchor_expression_coefficients[indx] = msg.expressionCoefficients();
          break;
        }
        case 8: {
          let handle = msg.type();
          let inst = this._barcode_finder_state_by_instance.get(handle);
          if (!inst)
            return;
          inst.number_found = msg.int();
          break;
        }
        case 9: {
          let handle = msg.type();
          let inst = this._barcode_finder_state_by_instance.get(handle);
          if (!inst)
            return;
          let indx = msg.int();
          inst.found_text[indx] = msg.string();
          break;
        }
        case 10: {
          let handle = msg.type();
          let inst = this._barcode_finder_state_by_instance.get(handle);
          if (!inst)
            return;
          let indx = msg.int();
          inst.found_format[indx] = msg.barcodeFormat();
          break;
        }
        case 4: {
          let handle = msg.type();
          let inst = this._instant_world_tracker_state_by_instance.get(handle);
          if (!inst)
            return;
          inst.pose = msg.matrix4x4();
          break;
        }
      }
    });
  }
};

// node_modules/@zappar/zappar-cv/lib/shader.js
function compileShader(gl, type, src) {
  let ret = gl.createShader(type);
  if (!ret)
    throw new Error("Unable to create shader");
  gl.shaderSource(ret, src);
  gl.compileShader(ret);
  let msg = gl.getShaderInfoLog(ret);
  if (msg && msg.trim().length > 0)
    throw new Error("Shader compile error: " + msg);
  return ret;
}
function linkProgram(gl, prog) {
  gl.linkProgram(prog);
  let msg = gl.getProgramInfoLog(prog);
  if (msg && msg.trim().length > 0)
    throw new Error("Unable to link: " + msg);
}

// node_modules/@zappar/zappar-cv/lib/drawplane.js
var shader;
var vbo;
var uvbo;
var texturesByUrl = {};
function disposeDrawPlane() {
  shader = void 0;
  vbo = void 0;
  uvbo = void 0;
  texturesByUrl = {};
}
function generate(gl) {
  if (vbo)
    return vbo;
  vbo = gl.createBuffer();
  if (!vbo)
    throw new Error("Unable to create buffer object");
  let coords = [
    -0.5,
    0.125,
    0,
    -0.5,
    -0.125,
    0,
    0.5,
    0.125,
    0,
    0.5,
    -0.125,
    0
  ];
  gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(coords), gl.STATIC_DRAW);
  gl.bindBuffer(gl.ARRAY_BUFFER, null);
  return vbo;
}
function generateUVBO(gl) {
  if (uvbo)
    return uvbo;
  uvbo = gl.createBuffer();
  if (!uvbo)
    throw new Error("Unable to create buffer object");
  let coords = [
    0,
    1,
    0,
    0,
    1,
    1,
    1,
    0
  ];
  gl.bindBuffer(gl.ARRAY_BUFFER, uvbo);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(coords), gl.STATIC_DRAW);
  gl.bindBuffer(gl.ARRAY_BUFFER, null);
  return uvbo;
}
function drawPlane(gl, projectionMatrix2, cameraMatrix, targetMatrix, textureUrl) {
  let shader2 = getShader(gl);
  let v = generate(gl);
  let uvbo2 = generateUVBO(gl);
  gl.disable(gl.DEPTH_TEST);
  gl.useProgram(shader2.prog);
  gl.uniformMatrix4fv(shader2.unif_proj, false, projectionMatrix2);
  gl.uniformMatrix4fv(shader2.unif_camera, false, cameraMatrix);
  gl.uniformMatrix4fv(shader2.unif_matrix, false, targetMatrix);
  gl.bindBuffer(gl.ARRAY_BUFFER, v);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, loadTexture(gl, textureUrl));
  gl.uniform1i(shader2.unif_skinSampler, 0);
  gl.vertexAttribPointer(shader2.attr_position, 3, gl.FLOAT, false, 3 * 4, 0);
  gl.enableVertexAttribArray(shader2.attr_position);
  gl.bindBuffer(gl.ARRAY_BUFFER, uvbo2);
  gl.vertexAttribPointer(shader2.attr_textureCoord, 2, gl.FLOAT, false, 2 * 4, 0);
  gl.enableVertexAttribArray(shader2.attr_textureCoord);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  gl.disableVertexAttribArray(shader2.attr_position);
  gl.disableVertexAttribArray(shader2.attr_textureCoord);
  gl.bindBuffer(gl.ARRAY_BUFFER, null);
}
var vertexShaderSrc = `
#ifndef GL_ES
#define highp
#define mediump
#define lowp
#endif

uniform mat4 projMatrix;
uniform mat4 cameraMatrix;
uniform mat4 modelViewMatrix;
attribute vec4 position;
attribute vec2 textureCoord;

varying highp vec2 vTextureCoord;

void main()
{
    gl_Position = projMatrix * cameraMatrix * modelViewMatrix * position;
    vTextureCoord = textureCoord;
}`;
var fragmentShaderSrc = `
#define highp mediump
#ifdef GL_ES
    // define default precision for float, vec, mat.
    precision highp float;
#else
#define highp
#define mediump
#define lowp
#endif

varying highp vec2 vTextureCoord;
uniform sampler2D skinSampler;

void main()
{
    gl_FragColor = texture2D(skinSampler, vTextureCoord);
}`;
function getShader(gl) {
  if (shader)
    return shader;
  let prog = gl.createProgram();
  if (!prog)
    throw new Error("Unable to create program");
  let vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexShaderSrc);
  let fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSrc);
  gl.attachShader(prog, vertexShader);
  gl.attachShader(prog, fragmentShader);
  linkProgram(gl, prog);
  let unif_proj = gl.getUniformLocation(prog, "projMatrix");
  if (!unif_proj)
    throw new Error("Unable to get uniform location projMatrix");
  let unif_matrix = gl.getUniformLocation(prog, "modelViewMatrix");
  if (!unif_matrix)
    throw new Error("Unable to get uniform location modelViewMatrix");
  let unif_camera = gl.getUniformLocation(prog, "cameraMatrix");
  if (!unif_camera)
    throw new Error("Unable to get uniform location cameraMatrix");
  let unif_skinSampler = gl.getUniformLocation(prog, "skinSampler");
  if (!unif_skinSampler)
    throw new Error("Unable to get uniform location skinSampler");
  shader = {
    prog,
    unif_matrix,
    unif_proj,
    unif_camera,
    unif_skinSampler,
    attr_position: gl.getAttribLocation(prog, "position"),
    attr_textureCoord: gl.getAttribLocation(prog, "textureCoord")
  };
  return shader;
}
function loadTexture(gl, url) {
  if (texturesByUrl[url])
    return texturesByUrl[url];
  let texture = gl.createTexture();
  if (!texture)
    throw new Error("Unable to create texture");
  texturesByUrl[url] = texture;
  gl.bindTexture(gl.TEXTURE_2D, texture);
  const level = 0;
  const internalFormat = gl.RGBA;
  const width = 1;
  const height = 1;
  const border = 0;
  const srcFormat = gl.RGBA;
  const srcType = gl.UNSIGNED_BYTE;
  const pixel = new Uint8Array([0, 0, 255, 255]);
  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
  gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, width, height, border, srcFormat, srcType, pixel);
  const image = new Image();
  image.onload = function() {
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, srcFormat, srcType, image);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  };
  image.src = url;
  return texture;
}

// node_modules/gl-matrix/esm/common.js
var EPSILON = 1e-6;
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
var RANDOM = Math.random;
var degree = Math.PI / 180;
if (!Math.hypot) Math.hypot = function() {
  var y = 0, i = arguments.length;
  while (i--) {
    y += arguments[i] * arguments[i];
  }
  return Math.sqrt(y);
};

// node_modules/gl-matrix/esm/mat3.js
function create() {
  var out = new ARRAY_TYPE(9);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}

// node_modules/gl-matrix/esm/mat4.js
var mat4_exports = {};
__export(mat4_exports, {
  add: () => add,
  adjoint: () => adjoint,
  clone: () => clone,
  copy: () => copy,
  create: () => create2,
  determinant: () => determinant,
  equals: () => equals,
  exactEquals: () => exactEquals,
  frob: () => frob,
  fromQuat: () => fromQuat,
  fromQuat2: () => fromQuat2,
  fromRotation: () => fromRotation,
  fromRotationTranslation: () => fromRotationTranslation,
  fromRotationTranslationScale: () => fromRotationTranslationScale,
  fromRotationTranslationScaleOrigin: () => fromRotationTranslationScaleOrigin,
  fromScaling: () => fromScaling,
  fromTranslation: () => fromTranslation,
  fromValues: () => fromValues,
  fromXRotation: () => fromXRotation,
  fromYRotation: () => fromYRotation,
  fromZRotation: () => fromZRotation,
  frustum: () => frustum,
  getRotation: () => getRotation,
  getScaling: () => getScaling,
  getTranslation: () => getTranslation,
  identity: () => identity,
  invert: () => invert,
  lookAt: () => lookAt,
  mul: () => mul,
  multiply: () => multiply,
  multiplyScalar: () => multiplyScalar,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd,
  ortho: () => ortho,
  orthoNO: () => orthoNO,
  orthoZO: () => orthoZO,
  perspective: () => perspective,
  perspectiveFromFieldOfView: () => perspectiveFromFieldOfView,
  perspectiveNO: () => perspectiveNO,
  perspectiveZO: () => perspectiveZO,
  rotate: () => rotate,
  rotateX: () => rotateX,
  rotateY: () => rotateY,
  rotateZ: () => rotateZ,
  scale: () => scale,
  set: () => set,
  str: () => str,
  sub: () => sub,
  subtract: () => subtract,
  targetTo: () => targetTo,
  translate: () => translate,
  transpose: () => transpose
});
function create2() {
  var out = new ARRAY_TYPE(16);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }
  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
function clone(a) {
  var out = new ARRAY_TYPE(16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function transpose(out, a) {
  if (out === a) {
    var a01 = a[1], a02 = a[2], a03 = a[3];
    var a12 = a[6], a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }
  return out;
}
function invert(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
function adjoint(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
function determinant(a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
function multiply(out, a, b) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
function translate(out, a, v) {
  var x = v[0], y = v[1], z2 = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z2 + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z2 + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z2 + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z2 + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z2 + a[12];
    out[13] = a01 * x + a11 * y + a21 * z2 + a[13];
    out[14] = a02 * x + a12 * y + a22 * z2 + a[14];
    out[15] = a03 * x + a13 * y + a23 * z2 + a[15];
  }
  return out;
}
function scale(out, a, v) {
  var x = v[0], y = v[1], z2 = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z2;
  out[9] = a[9] * z2;
  out[10] = a[10] * z2;
  out[11] = a[11] * z2;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function rotate(out, a, rad, axis) {
  var x = axis[0], y = axis[1], z2 = axis[2];
  var len3 = Math.hypot(x, y, z2);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;
  if (len3 < EPSILON) {
    return null;
  }
  len3 = 1 / len3;
  x *= len3;
  y *= len3;
  z2 *= len3;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11];
  b00 = x * x * t + c;
  b01 = y * x * t + z2 * s;
  b02 = z2 * x * t - y * s;
  b10 = x * y * t - z2 * s;
  b11 = y * y * t + c;
  b12 = z2 * y * t + x * s;
  b20 = x * z2 * t + y * s;
  b21 = y * z2 * t - x * s;
  b22 = z2 * z2 * t + c;
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;
  if (a !== out) {
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  return out;
}
function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  if (a !== out) {
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotation(out, rad, axis) {
  var x = axis[0], y = axis[1], z2 = axis[2];
  var len3 = Math.hypot(x, y, z2);
  var s, c, t;
  if (len3 < EPSILON) {
    return null;
  }
  len3 = 1 / len3;
  x *= len3;
  y *= len3;
  z2 *= len3;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  out[0] = x * x * t + c;
  out[1] = y * x * t + z2 * s;
  out[2] = z2 * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z2 * s;
  out[5] = y * y * t + c;
  out[6] = z2 * y * t + x * s;
  out[7] = 0;
  out[8] = x * z2 * t + y * s;
  out[9] = y * z2 * t - x * s;
  out[10] = z2 * z2 * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotationTranslation(out, q, v) {
  var x = q[0], y = q[1], z2 = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z22 = z2 + z2;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z22;
  var yy = y * y2;
  var yz = y * z22;
  var zz = z2 * z22;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z22;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromQuat2(out, a) {
  var translation = new ARRAY_TYPE(3);
  var bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw;
  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }
  fromRotationTranslation(out, a, translation);
  return out;
}
function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
function getRotation(out, mat) {
  var scaling = new ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;
  if (trace > 0) {
    S = Math.sqrt(trace + 1) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }
  return out;
}
function fromRotationTranslationScale(out, q, v, s) {
  var x = q[0], y = q[1], z2 = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z22 = z2 + z2;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z22;
  var yy = y * y2;
  var yz = y * z22;
  var zz = z2 * z22;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z22;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  var x = q[0], y = q[1], z2 = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z22 = z2 + z2;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z22;
  var yy = y * y2;
  var yz = y * z22;
  var zz = z2 * z22;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z22;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
function fromQuat(out, q) {
  var x = q[0], y = q[1], z2 = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z22 = z2 + z2;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z2 * x2;
  var zy = z2 * y2;
  var zz = z2 * z22;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z22;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
function perspectiveNO(out, fovy, aspect, near, far) {
  var f = 1 / Math.tan(fovy / 2), nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }
  return out;
}
var perspective = perspectiveNO;
function perspectiveZO(out, fovy, aspect, near, far) {
  var f = 1 / Math.tan(fovy / 2), nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = far * nf;
    out[14] = far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -near;
  }
  return out;
}
function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
  var xScale = 2 / (leftTan + rightTan);
  var yScale = 2 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = yScale;
  out[6] = 0;
  out[7] = 0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near / (near - far);
  out[15] = 0;
  return out;
}
function orthoNO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
var ortho = orthoNO;
function orthoZO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = near * nf;
  out[15] = 1;
  return out;
}
function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len3;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];
  if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
    return identity(out);
  }
  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len3 = 1 / Math.hypot(z0, z1, z2);
  z0 *= len3;
  z1 *= len3;
  z2 *= len3;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len3 = Math.hypot(x0, x1, x2);
  if (!len3) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len3 = 1 / len3;
    x0 *= len3;
    x1 *= len3;
    x2 *= len3;
  }
  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len3 = Math.hypot(y0, y1, y2);
  if (!len3) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len3 = 1 / len3;
    y0 *= len3;
    y1 *= len3;
    y2 *= len3;
  }
  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
function targetTo(out, eye, target, up) {
  var eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2];
  var z0 = eyex - target[0], z1 = eyey - target[1], z2 = eyez - target[2];
  var len3 = z0 * z0 + z1 * z1 + z2 * z2;
  if (len3 > 0) {
    len3 = 1 / Math.sqrt(len3);
    z0 *= len3;
    z1 *= len3;
    z2 *= len3;
  }
  var x0 = upy * z2 - upz * z1, x1 = upz * z0 - upx * z2, x2 = upx * z1 - upy * z0;
  len3 = x0 * x0 + x1 * x1 + x2 * x2;
  if (len3 > 0) {
    len3 = 1 / Math.sqrt(len3);
    x0 *= len3;
    x1 *= len3;
    x2 *= len3;
  }
  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
function str(a) {
  return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
}
function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
}
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}
function multiplyScalarAndAdd(out, a, b, scale5) {
  out[0] = a[0] + b[0] * scale5;
  out[1] = a[1] + b[1] * scale5;
  out[2] = a[2] + b[2] * scale5;
  out[3] = a[3] + b[3] * scale5;
  out[4] = a[4] + b[4] * scale5;
  out[5] = a[5] + b[5] * scale5;
  out[6] = a[6] + b[6] * scale5;
  out[7] = a[7] + b[7] * scale5;
  out[8] = a[8] + b[8] * scale5;
  out[9] = a[9] + b[9] * scale5;
  out[10] = a[10] + b[10] * scale5;
  out[11] = a[11] + b[11] * scale5;
  out[12] = a[12] + b[12] * scale5;
  out[13] = a[13] + b[13] * scale5;
  out[14] = a[14] + b[14] * scale5;
  out[15] = a[15] + b[15] * scale5;
  return out;
}
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
function equals(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7];
  var a8 = a[8], a9 = a[9], a10 = a[10], a11 = a[11];
  var a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  var b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
  var b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11];
  var b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1, Math.abs(a15), Math.abs(b15));
}
var mul = multiply;
var sub = subtract;

// node_modules/gl-matrix/esm/vec3.js
var vec3_exports = {};
__export(vec3_exports, {
  add: () => add2,
  angle: () => angle,
  bezier: () => bezier,
  ceil: () => ceil,
  clone: () => clone2,
  copy: () => copy2,
  create: () => create3,
  cross: () => cross,
  dist: () => dist,
  distance: () => distance,
  div: () => div,
  divide: () => divide,
  dot: () => dot,
  equals: () => equals2,
  exactEquals: () => exactEquals2,
  floor: () => floor,
  forEach: () => forEach,
  fromValues: () => fromValues2,
  hermite: () => hermite,
  inverse: () => inverse,
  len: () => len,
  length: () => length,
  lerp: () => lerp,
  max: () => max,
  min: () => min,
  mul: () => mul2,
  multiply: () => multiply2,
  negate: () => negate,
  normalize: () => normalize,
  random: () => random,
  rotateX: () => rotateX2,
  rotateY: () => rotateY2,
  rotateZ: () => rotateZ2,
  round: () => round,
  scale: () => scale2,
  scaleAndAdd: () => scaleAndAdd,
  set: () => set2,
  sqrDist: () => sqrDist,
  sqrLen: () => sqrLen,
  squaredDistance: () => squaredDistance,
  squaredLength: () => squaredLength,
  str: () => str2,
  sub: () => sub2,
  subtract: () => subtract2,
  transformMat3: () => transformMat3,
  transformMat4: () => transformMat4,
  transformQuat: () => transformQuat,
  zero: () => zero
});
function create3() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function clone2(a) {
  var out = new ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function length(a) {
  var x = a[0];
  var y = a[1];
  var z2 = a[2];
  return Math.hypot(x, y, z2);
}
function fromValues2(x, y, z2) {
  var out = new ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z2;
  return out;
}
function copy2(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function set2(out, x, y, z2) {
  out[0] = x;
  out[1] = y;
  out[2] = z2;
  return out;
}
function add2(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
function subtract2(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
function multiply2(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
function scale2(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
function scaleAndAdd(out, a, b, scale5) {
  out[0] = a[0] + b[0] * scale5;
  out[1] = a[1] + b[1] * scale5;
  out[2] = a[2] + b[2] * scale5;
  return out;
}
function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z2 = b[2] - a[2];
  return Math.hypot(x, y, z2);
}
function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z2 = b[2] - a[2];
  return x * x + y * y + z2 * z2;
}
function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z2 = a[2];
  return x * x + y * y + z2 * z2;
}
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
function inverse(out, a) {
  out[0] = 1 / a[0];
  out[1] = 1 / a[1];
  out[2] = 1 / a[2];
  return out;
}
function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z2 = a[2];
  var len3 = x * x + y * y + z2 * z2;
  if (len3 > 0) {
    len3 = 1 / Math.sqrt(len3);
  }
  out[0] = a[0] * len3;
  out[1] = a[1] * len3;
  out[2] = a[2] * len3;
  return out;
}
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function cross(out, a, b) {
  var ax = a[0], ay = a[1], az = a[2];
  var bx = b[0], by = b[1], bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
function random(out, scale5) {
  scale5 = scale5 || 1;
  var r = RANDOM() * 2 * Math.PI;
  var z2 = RANDOM() * 2 - 1;
  var zScale = Math.sqrt(1 - z2 * z2) * scale5;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z2 * scale5;
  return out;
}
function transformMat4(out, a, m) {
  var x = a[0], y = a[1], z2 = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z2 + m[15];
  w = w || 1;
  out[0] = (m[0] * x + m[4] * y + m[8] * z2 + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z2 + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z2 + m[14]) / w;
  return out;
}
function transformMat3(out, a, m) {
  var x = a[0], y = a[1], z2 = a[2];
  out[0] = x * m[0] + y * m[3] + z2 * m[6];
  out[1] = x * m[1] + y * m[4] + z2 * m[7];
  out[2] = x * m[2] + y * m[5] + z2 * m[8];
  return out;
}
function transformQuat(out, a, q) {
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var x = a[0], y = a[1], z2 = a[2];
  var uvx = qy * z2 - qz * y, uvy = qz * x - qx * z2, uvz = qx * y - qy * x;
  var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2;
  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2;
  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z2 + uvz + uuvz;
  return out;
}
function rotateX2(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateY2(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateZ2(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2];
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function angle(a, b) {
  var ax = a[0], ay = a[1], az = a[2], bx = b[0], by = b[1], bz = b[2], mag1 = Math.sqrt(ax * ax + ay * ay + az * az), mag2 = Math.sqrt(bx * bx + by * by + bz * bz), mag = mag1 * mag2, cosine = mag && dot(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}
function str2(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
function exactEquals2(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
function equals2(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2];
  var b0 = b[0], b1 = b[1], b2 = b[2];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2));
}
var sub2 = subtract2;
var mul2 = multiply2;
var div = divide;
var dist = distance;
var sqrDist = squaredDistance;
var len = length;
var sqrLen = squaredLength;
var forEach = (function() {
  var vec = create3();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }
    return a;
  };
})();

// node_modules/gl-matrix/esm/vec4.js
function create4() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
function normalize2(out, a) {
  var x = a[0];
  var y = a[1];
  var z2 = a[2];
  var w = a[3];
  var len3 = x * x + y * y + z2 * z2 + w * w;
  if (len3 > 0) {
    len3 = 1 / Math.sqrt(len3);
  }
  out[0] = x * len3;
  out[1] = y * len3;
  out[2] = z2 * len3;
  out[3] = w * len3;
  return out;
}
var forEach2 = (function() {
  var vec = create4();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 4;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }
    return a;
  };
})();

// node_modules/gl-matrix/esm/quat.js
function create5() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
function slerp(out, a, b, t) {
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  var omega, cosom, sinom, scale0, scale1;
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  if (cosom < 0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  if (1 - cosom > EPSILON) {
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    scale0 = 1 - t;
    scale1 = t;
  }
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
function fromMat3(out, m) {
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;
  if (fTrace > 0) {
    fRoot = Math.sqrt(fTrace + 1);
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    var i = 0;
    if (m[4] > m[0]) i = 1;
    if (m[8] > m[i * 3 + i]) i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }
  return out;
}
var normalize3 = normalize2;
var rotationTo = (function() {
  var tmpvec3 = create3();
  var xUnitVec3 = fromValues2(1, 0, 0);
  var yUnitVec3 = fromValues2(0, 1, 0);
  return function(out, a, b) {
    var dot5 = dot(a, b);
    if (dot5 < -0.999999) {
      cross(tmpvec3, xUnitVec3, a);
      if (len(tmpvec3) < 1e-6) cross(tmpvec3, yUnitVec3, a);
      normalize(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot5 > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      cross(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot5;
      return normalize3(out, out);
    }
  };
})();
var sqlerp = (function() {
  var temp1 = create5();
  var temp2 = create5();
  return function(out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
})();
var setAxes = (function() {
  var matr = create();
  return function(out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize3(out, fromMat3(out, matr));
  };
})();

// node_modules/gl-matrix/esm/vec2.js
var vec2_exports = {};
__export(vec2_exports, {
  add: () => add4,
  angle: () => angle2,
  ceil: () => ceil2,
  clone: () => clone4,
  copy: () => copy5,
  create: () => create6,
  cross: () => cross2,
  dist: () => dist2,
  distance: () => distance2,
  div: () => div2,
  divide: () => divide2,
  dot: () => dot4,
  equals: () => equals4,
  exactEquals: () => exactEquals4,
  floor: () => floor2,
  forEach: () => forEach3,
  fromValues: () => fromValues4,
  inverse: () => inverse2,
  len: () => len2,
  length: () => length4,
  lerp: () => lerp3,
  max: () => max2,
  min: () => min2,
  mul: () => mul3,
  multiply: () => multiply3,
  negate: () => negate2,
  normalize: () => normalize4,
  random: () => random2,
  rotate: () => rotate2,
  round: () => round2,
  scale: () => scale4,
  scaleAndAdd: () => scaleAndAdd2,
  set: () => set4,
  sqrDist: () => sqrDist2,
  sqrLen: () => sqrLen2,
  squaredDistance: () => squaredDistance2,
  squaredLength: () => squaredLength4,
  str: () => str3,
  sub: () => sub3,
  subtract: () => subtract3,
  transformMat2: () => transformMat2,
  transformMat2d: () => transformMat2d,
  transformMat3: () => transformMat32,
  transformMat4: () => transformMat42,
  zero: () => zero2
});
function create6() {
  var out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
function clone4(a) {
  var out = new ARRAY_TYPE(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
function fromValues4(x, y) {
  var out = new ARRAY_TYPE(2);
  out[0] = x;
  out[1] = y;
  return out;
}
function copy5(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
function set4(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
function add4(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
function subtract3(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
function multiply3(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}
function divide2(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}
function ceil2(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}
function floor2(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}
function min2(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}
function max2(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}
function round2(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}
function scale4(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
function scaleAndAdd2(out, a, b, scale5) {
  out[0] = a[0] + b[0] * scale5;
  out[1] = a[1] + b[1] * scale5;
  return out;
}
function distance2(a, b) {
  var x = b[0] - a[0], y = b[1] - a[1];
  return Math.hypot(x, y);
}
function squaredDistance2(a, b) {
  var x = b[0] - a[0], y = b[1] - a[1];
  return x * x + y * y;
}
function length4(a) {
  var x = a[0], y = a[1];
  return Math.hypot(x, y);
}
function squaredLength4(a) {
  var x = a[0], y = a[1];
  return x * x + y * y;
}
function negate2(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
function inverse2(out, a) {
  out[0] = 1 / a[0];
  out[1] = 1 / a[1];
  return out;
}
function normalize4(out, a) {
  var x = a[0], y = a[1];
  var len3 = x * x + y * y;
  if (len3 > 0) {
    len3 = 1 / Math.sqrt(len3);
  }
  out[0] = a[0] * len3;
  out[1] = a[1] * len3;
  return out;
}
function dot4(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
function cross2(out, a, b) {
  var z2 = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z2;
  return out;
}
function lerp3(out, a, b, t) {
  var ax = a[0], ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
function random2(out, scale5) {
  scale5 = scale5 || 1;
  var r = RANDOM() * 2 * Math.PI;
  out[0] = Math.cos(r) * scale5;
  out[1] = Math.sin(r) * scale5;
  return out;
}
function transformMat2(out, a, m) {
  var x = a[0], y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
function transformMat2d(out, a, m) {
  var x = a[0], y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
function transformMat32(out, a, m) {
  var x = a[0], y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
function transformMat42(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
function rotate2(out, a, b, rad) {
  var p0 = a[0] - b[0], p1 = a[1] - b[1], sinC = Math.sin(rad), cosC = Math.cos(rad);
  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
function angle2(a, b) {
  var x1 = a[0], y1 = a[1], x2 = b[0], y2 = b[1], mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2), cosine = mag && (x1 * x2 + y1 * y2) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero2(out) {
  out[0] = 0;
  out[1] = 0;
  return out;
}
function str3(a) {
  return "vec2(" + a[0] + ", " + a[1] + ")";
}
function exactEquals4(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
function equals4(a, b) {
  var a0 = a[0], a1 = a[1];
  var b0 = b[0], b1 = b[1];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1));
}
var len2 = length4;
var sub3 = subtract3;
var mul3 = multiply3;
var div2 = divide2;
var dist2 = distance2;
var sqrDist2 = squaredDistance2;
var sqrLen2 = squaredLength4;
var forEach3 = (function() {
  var vec = create6();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 2;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }
    return a;
  };
})();

// node_modules/@zappar/zappar-cv/lib/profile.js
var UAParser = __toESM(require_ua_parser());
var EmbeddedVideoImplementation;
(function(EmbeddedVideoImplementation2) {
  EmbeddedVideoImplementation2[EmbeddedVideoImplementation2["OBJECT_URL"] = 0] = "OBJECT_URL";
  EmbeddedVideoImplementation2[EmbeddedVideoImplementation2["SRC_OBJECT"] = 1] = "SRC_OBJECT";
})(EmbeddedVideoImplementation || (EmbeddedVideoImplementation = {}));
var profile = {
  deviceMotionMutliplier: -1,
  blacklisted: false,
  showGyroPermissionsWarningIfNecessary: false,
  showSafariPermissionsResetIfNecessary: false,
  requestHighFrameRate: false,
  videoWidth: 640,
  videoHeight: 480,
  dataWidth: 320,
  dataHeight: 240,
  videoElementInDOM: false,
  preferMediaStreamTrackProcessorCamera: false,
  preferImageBitmapCamera: false,
  ios164CameraSelection: false,
  relyOnConstraintsForCameraSelection: false,
  forceWindowOrientation: false
};
if (typeof window !== "undefined") {
  window["zeeProfile"] = profile;
  if (window.location.href.indexOf("_mstppipeline") >= 0) {
    console.log("Configuring for MSTP camera pipeline (if supported)");
    profile.preferMediaStreamTrackProcessorCamera = true;
  }
  if (window.location.href.indexOf("_imagebitmappipeline") >= 0) {
    console.log("Configuring for ImageBitmap camera pipeline (if supported)");
    profile.preferImageBitmapCamera = true;
  }
}
var agent = new UAParser.UAParser();
var os = (agent.getOS().name || "unknown").toLowerCase();
var engine = (agent.getEngine().name || "unknown").toLowerCase();
if (engine === "webkit" && os !== "ios") {
  profile.deviceMotionMutliplier = 1;
  if (typeof window !== "undefined" && window.orientation !== void 0) {
    iDevice("15.0");
  }
}
if (engine === "webkit" && os === "ios") {
  profile.deviceMotionMutliplier = 1;
  const version = agent.getOS().version || "15.0";
  iDevice(version);
}
function iDevice(version) {
  profile.forceWindowOrientation = true;
  let versionParts = version.split(".");
  if (versionParts.length >= 2) {
    const majorVersion = parseInt(versionParts[0]);
    const minorVersion = parseInt(versionParts[1]);
    if (majorVersion < 11 || majorVersion === 11 && minorVersion < 3) {
      profile.blacklisted = true;
    }
    if (majorVersion < 12 || majorVersion === 12 && minorVersion < 2) {
      profile.videoElementInDOM = true;
    }
    if (majorVersion === 12 && minorVersion >= 2 || majorVersion >= 13)
      profile.showGyroPermissionsWarningIfNecessary = true;
    if (majorVersion >= 13) {
      profile.showSafariPermissionsResetIfNecessary = true;
    }
    if ((majorVersion >= 12 && minorVersion > 1 || majorVersion >= 13) && navigator.mediaDevices && navigator.mediaDevices.getSupportedConstraints && navigator.mediaDevices.getSupportedConstraints().frameRate) {
      profile.requestHighFrameRate = true;
      if (majorVersion < 14) {
        profile.videoHeight = 360;
        profile.dataHeight = 180;
      }
    }
    if (majorVersion === 16 && minorVersion >= 4) {
      profile.ios164CameraSelection = true;
    }
    if (majorVersion >= 17) {
      profile.relyOnConstraintsForCameraSelection = true;
    }
  }
}

// node_modules/@zappar/zappar-cv/lib/cameramodel.js
function projectionMatrix(params, screenWidth, screenHeight, near = 0.01, far = 100) {
  let cam_x = params[2] * 2;
  let cam_y = params[3] * 2;
  let projection = mat4_exports.create();
  mat4_exports.frustum(projection, near * (-0.5 - params[2]) / params[0], near * (cam_x - 0.5 - params[2]) / params[0], near * (cam_y - 0.5 - params[3]) / params[1], near * (-0.5 - params[3]) / params[1], near, far);
  projection[4] *= -1;
  projection[5] *= -1;
  projection[6] *= -1;
  projection[7] *= -1;
  let mult = mat4_exports.create();
  mat4_exports.fromScaling(mult, [0.5 * cam_x, 0.5 * cam_y, 1]);
  mat4_exports.multiply(projection, mult, projection);
  mat4_exports.fromRotation(mult, cameraRotationForScreenOrientation(false) * Math.PI / 180, [0, 0, 1]);
  mat4_exports.multiply(projection, mult, projection);
  let vec = vec3_exports.create();
  vec[0] = cam_x;
  vec[1] = cam_y;
  vec[2] = 0;
  vec3_exports.transformMat4(vec, vec, mult);
  let absWidth = Math.abs(vec[0]);
  let absHeight = Math.abs(vec[1]);
  let scaleFactor = 1;
  if (absWidth / screenWidth > absHeight / screenHeight) {
    scaleFactor = screenHeight / absHeight;
  } else {
    scaleFactor = screenWidth / absWidth;
  }
  mat4_exports.fromScaling(mult, [scaleFactor, scaleFactor, 1]);
  mat4_exports.multiply(projection, mult, projection);
  mat4_exports.fromScaling(mult, [2 / screenWidth, 2 / screenHeight, 1]);
  mat4_exports.multiply(projection, mult, projection);
  mat4_exports.fromRotation(mult, cameraRotationForScreenOrientation(false) * Math.PI / -180, [0, 0, 1]);
  mat4_exports.multiply(projection, projection, mult);
  return projection;
}
function cameraRotationForScreenOrientation(isUserFacing) {
  if (window.screen.orientation && !profile.forceWindowOrientation) {
    switch (window.screen.orientation.type) {
      case "portrait-primary":
        return isUserFacing ? 90 : 270;
      case "landscape-secondary":
        return 180;
      case "portrait-secondary":
        return isUserFacing ? 270 : 90;
      default:
        return 0;
    }
  } else if (window.orientation !== void 0) {
    switch (window.orientation) {
      case 0:
        return isUserFacing ? 90 : 270;
      case 90:
        return 0;
      case 180:
        return isUserFacing ? 270 : 90;
      case -90:
        return 180;
    }
  }
  return 0;
}

// node_modules/@zappar/zappar-cv/lib/event.js
var Event2 = class {
  constructor() {
    this._funcs = [];
  }
  bind(f) {
    this._funcs.push(f);
  }
  unbind(f) {
    let indx = this._funcs.indexOf(f);
    if (indx > -1) {
      this._funcs.splice(indx, 1);
    }
  }
  emit() {
    for (var i = 0, total = this._funcs.length; i < total; i++) {
      this._funcs[i]();
    }
  }
};
var Event12 = class {
  constructor() {
    this._funcs = [];
  }
  bind(f) {
    this._funcs.push(f);
  }
  unbind(f) {
    let indx = this._funcs.indexOf(f);
    if (indx > -1) {
      this._funcs.splice(indx, 1);
    }
  }
  emit(a) {
    for (var i = 0, total = this._funcs.length; i < total; i++) {
      this._funcs[i](a);
    }
  }
};

// node_modules/@zappar/zappar-cv/lib/messages.js
var MsgManager = class {
  constructor() {
    this.onOutgoingMessage = new Event2();
    this.onIncomingMessage = new Event12();
    this._outgoingMessages = [];
  }
  postIncomingMessage(msg) {
    this.onIncomingMessage.emit(msg);
  }
  postOutgoingMessage(msg, trans) {
    this._outgoingMessages.push({
      msg,
      transferables: trans
    });
    this.onOutgoingMessage.emit();
  }
  getOutgoingMessages() {
    let ret = this._outgoingMessages;
    this._outgoingMessages = [];
    return ret;
  }
};

// node_modules/@zappar/zappar-cv/lib/worker-client.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var messageManager = new MsgManager();
function launchWorker(worker) {
  return __awaiter(this, void 0, void 0, function* () {
    if (!worker)
      worker = new Worker(new URL("./worker", import.meta.url), { type: "module" });
    worker.postMessage({
      t: "wasm",
      url: new URL("./zappar-cv.wasm", import.meta.url).toString()
    });
    yield waitForLoad(worker);
    function sendOutgoing() {
      let msgs = messageManager.getOutgoingMessages();
      for (let msg of msgs) {
        worker.postMessage(msg.msg, msg.transferables);
      }
    }
    messageManager.onOutgoingMessage.bind(sendOutgoing);
    sendOutgoing();
    worker.addEventListener("message", (evt) => {
      messageManager.postIncomingMessage(evt.data);
    });
  });
}
function waitForLoad(w) {
  return new Promise((resolve) => {
    let listener = (msg) => {
      if (msg.data === "loaded") {
        w.removeEventListener("message", listener);
        resolve();
      }
    };
    w.addEventListener("message", listener);
  });
}

// node_modules/@zappar/zappar-cv/lib/permission.js
var import_ua_parser_js = __toESM(require_ua_parser());

// node_modules/@zappar/zappar-cv/lib/tr.js
var STRINGS;
(function(STRINGS2) {
  STRINGS2[STRINGS2["PermissionTitle"] = 0] = "PermissionTitle";
  STRINGS2[STRINGS2["PermissionDescription"] = 1] = "PermissionDescription";
  STRINGS2[STRINGS2["PermissionButton"] = 2] = "PermissionButton";
})(STRINGS || (STRINGS = {}));
function parseLanguage(inp) {
  const [lang2, locale2] = inp.toLowerCase().split("-");
  return [lang2, locale2 || ""];
}
var [lang, locale] = parseLanguage(navigator.language);
function tr(str4) {
  switch (lang) {
    case "es":
      switch (str4) {
        case STRINGS.PermissionTitle:
          return "Ya casi...";
        case STRINGS.PermissionDescription:
          return "Para brindar esta experiencia de realidad aumentada, necesitamos acceso a la cmara y los sensores de movimiento de su dispositivo.";
        case STRINGS.PermissionButton:
          return "Permitir acceso";
      }
      break;
    case "de":
      switch (str4) {
        case STRINGS.PermissionTitle:
          return "Fast am Ziel..";
        case STRINGS.PermissionDescription:
          return "Um dir dieses Augmented Reality Erlebnis zu liefern, brauchen wir Zugriff auf die Kamera und Bewegungssensoren deines Gertes.";
        case STRINGS.PermissionButton:
          return "Gewhre Zugriff";
      }
      break;
    case "pt":
      switch (str4) {
        case STRINGS.PermissionTitle:
          return "Est quase!";
        case STRINGS.PermissionDescription:
          return "Esta experincia de realidade aumentada precisa de acesso  cmera e aos sensores de movimento deste dispositivo.";
        case STRINGS.PermissionButton:
          return "Permitir acesso";
      }
      break;
  }
  switch (str4) {
    case STRINGS.PermissionTitle:
      return "Almost there...";
    case STRINGS.PermissionDescription:
      return "In order to provide this augmented reality experience, we need access to your device's camera and motion sensors.";
    case STRINGS.PermissionButton:
      return "Grant Access";
  }
  return "";
}

// node_modules/@zappar/zappar-cv/lib/permission.js
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var parser = new import_ua_parser_js.UAParser();
var _permissionGrantedCamera = false;
var _permissionGrantedMotion = false;
var _permissionDeniedCamera = false;
var _permissionDeniedMotion = false;
if (!window.DeviceOrientationEvent || !window.DeviceOrientationEvent.requestPermission) {
  _permissionGrantedMotion = true;
}
function checkForCameraPermission() {
  return __awaiter2(this, void 0, void 0, function* () {
    if (navigator.permissions && navigator.permissions.query) {
      try {
        let res = yield navigator.permissions.query({ name: "camera" });
        _permissionDeniedCamera = res.state === "denied";
        _permissionGrantedCamera = res.state === "granted";
      } catch (ex) {
      }
    }
  });
}
checkForCameraPermission();
function permissionGrantedCamera() {
  return _permissionGrantedCamera;
}
function permissionGrantedMotion() {
  return _permissionGrantedMotion;
}
function permissionDeniedCamera() {
  return _permissionDeniedCamera;
}
function permissionDeniedMotion() {
  return _permissionDeniedMotion;
}
function permissionDeniedAny() {
  return _permissionDeniedCamera || _permissionDeniedMotion;
}
function permissionGrantedAll() {
  return _permissionGrantedCamera && _permissionGrantedMotion;
}
function permissionRequestAll() {
  return __awaiter2(this, void 0, void 0, function* () {
    yield permissionRequestMotion();
    yield permissionRequestCamera();
  });
}
function permissionRequestCamera() {
  return __awaiter2(this, void 0, void 0, function* () {
    try {
      let res = yield navigator.mediaDevices.getUserMedia({
        video: true
      });
      let tracks = res.getTracks();
      tracks.forEach((t) => t.stop());
      _permissionGrantedCamera = true;
      _permissionDeniedCamera = false;
    } catch (err) {
      _permissionGrantedCamera = false;
      _permissionDeniedCamera = true;
    }
  });
}
function permissionRequestMotion() {
  return __awaiter2(this, void 0, void 0, function* () {
    if (window.DeviceOrientationEvent && window.DeviceOrientationEvent.requestPermission) {
      let permissionResult = yield window.DeviceOrientationEvent.requestPermission();
      if (permissionResult !== "granted") {
        _permissionGrantedMotion = false;
        _permissionDeniedMotion = true;
        return false;
      }
    }
    _permissionGrantedMotion = true;
    _permissionDeniedMotion = false;
  });
}
function permissionRequestUI() {
  return __awaiter2(this, void 0, void 0, function* () {
    yield checkForCameraPermission();
    if (permissionGrantedAll()) {
      return true;
    }
    let div3 = document.createElement("div");
    div3.classList.add("zappar-permission-request");
    div3.innerHTML = `
    <style>
        .zappar-permission-request {
            position: fixed;
            width: 100%;
            height: 100%;
            top: 0px;
            left: 0px;
            z-index: 1000;
            background-color: rgba(0, 0, 0, 0.9);
            font-family: sans-serif;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .zappar-inner {
            max-width: 400px;
            text-align: center;
        }
        .zappar-title {
            font-size: 20px;
        }
        .zappar-text {
            font-size: 14px;
            padding: 15px;
        }
        .zappar-inner > button {
            background: none;
            outline: none;
            border: 2px solid white;
            border-radius: 10px;
            color: white;
            padding: 10px 40px;
            text-transform: uppercase;
        }
    </style>
    <div class="zappar-inner">
        <div class="zappar-title">${tr(STRINGS.PermissionTitle)}</div>
        <div class="zappar-text">${tr(STRINGS.PermissionDescription)}</div>
        <button id="zappar-permission-request-button">${tr(STRINGS.PermissionButton)}</button>
    </div>
`;
    document.body.append(div3);
    let button = div3.querySelector("#zappar-permission-request-button");
    return yield new Promise((resolve) => {
      button === null || button === void 0 ? void 0 : button.addEventListener("click", () => __awaiter2(this, void 0, void 0, function* () {
        yield permissionRequestAll();
        div3.remove();
        while (true) {
          yield nextFrame();
          if (permissionDeniedAny()) {
            resolve(false);
            return;
          }
          if (permissionGrantedAll()) {
            resolve(true);
            return;
          }
        }
      }));
    });
  });
}
function nextFrame() {
  return new Promise((resolve) => requestAnimationFrame(() => resolve()));
}
function permissionDeniedUI() {
  switch (parser.getBrowser().name) {
    case "Chrome":
      permissionDeniedUIChrome();
      break;
    default:
      permissionDeniedUIIOS();
      break;
  }
}
function permissionDeniedUIIOS() {
  let div3 = document.createElement("div");
  div3.classList.add("zappar-permission-request");
  div3.innerHTML = `
    <style>
        .zappar-permission-request {
            position: fixed;
            width: 100%;
            height: 100%;
            top: 0px;
            left: 0px;
            z-index: 1000;
            background-color: rgba(0, 0, 0, 0.9);
            font-family: sans-serif;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .zappar-inner {
            max-width: 400px;
            text-align: center;
        }
        .zappar-title {
            font-size: 20px;
        }
        .zappar-text {
            font-size: 14px;
            padding: 15px;
        }
        .zappar-inner > button {
            background: none;
            outline: none;
            border: 2px solid white;
            border-radius: 10px;
            color: white;
            padding: 10px 40px;
            text-transform: uppercase;
        }
    </style>
    <div class="zappar-inner">
        <div class="zappar-title">Permission is Needed</div>
        <div class="zappar-text">Permission to access your device's camera and motion sensors is necessary for this experience. Please reload the page to try again.</div>
        <button id="zappar-permission-reload-button">Reload</button>
    </div>
`;
  document.body.append(div3);
  let button = div3.querySelector("#zappar-permission-reload-button");
  button === null || button === void 0 ? void 0 : button.addEventListener("click", () => window.location.reload());
}
function permissionDeniedUIChrome() {
  let div3 = document.createElement("div");
  div3.classList.add("zappar-permission-request");
  div3.innerHTML = `
    <style>
        .zappar-permission-request {
            position: fixed;
            width: 100%;
            height: 100%;
            top: 0px;
            left: 0px;
            z-index: 1000;
            background-color: rgba(0, 0, 0, 0.9);
            font-family: sans-serif;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .zappar-inner {
            width: 400px;
            text-align: center;
        }
        .zappar-title {
            font-size: 20px;
        }
        .zappar-text {
            font-size: 14px;
            padding: 15px;
        }
        .zappar-inner > button {
            background: none;
            outline: none;
            border: 2px solid white;
            border-radius: 10px;
            color: white;
            padding: 10px 40px;
            text-transform: uppercase;
        }
    </style>
    <div class="zappar-inner">
        <div class="zappar-title">Permission is Needed</div>
        <div class="zappar-text">Permission to access your device's camera and motion sensors is necessary for this experience.<br/><br/>To grant access, please tap the ! button in the address bar of your browser, then "Site settings", and finally "Clear and reset". You can then reload the page to try again.</div>
        <button id="zappar-permission-reload-button">Reload</button>
    </div>
`;
  document.body.append(div3);
  let button = div3.querySelector("#zappar-permission-reload-button");
  button === null || button === void 0 ? void 0 : button.addEventListener("click", () => window.location.reload());
}

// node_modules/@zappar/zappar-cv/lib/loglevel.js
var logLevel = log_level_t.LOG_LEVEL_ERROR;
function setLogLevel(l) {
  logLevel = l;
}
function zcout(...args) {
  if (logLevel >= log_level_t.LOG_LEVEL_VERBOSE)
    console.log("[Zappar] INFO", ...args);
}
function zcerr(...args) {
  if (logLevel >= log_level_t.LOG_LEVEL_ERROR)
    console.error("[Zappar] ERROR", ...args);
}
function zcwarn(...args) {
  if (logLevel >= log_level_t.LOG_LEVEL_VERBOSE)
    console.log("[Zappar] WARN", ...args);
}

// node_modules/@zappar/zappar-cv/lib/facemesh.js
var latestFaceMesh = 1;
var faceMeshById = /* @__PURE__ */ new Map();
function createFaceMesh() {
  let ret = latestFaceMesh++;
  faceMeshById.set(ret, new FaceMesh());
  zcout("face_mesh_t initialized");
  return ret;
}
function destroyFaceMesh(m) {
  faceMeshById.delete(m);
}
function getFaceMesh(m) {
  return faceMeshById.get(m);
}
var FaceMesh = class {
  constructor() {
    this.render_mean_ = new Float32Array();
    this.render_identity_ = new Float32Array(50);
    this.render_expression_ = new Float32Array(29);
    this.render_uvs_ = new Float32Array();
    this.render_indices_ = new Uint16Array();
    this.vertices_ = new Float32Array();
    this.normals_ = new Float32Array();
    this.normalsCalculated_ = false;
    this.modelVersion_ = -1;
    this.mirrored_ = false;
  }
  loadFromMemory(ab, fillMouth, fillEyeL, fillEyeR, fillNeck) {
    let offset = 0;
    let uint16View = new Uint16Array(ab);
    let intView = new Int32Array(ab);
    let floatView = new Float32Array(ab);
    let readMatrix = () => {
      let nr = intView[offset++];
      let nc = intView[offset++];
      let size = nr * nc;
      let ret = floatView.subarray(offset, offset + size);
      offset += size;
      return ret;
    };
    let readShortVector = () => {
      let size = intView[offset++];
      let ret = uint16View.subarray(offset * 2, offset * 2 + size);
      offset += size / 2;
      return ret;
    };
    this.render_mean_ = readMatrix();
    this.render_identity_ = readMatrix();
    this.render_expression_ = readMatrix();
    this.render_uvs_ = readMatrix();
    let baseIndices = readShortVector();
    let mouthIndices = offset < intView.length ? readShortVector() : new Uint16Array();
    let leftEyeIndices = offset < intView.length ? readShortVector() : new Uint16Array();
    let rightEyeIndices = offset < intView.length ? readShortVector() : new Uint16Array();
    let neckIndices = offset < intView.length ? readShortVector() : new Uint16Array();
    if (!fillMouth && !fillEyeL && !fillEyeR && !fillNeck) {
      this.render_indices_ = baseIndices;
    } else {
      let sizeRequired = baseIndices.length;
      if (fillMouth)
        sizeRequired += mouthIndices.length;
      if (fillEyeL)
        sizeRequired += leftEyeIndices.length;
      if (fillEyeR)
        sizeRequired += rightEyeIndices.length;
      if (fillNeck)
        sizeRequired += neckIndices.length;
      this.render_indices_ = new Uint16Array(sizeRequired);
      this.render_indices_.set(baseIndices, 0);
      let indx = baseIndices.length;
      if (fillMouth) {
        this.render_indices_.set(mouthIndices, indx);
        indx += mouthIndices.length;
      }
      if (fillEyeL) {
        this.render_indices_.set(leftEyeIndices, indx);
        indx += leftEyeIndices.length;
      }
      if (fillEyeR) {
        this.render_indices_.set(rightEyeIndices, indx);
        indx += rightEyeIndices.length;
      }
      if (fillNeck) {
        this.render_indices_.set(neckIndices, indx);
        indx += neckIndices.length;
      }
    }
    this.vertices_ = new Float32Array(this.render_mean_);
    this.normals_ = new Float32Array(this.vertices_.length);
    this.modelVersion_++;
  }
  getVertices() {
    return this.vertices_;
  }
  getUVs() {
    return this.render_uvs_;
  }
  getIndices() {
    if (this.mirrored_) {
      if (!this.render_indices_reversed) {
        this.render_indices_reversed = new Uint16Array(this.render_indices_.length);
        for (let i = 0; i < this.render_indices_.length; i += 3) {
          this.render_indices_reversed[i] = this.render_indices_[i + 2];
          this.render_indices_reversed[i + 1] = this.render_indices_[i + 1];
          this.render_indices_reversed[i + 2] = this.render_indices_[i];
        }
      }
      return this.render_indices_reversed;
    }
    return this.render_indices_;
  }
  getNormals() {
    if (!this.normalsCalculated_)
      this.calculateNormals();
    return this.normals_;
  }
  getModelVersion() {
    return this.modelVersion_;
  }
  getLandmarkDataForVertex(v) {
    let mean = [
      this.render_mean_[v * 3],
      this.render_mean_[v * 3 + 1],
      this.render_mean_[v * 3 + 2]
    ];
    let identity4 = [];
    for (let i = 0; i < 50; i++) {
      identity4.push(this.render_identity_[v * 3 * 50 + i]), identity4.push(this.render_identity_[(v * 3 + 1) * 50 + i]), identity4.push(this.render_identity_[(v * 3 + 2) * 50 + i]);
    }
    let expression = [];
    for (let i = 0; i < 29; i++) {
      expression.push(this.render_expression_[v * 3 * 29 + i]), expression.push(this.render_expression_[(v * 3 + 1) * 29 + i]), expression.push(this.render_expression_[(v * 3 + 2) * 29 + i]);
    }
    return { mean, identity: identity4, expression };
  }
  update(identity4, expression, mirrored) {
    if (this.render_mean_.length === 0)
      return;
    if (this.render_identity_.length === 0)
      return;
    if (this.render_expression_.length === 0)
      return;
    this.mirrored_ = mirrored;
    this.vertices_.set(this.render_mean_);
    for (let i = 0; i < identity4.length; i++) {
      for (let j = 0; j < this.vertices_.length; j++) {
        this.vertices_[j] += identity4[i] * this.render_identity_[j * identity4.length + i];
      }
    }
    for (let i = 0; i < expression.length; i++) {
      for (let j = 0; j < this.vertices_.length; j++) {
        this.vertices_[j] += expression[i] * this.render_expression_[j * expression.length + i];
      }
    }
    if (mirrored) {
      for (let j = 0; j < this.vertices_.length; j += 3) {
        this.vertices_[j] *= -1;
      }
    }
    this.normalsCalculated_ = false;
  }
  calculateNormals() {
    let indices = this.getIndices();
    let vertices = this.vertices_;
    let faceNormals = new Float32Array(indices.length);
    if (!vertices)
      return;
    let size = indices.length;
    let normals = this.normals_;
    let v = new Float32Array([0, 0, 0]);
    let w = new Float32Array([0, 0, 0]);
    let out = new Float32Array([0, 0, 0]);
    for (let i = 0; i < size; i += 3) {
      let vertexStart0 = indices[i] * 3;
      let vertexStart1 = indices[i + 1] * 3;
      let vertexStart2 = indices[i + 2] * 3;
      v[0] = vertices[vertexStart1] - vertices[vertexStart0];
      v[1] = vertices[vertexStart1 + 1] - vertices[vertexStart0 + 1];
      v[2] = vertices[vertexStart1 + 2] - vertices[vertexStart0 + 2];
      w[0] = vertices[vertexStart2] - vertices[vertexStart0];
      w[1] = vertices[vertexStart2 + 1] - vertices[vertexStart0 + 1];
      w[2] = vertices[vertexStart2 + 2] - vertices[vertexStart0 + 2];
      vec3_exports.cross(out, v, w);
      let length5 = vec3_exports.length(out);
      faceNormals[i] = out[0] / length5;
      faceNormals[i + 1] = out[1] / length5;
      faceNormals[i + 2] = out[2] / length5;
    }
    normals.fill(0);
    for (let i = 0; i < size; i += 3) {
      let vertexStart0 = indices[i] * 3;
      let vertexStart1 = indices[i + 1] * 3;
      let vertexStart2 = indices[i + 2] * 3;
      normals[vertexStart0] += faceNormals[i];
      normals[vertexStart0 + 1] += faceNormals[i + 1];
      normals[vertexStart0 + 2] += faceNormals[i + 2];
      normals[vertexStart1] += faceNormals[i];
      normals[vertexStart1 + 1] += faceNormals[i + 1];
      normals[vertexStart1 + 2] += faceNormals[i + 2];
      normals[vertexStart2] += faceNormals[i];
      normals[vertexStart2 + 1] += faceNormals[i + 1];
      normals[vertexStart2 + 2] += faceNormals[i + 2];
    }
    let numberNormals = normals.length / 3;
    for (let i = 0; i < numberNormals; i++) {
      let indx = i * 3;
      v[0] = normals[indx];
      v[1] = normals[indx + 1];
      v[2] = normals[indx + 2];
      vec3_exports.normalize(w, v);
      normals[indx] = w[0];
      normals[indx + 1] = w[1];
      normals[indx + 2] = w[2];
    }
    this.normalsCalculated_ = true;
  }
};

// node_modules/@zappar/zappar-cv/lib/drawcamera.js
var identity2 = mat4_exports.create();
var CameraDraw = class {
  constructor(_gl) {
    this._gl = _gl;
  }
  dispose() {
    if (this._vbo)
      this._gl.deleteBuffer(this._vbo);
    this._vbo = void 0;
    if (this._shader)
      this._gl.deleteProgram(this._shader.prog);
    this._shader = void 0;
  }
  _generate(gl, i) {
    if (this._vbo)
      return this._vbo;
    if (!this._vbo)
      this._vbo = gl.createBuffer();
    if (!this._vbo)
      throw new Error("Unable to create buffer object");
    let vboData = new Float32Array([
      -1,
      -1,
      0,
      0,
      0,
      -1,
      1,
      0,
      0,
      1,
      1,
      -1,
      0,
      1,
      0,
      1,
      -1,
      0,
      1,
      0,
      -1,
      1,
      0,
      0,
      1,
      1,
      1,
      0,
      1,
      1
    ]);
    gl.bindBuffer(gl.ARRAY_BUFFER, this._vbo);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vboData), gl.STATIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    return this._vbo;
  }
  drawCameraFrame(screenWidth, screenHeight, i, mirror) {
    if (!i.texture)
      return;
    let gl = this._gl;
    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.SCISSOR_TEST);
    gl.disable(gl.CULL_FACE);
    gl.disable(gl.BLEND);
    let shader2 = this._getCameraShader(gl);
    let vbo2 = this._generate(gl, i);
    gl.activeTexture(gl.TEXTURE0);
    gl.useProgram(shader2.prog);
    gl.uniformMatrix4fv(shader2.unif_skinTexTransform, false, cameraFrameTextureMatrix(i.dataWidth, i.dataHeight, screenWidth, screenHeight, i.uvTransform || identity2, mirror));
    gl.uniform1i(shader2.unif_skinSampler, 0);
    gl.bindTexture(gl.TEXTURE_2D, i.texture);
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo2);
    gl.vertexAttribPointer(shader2.attr_position, 3, gl.FLOAT, false, 5 * 4, 0);
    gl.enableVertexAttribArray(shader2.attr_position);
    gl.vertexAttribPointer(shader2.attr_texCoord, 2, gl.FLOAT, false, 5 * 4, 3 * 4);
    gl.enableVertexAttribArray(shader2.attr_texCoord);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    gl.disableVertexAttribArray(shader2.attr_position);
    gl.disableVertexAttribArray(shader2.attr_texCoord);
    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    gl.useProgram(null);
  }
  _getCameraShader(gl) {
    if (this._shader)
      return this._shader;
    let prog = gl.createProgram();
    if (!prog)
      throw new Error("Unable to create program");
    let vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexShaderSrc2);
    let fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSrc2);
    gl.attachShader(prog, vertexShader);
    gl.attachShader(prog, fragmentShader);
    linkProgram(gl, prog);
    let unif_skinTexTransform = gl.getUniformLocation(prog, "skinTexTransform");
    if (!unif_skinTexTransform)
      throw new Error("Unable to get uniform location skinTexTransform");
    let unif_skinSampler = gl.getUniformLocation(prog, "skinSampler");
    if (!unif_skinSampler)
      throw new Error("Unable to get uniform location skinSampler");
    this._shader = {
      prog,
      unif_skinTexTransform,
      unif_skinSampler,
      attr_position: gl.getAttribLocation(prog, "position"),
      attr_texCoord: gl.getAttribLocation(prog, "texCoord")
    };
    return this._shader;
  }
};
var vertexShaderSrc2 = `
#ifndef GL_ES
#define highp
#define mediump
#define lowp
#endif

attribute vec4 position;
attribute vec4 texCoord;
varying vec4 skinTexVarying;
uniform mat4 skinTexTransform;

void main()
{
    gl_Position = position;
    skinTexVarying = skinTexTransform * texCoord;
}`;
var fragmentShaderSrc2 = `
#define highp mediump
#ifdef GL_ES
    // define default precision for float, vec, mat.
    precision highp float;
#else
#define highp
#define mediump
#define lowp
#endif

varying vec4 skinTexVarying;
uniform lowp sampler2D skinSampler;

void main()
{
    gl_FragColor = texture2DProj(skinSampler, skinTexVarying);
}`;
function cameraRotationForScreenOrientation2() {
  if (window.screen.orientation && !profile.forceWindowOrientation) {
    switch (window.screen.orientation.type) {
      case "portrait-primary":
        return 270;
      case "landscape-secondary":
        return 180;
      case "portrait-secondary":
        return 90;
      default:
        return 0;
    }
  } else if (window.orientation !== void 0) {
    switch (window.orientation) {
      case 0:
        return 270;
      case 90:
        return 0;
      case 180:
        return 90;
      case -90:
        return 180;
    }
  }
  return 0;
}
function cameraFrameTextureMatrix(frameWidth, frameHeight, screenWidth, screenHeight, uvMatrix, mirror) {
  let ret = mat4_exports.create();
  let trans = mat4_exports.create();
  mat4_exports.fromTranslation(trans, [-0.5, -0.5, 0]);
  mat4_exports.multiply(ret, trans, ret);
  if (mirror) {
    mat4_exports.fromScaling(trans, [-1, 1, 1]);
    mat4_exports.multiply(ret, trans, ret);
  }
  mat4_exports.fromRotation(trans, -1 * cameraRotationForScreenOrientation2() * Math.PI / 180, [0, 0, 1]);
  mat4_exports.multiply(ret, trans, ret);
  let vec = vec3_exports.create();
  vec[0] = screenWidth;
  vec[1] = screenHeight;
  vec[2] = 0;
  vec3_exports.transformMat4(vec, vec, trans);
  let absScreenX = Math.abs(vec[0]);
  let absScreenY = Math.abs(vec[1]);
  mat4_exports.fromScaling(trans, [1, -1, 1]);
  mat4_exports.multiply(ret, trans, ret);
  let screenAspect = absScreenX / absScreenY;
  let frameAspect = frameWidth / frameHeight;
  if (screenAspect > frameAspect) {
    mat4_exports.fromScaling(trans, [1, frameAspect / screenAspect, 1]);
  } else {
    mat4_exports.fromScaling(trans, [screenAspect / frameAspect, 1, 1]);
  }
  mat4_exports.multiply(ret, trans, ret);
  mat4_exports.fromTranslation(trans, [0.5, 0.5, 0]);
  mat4_exports.multiply(ret, trans, ret);
  mat4_exports.multiply(ret, uvMatrix, ret);
  return ret;
}

// node_modules/@zappar/zappar-cv/lib/drawface.js
var FaceDraw = class {
  constructor(_gl) {
    this._gl = _gl;
  }
  dispose() {
    if (this._vbo)
      this._gl.deleteBuffer(this._vbo);
    if (this._normalbo)
      this._gl.deleteBuffer(this._normalbo);
    if (this._ibo)
      this._gl.deleteBuffer(this._ibo);
    if (this._shader)
      this._gl.deleteProgram(this._shader.prog);
    this._vbo = void 0;
    this._normalbo = void 0;
    this._ibo = void 0;
    this._shader = void 0;
  }
  _generateIBO(indices, gl) {
    if (this._ibo && this._lastIndices === indices)
      return this._ibo;
    this._lastIndices = indices;
    if (!this._ibo)
      this._ibo = gl.createBuffer();
    if (!this._ibo)
      throw new Error("Unable to create buffer object");
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._ibo);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    return this._ibo;
  }
  _generateVBO(face, gl) {
    if (!this._vbo)
      this._vbo = gl.createBuffer();
    if (!this._vbo)
      throw new Error("Unable to create buffer object");
    gl.bindBuffer(gl.ARRAY_BUFFER, this._vbo);
    gl.bufferData(gl.ARRAY_BUFFER, face, gl.STREAM_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    return this._vbo;
  }
  _generateNormalBO(face, gl) {
    if (!this._normalbo)
      this._normalbo = gl.createBuffer();
    if (!this._normalbo)
      throw new Error("Unable to create buffer object");
    gl.bindBuffer(gl.ARRAY_BUFFER, this._normalbo);
    gl.bufferData(gl.ARRAY_BUFFER, face, gl.STREAM_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    return this._normalbo;
  }
  drawFace(matrix, o) {
    let gl = this._gl;
    let shader2 = this._getShader(gl);
    let v = this._generateVBO(o.getVertices(), gl);
    let n = this._generateNormalBO(o.getNormals(), gl);
    let i = this._generateIBO(o.getIndices(), gl);
    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.CULL_FACE);
    gl.useProgram(shader2.prog);
    gl.uniformMatrix4fv(shader2.unif_matrix, false, matrix);
    gl.bindBuffer(gl.ARRAY_BUFFER, v);
    gl.vertexAttribPointer(shader2.attr_position, 3, gl.FLOAT, false, 3 * 4, 0);
    gl.enableVertexAttribArray(shader2.attr_position);
    gl.bindBuffer(gl.ARRAY_BUFFER, n);
    gl.vertexAttribPointer(shader2.attr_normal, 3, gl.FLOAT, false, 3 * 4, 0);
    gl.enableVertexAttribArray(shader2.attr_normal);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, i);
    gl.drawElements(gl.TRIANGLES, o.getIndices().length, gl.UNSIGNED_SHORT, 0);
    gl.disableVertexAttribArray(shader2.attr_position);
    gl.disableVertexAttribArray(shader2.attr_normal);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
  }
  _getShader(gl) {
    if (this._shader)
      return this._shader;
    let prog = gl.createProgram();
    if (!prog)
      throw new Error("Unable to create program");
    let vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexShaderSrc3);
    let fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSrc3);
    gl.attachShader(prog, vertexShader);
    gl.attachShader(prog, fragmentShader);
    linkProgram(gl, prog);
    let unif_matrix = gl.getUniformLocation(prog, "matrix");
    if (!unif_matrix)
      throw new Error("Unable to get uniform location mattrix");
    this._shader = {
      prog,
      unif_matrix,
      attr_position: gl.getAttribLocation(prog, "position"),
      attr_normal: gl.getAttribLocation(prog, "normal")
    };
    return this._shader;
  }
};
var vertexShaderSrc3 = `
#ifndef GL_ES
#define highp
#define mediump
#define lowp
#endif

uniform mat4 matrix;
attribute vec4 position;
attribute vec3 normal;
varying highp vec3 vnormal;

void main()
{
    gl_Position = matrix * position;
    vnormal = normal;
}`;
var fragmentShaderSrc3 = `
#define highp mediump
#ifdef GL_ES
    // define default precision for float, vec, mat.
    precision highp float;
#else
#define highp
#define mediump
#define lowp
#endif

varying vec4 skinTexVarying;
varying highp vec3 vnormal;
uniform lowp sampler2D skinSampler;

void main()
{
    vec3 normal2 = 0.5 * vnormal + 0.5;
    gl_FragColor = vec4(normal2.x , normal2.y, normal2.z, 1.0);
}`;

// node_modules/@zappar/zappar-cv/lib/drawfaceproject.js
var FaceDrawProject = class {
  constructor(_gl) {
    this._gl = _gl;
  }
  dispose() {
    if (this._vbo)
      this._gl.deleteBuffer(this._vbo);
    if (this._uvbo)
      this._gl.deleteBuffer(this._uvbo);
    if (this._ibo)
      this._gl.deleteBuffer(this._ibo);
    if (this._shader)
      this._gl.deleteProgram(this._shader.prog);
    this._vbo = void 0;
    this._uvbo = void 0;
    this._ibo = void 0;
    this._shader = void 0;
  }
  _generateIBO(indices, gl) {
    if (this._ibo && this._lastIndices === indices)
      return this._ibo;
    this._lastIndices = indices;
    if (!this._ibo)
      this._ibo = gl.createBuffer();
    if (!this._ibo)
      throw new Error("Unable to create buffer object");
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._ibo);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    return this._ibo;
  }
  _generateVBO(face, gl) {
    if (!this._vbo)
      this._vbo = gl.createBuffer();
    if (!this._vbo)
      throw new Error("Unable to create buffer object");
    gl.bindBuffer(gl.ARRAY_BUFFER, this._vbo);
    gl.bufferData(gl.ARRAY_BUFFER, face, gl.STREAM_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    return this._vbo;
  }
  _generateUVBO(face, gl) {
    if (!this._uvbo)
      this._uvbo = gl.createBuffer();
    if (!this._uvbo)
      throw new Error("Unable to create buffer object");
    gl.bindBuffer(gl.ARRAY_BUFFER, this._uvbo);
    gl.bufferData(gl.ARRAY_BUFFER, face, gl.STREAM_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    return this._uvbo;
  }
  drawFace(matrix, vertices, uvMatrix, uvs, indices, texture) {
    let gl = this._gl;
    let shader2 = this._getShader(gl);
    let v = this._generateVBO(vertices, gl);
    let u = this._generateUVBO(uvs, gl);
    let i = this._generateIBO(indices, gl);
    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.CULL_FACE);
    gl.useProgram(shader2.prog);
    gl.uniformMatrix4fv(shader2.unif_matrix, false, matrix);
    gl.uniformMatrix4fv(shader2.unif_uvmatrix, false, uvMatrix);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.uniform1i(shader2.unif_sampler, 0);
    gl.bindBuffer(gl.ARRAY_BUFFER, v);
    gl.vertexAttribPointer(shader2.attr_position, 3, gl.FLOAT, false, 3 * 4, 0);
    gl.enableVertexAttribArray(shader2.attr_position);
    gl.bindBuffer(gl.ARRAY_BUFFER, u);
    gl.vertexAttribPointer(shader2.attr_uv, 3, gl.FLOAT, false, 3 * 4, 0);
    gl.enableVertexAttribArray(shader2.attr_uv);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, i);
    gl.drawElements(gl.TRIANGLES, 2304 * 3, gl.UNSIGNED_SHORT, 0);
    gl.disableVertexAttribArray(shader2.attr_position);
    gl.disableVertexAttribArray(shader2.attr_uv);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
  }
  _getShader(gl) {
    if (this._shader)
      return this._shader;
    let prog = gl.createProgram();
    if (!prog)
      throw new Error("Unable to create program");
    let vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexShaderSrc4);
    let fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSrc4);
    gl.attachShader(prog, vertexShader);
    gl.attachShader(prog, fragmentShader);
    linkProgram(gl, prog);
    let unif_matrix = gl.getUniformLocation(prog, "matrix");
    if (!unif_matrix)
      throw new Error("Unable to get uniform location matrix");
    let unif_uvmatrix = gl.getUniformLocation(prog, "uvmatrix");
    if (!unif_uvmatrix)
      throw new Error("Unable to get uniform location matrix");
    let unif_sampler = gl.getUniformLocation(prog, "uSampler");
    if (!unif_sampler)
      throw new Error("Unable to get uniform location sampler");
    this._shader = {
      prog,
      unif_matrix,
      unif_sampler,
      unif_uvmatrix,
      attr_position: gl.getAttribLocation(prog, "position"),
      attr_uv: gl.getAttribLocation(prog, "uv"),
      attr_texturecoord: gl.getAttribLocation(prog, "aTextureCoord")
    };
    return this._shader;
  }
};
var vertexShaderSrc4 = `
#ifndef GL_ES
#define highp
#define mediump
#define lowp
#endif

uniform mat4 matrix;
uniform mat4 uvmatrix;
attribute vec4 position;
attribute vec3 normal;
attribute vec3 uv;

// varying highp vec3 vnormal;

varying highp vec2 vTextureCoord;
varying highp float vAlpha;

void main()
{
    gl_Position = matrix * position;
    vec4 ret = uvmatrix * vec4(uv.x, uv.y, uv.z, 1.0);
    ret.x /= ret.w * 2.0;
    ret.y /= ret.w * 2.0;
    ret.x += 0.5;
    ret.y += 0.0;
    vAlpha = 1.0;
    vTextureCoord = ret.xy;
}`;
var fragmentShaderSrc4 = `
#define highp mediump
#ifdef GL_ES
    // define default precision for float, vec, mat.
    precision highp float;
#else
#define highp
#define mediump
#define lowp
#endif

varying highp vec2 vTextureCoord;
varying highp vec3 vnormal;
varying highp float vAlpha;
uniform lowp sampler2D uSampler;

void main()
{
    // vec3 normal2 = 0.5 * vnormal + 0.5;
    vec4 p = texture2D(uSampler, vTextureCoord);
    p.a = vAlpha;
    gl_FragColor = p; // vec4(normal2.x , normal2.y, normal2.z, 1.0);
}`;

// node_modules/@zappar/zappar-cv/lib/sequencerecorder.js
var SequenceRecorderPacketType;
(function(SequenceRecorderPacketType2) {
  SequenceRecorderPacketType2[SequenceRecorderPacketType2["CAMERA_FRAME"] = 0] = "CAMERA_FRAME";
  SequenceRecorderPacketType2[SequenceRecorderPacketType2["ACCELEROMETER"] = 1] = "ACCELEROMETER";
  SequenceRecorderPacketType2[SequenceRecorderPacketType2["ROTATION_RATE"] = 2] = "ROTATION_RATE";
  SequenceRecorderPacketType2[SequenceRecorderPacketType2["ATTITUDE"] = 3] = "ATTITUDE";
  SequenceRecorderPacketType2[SequenceRecorderPacketType2["ATTITUDE_MATRIX"] = 4] = "ATTITUDE_MATRIX";
})(SequenceRecorderPacketType || (SequenceRecorderPacketType = {}));
var SequenceRecorder = class _SequenceRecorder {
  constructor(estimatedFrames) {
    this._insertionByte = 0;
    this._numberPackets = 0;
    this._started = false;
    this._hasLoggedUnsuppored = false;
    this._data = new ArrayBuffer(this._estimatedSize(estimatedFrames, 320, 240));
    this._dataView = new DataView(this._data);
    this._dataUint8 = new Uint8Array(this._data);
    this._dataFloat32 = new Float32Array(this._data);
  }
  _estimatedSize(frames, cameraFrameWidth, cameraFrameHeight) {
    return _SequenceRecorder.headerSizeBytes + (_SequenceRecorder.psbPacketType + _SequenceRecorder.cameraPacketSizeBytes + cameraFrameWidth * cameraFrameHeight) * frames;
  }
  start() {
    this._started = true;
    this._insertionByte = 0;
    this._numberPackets = 0;
    this._growArrayBuffer(_SequenceRecorder.headerSizeBytes);
    let enc = new TextEncoder();
    let headerData = enc.encode("UAR1");
    this._dataUint8.set(headerData);
    this._dataView.setUint32(4, 0, true);
    this._insertionByte += 8;
  }
  stop() {
    this._started = false;
    let trimmed = this._data.slice(0, this._insertionByte);
    this._data = trimmed;
    this._dataUint8 = new Uint8Array(this._data);
    this._dataFloat32 = new Float32Array(this._data);
    this._dataView = new DataView(this._data);
  }
  data() {
    return this._dataUint8;
  }
  appendCameraFrame(c) {
    if (!this._started)
      return;
    if (!c.data) {
      if (this._hasLoggedUnsuppored)
        return;
      this._hasLoggedUnsuppored = true;
      zcerr("Unable to record frames from this camera source");
      return;
    }
    if (c.data.byteLength !== c.dataWidth * c.dataHeight) {
      zcerr("Unable to record frame to sequence: greyscale array doesn't match dimensions");
      return;
    }
    let increment = _SequenceRecorder.psbPacketType + _SequenceRecorder.cameraPacketSizeBytes + c.dataWidth * c.dataHeight;
    this._growArrayBuffer(increment);
    this._dataView.setUint32(this._insertionByte, SequenceRecorderPacketType.CAMERA_FRAME, true);
    this._insertionByte += _SequenceRecorder.psbPacketType;
    this._dataView.setUint32(this._insertionByte, c.dataWidth, true);
    this._insertionByte += _SequenceRecorder.psbCameraFrameWidth;
    this._dataView.setUint32(this._insertionByte, c.dataHeight, true);
    this._insertionByte += _SequenceRecorder.psbCameraFrameHeight;
    this._dataFloat32.set(c.cameraToDevice, this._insertionByte / 4);
    this._insertionByte += _SequenceRecorder.psbCameraToDeviceTransform;
    this._dataFloat32.set(c.cameraModel, this._insertionByte / 4);
    this._insertionByte += _SequenceRecorder.psbCameraModel;
    this._dataView.setUint32(this._insertionByte, c.userFacing ? 1 : 0, true);
    this._insertionByte += _SequenceRecorder.psbFlags;
    this._dataUint8.set(new Uint8Array(c.data), this._insertionByte);
    this._insertionByte += c.data.byteLength;
    this._numberPackets++;
    this._dataView.setUint32(4, this._numberPackets, true);
  }
  appendAccelerometer(t, x, y, z2) {
    this._appendTimestampedVec3(SequenceRecorderPacketType.ACCELEROMETER, t, x, y, z2);
  }
  appendRotationRate(t, x, y, z2) {
    this._appendTimestampedVec3(SequenceRecorderPacketType.ROTATION_RATE, t, x, y, z2);
  }
  appendAttitude(t, x, y, z2) {
    this._appendTimestampedVec3(SequenceRecorderPacketType.ATTITUDE, t, x, y, z2);
  }
  _appendTimestampedVec3(type, t, x, y, z2) {
    if (!this._started)
      return;
    let increment = _SequenceRecorder.psbPacketType + _SequenceRecorder.accelerometerPacketSizeBytes;
    this._growArrayBuffer(increment);
    this._dataView.setUint32(this._insertionByte, type, true);
    this._insertionByte += _SequenceRecorder.psbPacketType;
    this._dataView.setUint32(this._insertionByte, t, true);
    this._insertionByte += 4;
    this._dataView.setFloat32(this._insertionByte, x, true);
    this._insertionByte += 4;
    this._dataView.setFloat32(this._insertionByte, y, true);
    this._insertionByte += 4;
    this._dataView.setFloat32(this._insertionByte, z2, true);
    this._insertionByte += 4;
    this._numberPackets++;
    this._dataView.setUint32(4, this._numberPackets, true);
  }
  appendAttitudeMatrix(m) {
    if (!this._started)
      return;
    let increment = _SequenceRecorder.psbPacketType + _SequenceRecorder.attitudeMatrixPacketSizeBytes;
    this._growArrayBuffer(increment);
    this._dataView.setUint32(this._insertionByte, SequenceRecorderPacketType.ATTITUDE_MATRIX, true);
    this._insertionByte += _SequenceRecorder.psbPacketType;
    this._dataFloat32.set(m, this._insertionByte / 4);
    this._insertionByte += _SequenceRecorder.attitudeMatrixPacketSizeBytes;
    this._numberPackets++;
    this._dataView.setUint32(4, this._numberPackets, true);
  }
  _growArrayBuffer(requiredIncrement) {
    while (this._insertionByte + requiredIncrement > this._data.byteLength) {
      let newSize = Math.max(this._data.byteLength * 2, this._estimatedSize(50, 320, 240));
      let newData = new ArrayBuffer(newSize);
      let newDataUint8 = new Uint8Array(newData);
      newDataUint8.set(this._dataUint8);
      this._data = newData;
      this._dataUint8 = newDataUint8;
      this._dataFloat32 = new Float32Array(this._data);
      this._dataView = new DataView(this._data);
    }
  }
};
SequenceRecorder.headerSizeBytes = 8;
SequenceRecorder.psbPacketType = 4;
SequenceRecorder.psbCameraFrameWidth = 4;
SequenceRecorder.psbCameraFrameHeight = 4;
SequenceRecorder.psbFlags = 4;
SequenceRecorder.psbCameraToDeviceTransform = 4 * 16;
SequenceRecorder.psbCameraModel = 4 * 6;
SequenceRecorder.cameraPacketSizeBytes = SequenceRecorder.psbCameraFrameWidth + SequenceRecorder.psbCameraFrameHeight + SequenceRecorder.psbCameraToDeviceTransform + SequenceRecorder.psbCameraModel + SequenceRecorder.psbFlags;
SequenceRecorder.accelerometerPacketSizeBytes = 4 * 4;
SequenceRecorder.rotationRatePacketSizeBytes = 4 * 4;
SequenceRecorder.attitudePacketSizeBytes = 4 * 4;
SequenceRecorder.attitudeMatrixPacketSizeBytes = 4 * 16;
var SequenceDecoder = class {
  constructor(_data) {
    this._data = _data;
    this.dataByPacket = /* @__PURE__ */ new Map();
    this.dataByCameraFrame = /* @__PURE__ */ new Map();
    this.numberPackets = 0;
    this.numberCameraFrames = 0;
    this.numberAccelerometerPackets = 0;
    this.numberRotationRatePackets = 0;
    this.numberAttitudePackets = 0;
    this.numberAttitudeMatrixPackets = 0;
    let dec = new TextDecoder();
    let txt = "";
    try {
      txt = dec.decode(this._data.slice(0, 4));
    } catch (err) {
      throw new Error("Unable to decode header - perhaps this isn't a sequence file?");
    }
    if (txt !== "UAR1") {
      throw new Error(`Invalid - perhaps this isn't a sequence file: ${txt}`);
    }
    let readPoint = 0;
    let dataView = new DataView(this._data);
    this.numberPackets = dataView.getUint32(4, true);
    readPoint += SequenceRecorder.headerSizeBytes;
    for (let i = 0; i < this.numberPackets; i++) {
      let type = dataView.getUint32(readPoint, true);
      readPoint += SequenceRecorder.psbPacketType;
      switch (type) {
        case SequenceRecorderPacketType.CAMERA_FRAME: {
          let width = dataView.getUint32(readPoint, true);
          readPoint += SequenceRecorder.psbCameraFrameWidth;
          let height = dataView.getUint32(readPoint, true);
          readPoint += SequenceRecorder.psbCameraFrameHeight;
          let cameraToDevice = new Float32Array(this._data, readPoint, SequenceRecorder.psbCameraToDeviceTransform / 4);
          readPoint += SequenceRecorder.psbCameraToDeviceTransform;
          let cameraModel = new Float32Array(this._data, readPoint, SequenceRecorder.psbCameraModel / 4);
          readPoint += SequenceRecorder.psbCameraModel;
          let flags = dataView.getUint32(readPoint, true);
          readPoint += SequenceRecorder.psbFlags;
          let userFacing = flags === 1;
          let greyscale = new Uint8Array(this._data, readPoint, width * height);
          readPoint += width * height;
          let d = {
            type: SequenceRecorderPacketType.CAMERA_FRAME,
            width,
            height,
            cameraToDevice,
            cameraModel,
            userFacing,
            greyscale
          };
          this.dataByPacket.set(i, d);
          this.dataByCameraFrame.set(this.numberCameraFrames, d);
          this.numberCameraFrames++;
          break;
        }
        case SequenceRecorderPacketType.ACCELEROMETER: {
          let t = dataView.getUint32(readPoint, true);
          readPoint += 4;
          let x = dataView.getFloat32(readPoint, true);
          readPoint += 4;
          let y = dataView.getFloat32(readPoint, true);
          readPoint += 4;
          let z2 = dataView.getFloat32(readPoint, true);
          readPoint += 4;
          this.dataByPacket.set(i, {
            type: SequenceRecorderPacketType.ACCELEROMETER,
            t,
            x,
            y,
            z: z2
          });
          this.numberAccelerometerPackets++;
          break;
        }
        case SequenceRecorderPacketType.ROTATION_RATE: {
          let t = dataView.getUint32(readPoint, true);
          readPoint += 4;
          let x = dataView.getFloat32(readPoint, true);
          readPoint += 4;
          let y = dataView.getFloat32(readPoint, true);
          readPoint += 4;
          let z2 = dataView.getFloat32(readPoint, true);
          readPoint += 4;
          this.dataByPacket.set(i, {
            type: SequenceRecorderPacketType.ROTATION_RATE,
            t,
            x,
            y,
            z: z2
          });
          this.numberRotationRatePackets++;
          break;
        }
        case SequenceRecorderPacketType.ATTITUDE: {
          let t = dataView.getUint32(readPoint, true);
          readPoint += 4;
          let x = dataView.getFloat32(readPoint, true);
          readPoint += 4;
          let y = dataView.getFloat32(readPoint, true);
          readPoint += 4;
          let z2 = dataView.getFloat32(readPoint, true);
          readPoint += 4;
          this.dataByPacket.set(i, {
            type: SequenceRecorderPacketType.ATTITUDE,
            t,
            x,
            y,
            z: z2
          });
          this.numberAttitudePackets++;
          break;
        }
        case SequenceRecorderPacketType.ATTITUDE_MATRIX: {
          let attitude = new Float32Array(this._data, readPoint, SequenceRecorder.attitudeMatrixPacketSizeBytes / 4);
          readPoint += SequenceRecorder.attitudeMatrixPacketSizeBytes;
          this.dataByPacket.set(i, {
            type: SequenceRecorderPacketType.ATTITUDE_MATRIX,
            attitude
          });
          this.numberAttitudeMatrixPackets++;
          break;
        }
      }
    }
  }
};

// node_modules/@zappar/zappar-cv/lib/source.js
var Source = class {
};

// node_modules/@zappar/zappar-cv/lib/gl-state-manager.js
var managers = /* @__PURE__ */ new Map();
var GLStateManager = class _GLStateManager {
  constructor(_gl) {
    this._gl = _gl;
    this._viewports = [];
    this._underlyingViewport = this._gl.viewport;
    this._viewports.push(this._gl.getParameter(this._gl.VIEWPORT));
    this._gl.viewport = (x, y, width, height) => {
      this._viewports[this._viewports.length - 1] = [x, y, width, height];
      this._underlyingViewport.call(this._gl, x, y, width, height);
    };
  }
  static get(gl) {
    let existing = managers.get(gl);
    if (!existing) {
      existing = new _GLStateManager(gl);
      managers.set(gl, existing);
    }
    return existing;
  }
  push() {
    this._viewports.push(this._viewports[this._viewports.length - 1]);
  }
  pop() {
    const current = this._viewports.pop();
    const prev = this._viewports[this._viewports.length - 1];
    if (!current || current[0] !== prev[0] || current[1] !== prev[1] || current[2] !== prev[2] || current[3] !== prev[3]) {
      this._underlyingViewport.call(this._gl, prev[0], prev[1], prev[2], prev[3]);
    }
  }
};

// node_modules/@zappar/zappar-cv/lib/image-process-gl.js
var ImageProcessGL = class {
  constructor(_gl) {
    this._gl = _gl;
    this._isPaused = true;
    this._hadFrames = false;
    this._isUserFacing = false;
    this._cameraToScreenRotation = 0;
    this._isUploadFrame = true;
    this._computedTransformRotation = -1;
    this._computedFrontCameraRotation = false;
    this._cameraUvTransform = mat4_exports.create();
    this._framebufferWidth = 0;
    this._framebufferHeight = 0;
    this._framebufferId = null;
    this._renderTexture = null;
    this._isWebGL2 = false;
    this._isWebGL2 = _gl.getParameter(_gl.VERSION).indexOf("WebGL 2") >= 0;
    if (!this._isWebGL2) {
      this._instancedArraysExtension = this._gl.getExtension("ANGLE_instanced_arrays");
    }
  }
  resetGLContext() {
    this._framebufferId = null;
    this._renderTexture = null;
    this._vertexBuffer = void 0;
    this._indexBuffer = void 0;
    this._greyscaleShader = void 0;
  }
  destroy() {
    this.resetGLContext();
  }
  uploadFrame(texture, img, rotation, fc) {
    let gl = this._gl;
    const glStateManager = GLStateManager.get(gl);
    glStateManager.push();
    const reenableScissorTest = gl.isEnabled(gl.SCISSOR_TEST);
    const reenableDepthTest = gl.isEnabled(gl.DEPTH_TEST);
    const reenableBlend = gl.isEnabled(gl.BLEND);
    const reenableCullFace = gl.isEnabled(gl.CULL_FACE);
    const reenableStencilTest = gl.isEnabled(gl.STENCIL_TEST);
    const previousActiveTexture = gl.getParameter(gl.ACTIVE_TEXTURE);
    const previousUnpackFlip = gl.getParameter(gl.UNPACK_FLIP_Y_WEBGL);
    const previousProgram = gl.getParameter(gl.CURRENT_PROGRAM);
    gl.activeTexture(gl.TEXTURE0);
    const previousBoundTexture = gl.getParameter(gl.TEXTURE_BINDING_2D);
    const previousBoundFramebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
    const previousBoundArrayBuffer = gl.getParameter(gl.ARRAY_BUFFER_BINDING);
    const previousBoundElementArrayBuffer = gl.getParameter(gl.ELEMENT_ARRAY_BUFFER_BINDING);
    gl.disable(gl.SCISSOR_TEST);
    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.BLEND);
    gl.disable(gl.CULL_FACE);
    gl.disable(gl.STENCIL_TEST);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    const level = 0;
    const internalFormat = gl.RGBA;
    const srcFormat = gl.RGBA;
    const srcType = gl.UNSIGNED_BYTE;
    gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, srcFormat, srcType, img);
    let videoWidth = 0;
    let videoHeight = 0;
    if (typeof HTMLVideoElement !== "undefined" && img instanceof HTMLVideoElement) {
      videoWidth = img.videoWidth;
      videoHeight = img.videoHeight;
    } else {
      videoWidth = img.width;
      videoHeight = img.height;
    }
    if (videoHeight > videoWidth)
      videoHeight = [videoWidth, videoWidth = videoHeight][0];
    this._updateTransforms(rotation, fc);
    let framebuffer = this._getFramebuffer(gl, profile.dataWidth / 4, profile.dataHeight);
    let vbo2 = this._getVertexBuffer(gl);
    let ibo = this._getIndexBuffer(gl);
    let shader2 = this._getGreyscaleShader(gl);
    const previousVertexAttribSize = gl.getVertexAttrib(shader2.aVertexPositionLoc, gl.VERTEX_ATTRIB_ARRAY_SIZE);
    const previousVertexAttribType = gl.getVertexAttrib(shader2.aVertexPositionLoc, gl.VERTEX_ATTRIB_ARRAY_TYPE);
    const previousVertexAttribNormalized = gl.getVertexAttrib(shader2.aVertexPositionLoc, gl.VERTEX_ATTRIB_ARRAY_NORMALIZED);
    const previousVertexAttribStride = gl.getVertexAttrib(shader2.aVertexPositionLoc, gl.VERTEX_ATTRIB_ARRAY_STRIDE);
    const previousVertexAttribOffset = gl.getVertexAttribOffset(shader2.aVertexPositionLoc, gl.VERTEX_ATTRIB_ARRAY_POINTER);
    const previousVertexAttribEnabled = gl.getVertexAttrib(shader2.aVertexPositionLoc, gl.VERTEX_ATTRIB_ARRAY_ENABLED);
    const previousVertexAttribBufferBinding = gl.getVertexAttrib(shader2.aVertexPositionLoc, gl.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING);
    const previousTextureAttribSize = gl.getVertexAttrib(shader2.aTextureCoordLoc, gl.VERTEX_ATTRIB_ARRAY_SIZE);
    const previousTextureAttribType = gl.getVertexAttrib(shader2.aTextureCoordLoc, gl.VERTEX_ATTRIB_ARRAY_TYPE);
    const previousTextureAttribNormalized = gl.getVertexAttrib(shader2.aTextureCoordLoc, gl.VERTEX_ATTRIB_ARRAY_NORMALIZED);
    const previousTextureAttribStride = gl.getVertexAttrib(shader2.aTextureCoordLoc, gl.VERTEX_ATTRIB_ARRAY_STRIDE);
    const previousTextureAttribOffset = gl.getVertexAttribOffset(shader2.aTextureCoordLoc, gl.VERTEX_ATTRIB_ARRAY_POINTER);
    const previousTextureAttribBufferBinding = gl.getVertexAttrib(shader2.aTextureCoordLoc, gl.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING);
    const previousTextureAttribEnabled = gl.getVertexAttrib(shader2.aTextureCoordLoc, gl.VERTEX_ATTRIB_ARRAY_ENABLED);
    let previousVertexAttribDivisor = 0;
    let previousTextureAttribDivisor = 0;
    if (this._isWebGL2) {
      previousVertexAttribDivisor = gl.getVertexAttrib(shader2.aVertexPositionLoc, gl.VERTEX_ATTRIB_ARRAY_DIVISOR);
      previousTextureAttribDivisor = gl.getVertexAttrib(shader2.aTextureCoordLoc, gl.VERTEX_ATTRIB_ARRAY_DIVISOR);
      gl.vertexAttribDivisor(shader2.aVertexPositionLoc, 0);
      gl.vertexAttribDivisor(shader2.aTextureCoordLoc, 0);
    } else if (this._instancedArraysExtension) {
      previousVertexAttribDivisor = gl.getVertexAttrib(shader2.aVertexPositionLoc, this._instancedArraysExtension.VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE);
      previousTextureAttribDivisor = gl.getVertexAttrib(shader2.aTextureCoordLoc, this._instancedArraysExtension.VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE);
      this._instancedArraysExtension.vertexAttribDivisorANGLE(shader2.aVertexPositionLoc, 0);
      this._instancedArraysExtension.vertexAttribDivisorANGLE(shader2.aTextureCoordLoc, 0);
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    gl.viewport(0, 0, this._framebufferWidth, this._framebufferHeight);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo2);
    gl.vertexAttribPointer(shader2.aVertexPositionLoc, 2, gl.FLOAT, false, 4 * 4, 0);
    gl.enableVertexAttribArray(shader2.aVertexPositionLoc);
    gl.vertexAttribPointer(shader2.aTextureCoordLoc, 2, gl.FLOAT, false, 4 * 4, 2 * 4);
    gl.enableVertexAttribArray(shader2.aTextureCoordLoc);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
    gl.useProgram(shader2.program);
    gl.uniform1f(shader2.uTexWidthLoc, profile.dataWidth);
    gl.uniformMatrix4fv(shader2.uUvTransformLoc, false, this._cameraUvTransform);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.uniform1i(shader2.uSamplerLoc, 0);
    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
    gl.bindBuffer(gl.ARRAY_BUFFER, previousVertexAttribBufferBinding);
    gl.vertexAttribPointer(shader2.aVertexPositionLoc, previousVertexAttribSize, previousVertexAttribType, previousVertexAttribNormalized, previousVertexAttribStride, previousVertexAttribOffset);
    gl.bindBuffer(gl.ARRAY_BUFFER, previousTextureAttribBufferBinding);
    gl.vertexAttribPointer(shader2.aTextureCoordLoc, previousTextureAttribSize, previousTextureAttribType, previousTextureAttribNormalized, previousTextureAttribStride, previousTextureAttribOffset);
    gl.bindBuffer(gl.ARRAY_BUFFER, previousBoundArrayBuffer);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, previousBoundElementArrayBuffer);
    if (!previousVertexAttribEnabled)
      gl.disableVertexAttribArray(shader2.aVertexPositionLoc);
    if (!previousTextureAttribEnabled)
      gl.disableVertexAttribArray(shader2.aTextureCoordLoc);
    if (this._isWebGL2) {
      gl.vertexAttribDivisor(shader2.aVertexPositionLoc, previousVertexAttribDivisor);
      gl.vertexAttribDivisor(shader2.aTextureCoordLoc, previousTextureAttribDivisor);
    } else if (this._instancedArraysExtension) {
      this._instancedArraysExtension.vertexAttribDivisorANGLE(shader2.aVertexPositionLoc, previousVertexAttribDivisor);
      this._instancedArraysExtension.vertexAttribDivisorANGLE(shader2.aTextureCoordLoc, previousTextureAttribDivisor);
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, previousBoundFramebuffer);
    gl.useProgram(previousProgram);
    gl.bindTexture(gl.TEXTURE_2D, previousBoundTexture);
    gl.activeTexture(previousActiveTexture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, previousUnpackFlip);
    glStateManager.pop();
    if (reenableBlend)
      gl.enable(gl.BLEND);
    if (reenableCullFace)
      gl.enable(gl.CULL_FACE);
    if (reenableDepthTest)
      gl.enable(gl.DEPTH_TEST);
    if (reenableScissorTest)
      gl.enable(gl.SCISSOR_TEST);
    if (reenableStencilTest)
      gl.enable(gl.STENCIL_TEST);
  }
  readFrame(texture, pixels) {
    let gl = this._gl;
    let pixelsView = new Uint8Array(pixels);
    const previousBoundFramebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
    let framebuffer = this._getFramebuffer(gl, profile.dataWidth / 4, profile.dataHeight);
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    gl.readPixels(0, 0, this._framebufferWidth, this._framebufferHeight, gl.RGBA, gl.UNSIGNED_BYTE, pixelsView);
    gl.bindFramebuffer(gl.FRAMEBUFFER, previousBoundFramebuffer);
    return {
      uvTransform: this._cameraUvTransform,
      data: pixels,
      texture,
      dataWidth: profile.dataWidth,
      dataHeight: profile.dataHeight,
      userFacing: this._computedFrontCameraRotation
    };
  }
  _updateTransforms(rot, fc) {
    if (rot == this._computedTransformRotation && fc == this._computedFrontCameraRotation)
      return;
    this._computedTransformRotation = rot;
    this._computedFrontCameraRotation = fc;
    this._cameraUvTransform = this._getCameraUvTransform();
  }
  _getCameraUvTransform() {
    switch (this._computedTransformRotation) {
      case 270:
        return new Float32Array([0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1]);
      case 180:
        return new Float32Array([-1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1]);
      case 90:
        return new Float32Array([0, -1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1]);
    }
    return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
  }
  _getFramebuffer(gl, fbWidth, fbHeight) {
    if (this._framebufferWidth === fbWidth && this._framebufferHeight === fbHeight && this._framebufferId)
      return this._framebufferId;
    if (this._framebufferId) {
      gl.deleteFramebuffer(this._framebufferId);
      this._framebufferId = null;
    }
    if (this._renderTexture) {
      gl.deleteTexture(this._renderTexture);
      this._renderTexture = null;
    }
    this._framebufferId = gl.createFramebuffer();
    if (!this._framebufferId)
      throw new Error("Unable to create framebuffer");
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._framebufferId);
    this._renderTexture = gl.createTexture();
    if (!this._renderTexture)
      throw new Error("Unable to create render texture");
    gl.activeTexture(gl.TEXTURE0);
    const previousBoundTexture = gl.getParameter(gl.TEXTURE_BINDING_2D);
    gl.bindTexture(gl.TEXTURE_2D, this._renderTexture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, fbWidth, fbHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._renderTexture, 0);
    let fbStatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    if (fbStatus !== gl.FRAMEBUFFER_COMPLETE)
      throw new Error("Framebuffer not complete: " + fbStatus.toString());
    this._framebufferWidth = fbWidth;
    this._framebufferHeight = fbHeight;
    gl.bindTexture(gl.TEXTURE_2D, previousBoundTexture);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    return this._framebufferId;
  }
  _getVertexBuffer(gl) {
    if (this._vertexBuffer)
      return this._vertexBuffer;
    this._vertexBuffer = gl.createBuffer();
    if (!this._vertexBuffer)
      throw new Error("Unable to create vertex buffer");
    gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
    let buffer = new Float32Array([
      -1,
      -1,
      0,
      0,
      -1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      -1,
      1,
      0
    ]);
    gl.bufferData(gl.ARRAY_BUFFER, buffer, gl.STATIC_DRAW);
    return this._vertexBuffer;
  }
  _getIndexBuffer(gl) {
    if (this._indexBuffer)
      return this._indexBuffer;
    this._indexBuffer = gl.createBuffer();
    if (!this._indexBuffer)
      throw new Error("Unable to create index buffer");
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
    let buffer = new Uint16Array([0, 1, 2, 0, 2, 3]);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, buffer, gl.STATIC_DRAW);
    return this._indexBuffer;
  }
  _getGreyscaleShader(gl) {
    if (this._greyscaleShader)
      return this._greyscaleShader;
    let prog = gl.createProgram();
    if (!prog)
      throw new Error("Unable to create program");
    let vertexShader = compileShader(gl, gl.VERTEX_SHADER, greyscaleVsSource);
    let fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, greyscaleFsSource);
    gl.attachShader(prog, vertexShader);
    gl.attachShader(prog, fragmentShader);
    linkProgram(gl, prog);
    let uTexWidthLoc = gl.getUniformLocation(prog, "uTexWidth");
    if (!uTexWidthLoc)
      throw new Error("Unable to get uniform location uTexWidth");
    let uUvTransformLoc = gl.getUniformLocation(prog, "uUvTransform");
    if (!uUvTransformLoc)
      throw new Error("Unable to get uniform location uUvTransform");
    let uSamplerLoc = gl.getUniformLocation(prog, "uSampler");
    if (!uSamplerLoc)
      throw new Error("Unable to get uniform location uSampler");
    this._greyscaleShader = {
      program: prog,
      aVertexPositionLoc: gl.getAttribLocation(prog, "aVertexPosition"),
      aTextureCoordLoc: gl.getAttribLocation(prog, "aTextureCoord"),
      uTexWidthLoc,
      uUvTransformLoc,
      uSamplerLoc
    };
    return this._greyscaleShader;
  }
};
var greyscaleVsSource = `
    attribute vec4 aVertexPosition;
    attribute vec2 aTextureCoord;

    varying highp vec2 vTextureCoord1;
    varying highp vec2 vTextureCoord2;
    varying highp vec2 vTextureCoord3;
    varying highp vec2 vTextureCoord4;

    uniform float uTexWidth;
	uniform mat4 uUvTransform;

    void main(void) {
      highp vec2 offset1 = vec2(1.5 / uTexWidth, 0);
      highp vec2 offset2 = vec2(0.5 / uTexWidth, 0);

      gl_Position = aVertexPosition;
      vTextureCoord1 = (uUvTransform * vec4(aTextureCoord - offset1, 0, 1)).xy;
      vTextureCoord2 = (uUvTransform * vec4(aTextureCoord - offset2, 0, 1)).xy;
      vTextureCoord3 = (uUvTransform * vec4(aTextureCoord + offset2, 0, 1)).xy;
      vTextureCoord4 = (uUvTransform * vec4(aTextureCoord + offset1, 0, 1)).xy;
    }
`;
var greyscaleFsSource = `
  varying highp vec2 vTextureCoord1;
  varying highp vec2 vTextureCoord2;
  varying highp vec2 vTextureCoord3;
  varying highp vec2 vTextureCoord4;

  uniform sampler2D uSampler;

  const lowp vec3 colorWeights = vec3(77.0 / 256.0, 150.0 / 256.0, 29.0 / 256.0);

  void main(void) {
    lowp vec4 outpx;

    outpx.r = dot(colorWeights, texture2D(uSampler, vTextureCoord1).xyz);
    outpx.g = dot(colorWeights, texture2D(uSampler, vTextureCoord2).xyz);
    outpx.b = dot(colorWeights, texture2D(uSampler, vTextureCoord3).xyz);
    outpx.a = dot(colorWeights, texture2D(uSampler, vTextureCoord4).xyz);

    gl_FragColor = outpx;
  }
`;

// node_modules/@zappar/zappar-cv/lib/html-element-source.js
var latest = 1;
var byId = /* @__PURE__ */ new Map();
var HTMLElementSource = class _HTMLElementSource extends Source {
  constructor(_video, _pipeline) {
    super();
    this._video = _video;
    this._pipeline = _pipeline;
    this._isPaused = true;
    this._hadFrames = false;
    this._isUserFacing = false;
    this._cameraToScreenRotation = 0;
    this._isUploadFrame = true;
    this._cameraToDeviceTransform = mat4_exports.create();
    this._cameraToDeviceTransformUserFacing = mat4_exports.create();
    this._cameraModel = new Float32Array([300, 300, 160, 120, 0, 0]);
    mat4_exports.fromScaling(this._cameraToDeviceTransformUserFacing, [-1, 1, -1]);
    let video = this._video;
    if (this._video instanceof HTMLVideoElement) {
      video.addEventListener("loadedmetadata", () => {
        this._hadFrames = true;
      });
    } else {
      this._hadFrames = true;
    }
    this._resetGLContext = this._resetGLContext.bind(this);
    let p = Pipeline.get(this._pipeline);
    if (p)
      p.onGLContextReset.bind(this._resetGLContext);
  }
  static createVideoElementSource(p, element) {
    let ret = latest++;
    byId.set(ret, new _HTMLElementSource(element, p));
    zcout("html_element_source_t initialized");
    return ret;
  }
  static getVideoElementSource(m) {
    return byId.get(m);
  }
  _resetGLContext() {
    var _a, _b;
    this._currentVideoTexture = void 0;
    (_b = (_a = this._imageProcessor) === null || _a === void 0 ? void 0 : _a.resetGLContext) === null || _b === void 0 ? void 0 : _b.call(_a);
  }
  destroy() {
    let p = Pipeline.get(this._pipeline);
    if (p)
      p.onGLContextReset.unbind(this._resetGLContext);
    this.pause();
    this._resetGLContext();
  }
  pause() {
    this._isPaused = true;
    let p = Pipeline.get(this._pipeline);
    if (p && p.currentCameraSource === this)
      p.currentCameraSource = void 0;
  }
  start() {
    var _a;
    if (this._isPaused) {
      this._isUploadFrame = true;
      if (this._video instanceof HTMLVideoElement)
        this._hadFrames = false;
    }
    this._isPaused = false;
    let p = Pipeline.get(this._pipeline);
    if (p && p.currentCameraSource !== this) {
      (_a = p.currentCameraSource) === null || _a === void 0 ? void 0 : _a.pause();
      p.currentCameraSource = this;
    }
  }
  getFrame(currentlyProcessing) {
    let pipeline = Pipeline.get(this._pipeline);
    if (!pipeline)
      return;
    let gl = pipeline.glContext;
    if (!gl)
      return;
    if (this._isPaused)
      return;
    if (!this._hadFrames)
      return;
    try {
      let info = this._processFrame(gl, this._cameraToScreenRotation, currentlyProcessing);
      if (info) {
        let token = pipeline.registerToken(info);
        pipeline.sendDataToWorker(info.data || new ArrayBuffer(0), token, info.dataWidth, info.dataHeight, info.userFacing, info.cameraToDevice, info.cameraModel);
      }
    } catch (ex) {
      console.log("Unable to process frame");
    }
    return;
  }
  _processFrame(gl, rotation, currentlyProcessing) {
    let pipeline = Pipeline.get(this._pipeline);
    if (!pipeline)
      return void 0;
    if (!this._imageProcessor)
      this._imageProcessor = new ImageProcessGL(gl);
    if (this._isUploadFrame) {
      if (!this._currentVideoTexture) {
        this._currentVideoTexture = pipeline.getVideoTexture();
      }
      if (!this._currentVideoTexture)
        return void 0;
      this._imageProcessor.uploadFrame(this._currentVideoTexture, this._video, rotation, this._isUserFacing);
      this._isUploadFrame = !this._isUploadFrame;
      return void 0;
    }
    if (currentlyProcessing || !this._currentVideoTexture)
      return void 0;
    this._isUploadFrame = !this._isUploadFrame;
    let greySize = profile.dataWidth * profile.dataHeight;
    let pixels = pipeline.cameraPixelArrays.pop();
    while (pixels) {
      if (pixels.byteLength === greySize)
        break;
      pixels = pipeline.cameraPixelArrays.pop();
    }
    if (!pixels) {
      pixels = new ArrayBuffer(greySize);
    }
    let tex = this._currentVideoTexture;
    this._currentVideoTexture = void 0;
    let focalLength = 300 * profile.dataWidth / 320;
    this._cameraModel[0] = focalLength;
    this._cameraModel[1] = focalLength;
    this._cameraModel[2] = profile.dataWidth * 0.5;
    this._cameraModel[3] = profile.dataHeight * 0.5;
    return Object.assign(Object.assign({}, this._imageProcessor.readFrame(tex, pixels)), { cameraModel: this._cameraModel, cameraSource: this, cameraToDevice: this._isUserFacing ? this._cameraToDeviceTransformUserFacing : this._cameraToDeviceTransform });
  }
  uploadGL() {
  }
};

// node_modules/@zappar/zappar-cv/lib/camera-source.js
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var _videoSingleton = document.createElement("video");
_videoSingleton.setAttribute("playsinline", "");
_videoSingleton.setAttribute("webkit-playsinline", "");
if (profile.videoElementInDOM) {
  _videoSingleton.style.width = "0px";
  _videoSingleton.style.height = "0px";
  document.body.appendChild(_videoSingleton);
}
var CameraSource = class _CameraSource extends HTMLElementSource {
  constructor(_impl, pipeline, _deviceId) {
    super(_videoSingleton, pipeline);
    this._impl = _impl;
    this._deviceId = _deviceId;
    this._currentStream = null;
    this._activeDeviceId = null;
    this._hasStartedOrientation = false;
    this._deviceMotionListener = (ev) => {
      let pipeline2 = Pipeline.get(this._pipeline);
      if (!pipeline2)
        return;
      let timeStamp = ev.timeStamp !== void 0 && ev.timeStamp !== null ? ev.timeStamp : performance.now();
      if (ev.accelerationIncludingGravity !== null && ev.accelerationIncludingGravity.x !== null && ev.accelerationIncludingGravity.y !== null && ev.accelerationIncludingGravity.z !== null) {
        pipeline2.motionAccelerometerSubmit(timeStamp, ev.accelerationIncludingGravity.x * profile.deviceMotionMutliplier, ev.accelerationIncludingGravity.y * profile.deviceMotionMutliplier, ev.accelerationIncludingGravity.z * profile.deviceMotionMutliplier);
      }
      if (ev.rotationRate !== null && ev.rotationRate.alpha !== null && ev.rotationRate.beta !== null && ev.rotationRate.gamma !== null && !this._hasStartedOrientation) {
        ev.timeStamp;
        pipeline2.motionRotationRateSubmit(timeStamp, ev.rotationRate.alpha * Math.PI / -180, ev.rotationRate.beta * Math.PI / -180, ev.rotationRate.gamma * Math.PI / -180);
      } else if (!this._hasStartedOrientation) {
        this._startDeviceOrientation();
      }
    };
  }
  destroy() {
    deleteCameraSource(this._impl);
    super.destroy();
  }
  _stop() {
    if (!this._currentStream)
      return;
    let tracks = this._currentStream.getTracks();
    tracks.forEach((t) => t.stop());
    this._currentStream = null;
  }
  pause() {
    super.pause();
    this._stopDeviceMotion();
    this._syncCamera();
  }
  start() {
    super.start();
    this._startDeviceMotion();
    this._syncCamera();
  }
  _getConstraints() {
    return __awaiter3(this, void 0, void 0, function* () {
      let deviceId;
      let facingMode;
      if (this._deviceId !== _CameraSource.DEFAULT_DEVICE_ID && this._deviceId !== _CameraSource.USER_DEFAULT_DEVICE_ID) {
        deviceId = this._deviceId;
      } else {
        facingMode = this._deviceId === _CameraSource.DEFAULT_DEVICE_ID ? "environment" : "user";
        if (profile.ios164CameraSelection) {
          if (!this._explicitEnvironmentCameraId || !this._explicitUserCameraId) {
            const stream = yield navigator.mediaDevices.getUserMedia({ audio: false, video: { facingMode } });
            let tracks = stream.getTracks();
            tracks.forEach((t) => t.stop());
            let devices2 = yield navigator.mediaDevices.enumerateDevices();
            devices2 = devices2.filter((val) => val.kind === "videoinput");
            if (devices2.length >= 2) {
              this._explicitUserCameraId = devices2[0].deviceId;
              this._explicitEnvironmentCameraId = devices2[1].deviceId;
            }
          }
          deviceId = facingMode === "environment" ? this._explicitEnvironmentCameraId : this._explicitUserCameraId;
        }
      }
      let constraints = {
        audio: false,
        video: {
          facingMode,
          width: profile.videoWidth,
          height: profile.videoHeight,
          frameRate: profile.requestHighFrameRate ? 60 : void 0,
          deviceId
        }
      };
      if (deviceId || profile.relyOnConstraintsForCameraSelection)
        return constraints;
      if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices)
        return constraints;
      let devices = yield navigator.mediaDevices.enumerateDevices();
      let hasHadCapabilities = false;
      devices = devices.filter((val) => {
        if (val.kind !== "videoinput")
          return false;
        if (val.getCapabilities) {
          hasHadCapabilities = true;
          let capabilities = val.getCapabilities();
          if (capabilities && capabilities.facingMode && capabilities.facingMode.indexOf(facingMode === "user" ? "user" : "environment") < 0)
            return false;
        }
        return true;
      });
      if (!hasHadCapabilities || devices.length === 0) {
        return constraints;
      }
      if (typeof constraints.video === "object") {
        zcout("choosing device ID", devices[devices.length - 1].deviceId);
        constraints.video.deviceId = devices[devices.length - 1].deviceId;
      }
      return constraints;
    });
  }
  getFrame(allowRead) {
    this._cameraToScreenRotation = cameraRotationForScreenOrientation(false);
    super.getFrame(allowRead);
  }
  _getUserMedia() {
    return __awaiter3(this, void 0, void 0, function* () {
      let constraints = yield this._getConstraints();
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia)
        return yield navigator.mediaDevices.getUserMedia(constraints);
      return yield new Promise((resolve, reject) => {
        navigator.getUserMedia(constraints, resolve, reject);
      });
    });
  }
  _syncCamera() {
    return __awaiter3(this, void 0, void 0, function* () {
      if (this._currentStream && this._isPaused) {
        this._stop();
        return;
      }
      if (this._currentStream && this._activeDeviceId !== this._deviceId)
        this._stop();
      if (!this._isPaused) {
        this._activeDeviceId = this._deviceId;
        this._currentStream = yield this._getUserMedia();
        if (this._isPaused) {
          yield this._syncCamera();
          return;
        }
        this._isUserFacing = false;
        if (this._currentStream) {
          let videoTracks = this._currentStream.getVideoTracks();
          if (videoTracks.length > 0) {
            this._isUserFacing = videoTracks[0].getSettings().facingMode === "user";
          }
        }
        if (!(this._video instanceof HTMLVideoElement))
          return;
        this._video.src = "";
        this._video.loop = false;
        this._video.muted = true;
        this._video.srcObject = this._currentStream;
        this._video.play();
      }
    });
  }
  _startDeviceOrientation() {
    if (this._hasStartedOrientation)
      return;
    this._hasStartedOrientation = true;
    this._deviceOrientationListener = (ev) => {
      let pipeline = Pipeline.get(this._pipeline);
      if (!pipeline)
        return;
      let timeStamp = ev.timeStamp !== void 0 && ev.timeStamp !== null ? ev.timeStamp : performance.now();
      if (ev.alpha === null || ev.beta === null || ev.gamma === null)
        return;
      pipeline.motionAttitudeSubmit(timeStamp, ev.alpha, ev.beta, ev.gamma);
    };
    window.addEventListener("deviceorientation", this._deviceOrientationListener);
  }
  _startDeviceMotion() {
    window.addEventListener("devicemotion", this._deviceMotionListener, false);
  }
  _stopDeviceMotion() {
    window.removeEventListener("devicemotion", this._deviceMotionListener);
    if (this._deviceOrientationListener)
      window.removeEventListener("deviceorientation", this._deviceOrientationListener);
  }
};
CameraSource.USER_DEFAULT_DEVICE_ID = "Simulated User Default Device ID: a908df7f-5661-4d20-b227-a1c15d2fdb4b";
CameraSource.DEFAULT_DEVICE_ID = "Simulated Default Device ID: a908df7f-5661-4d20-b227-a1c15d2fdb4b";

// node_modules/@zappar/zappar-cv/lib/imagebitmap-camera-source.js
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ImageBitmapCameraSource = class _ImageBitmapCameraSource extends Source {
  constructor(_impl, _pipeline, _deviceId) {
    super();
    this._impl = _impl;
    this._pipeline = _pipeline;
    this._deviceId = _deviceId;
    this._currentStream = null;
    this._activeDeviceId = null;
    this._isPaused = true;
    this._isUserFacing = false;
    this._hadFrames = false;
    this._canvas = new OffscreenCanvas(640, 480);
    this._context = this._canvas.getContext("2d");
    this._lastFrameTime = -1;
    this._video = document.createElement("video");
    this._cameraToDeviceTransform = mat4_exports.create();
    this._cameraToDeviceTransformUserFacing = mat4_exports.create();
    this._cameraModel = new Float32Array([300, 300, 160, 120, 0, 0]);
    this._hasStartedOrientation = false;
    this._deviceMotionListener = (ev) => {
      let pipeline = Pipeline.get(this._pipeline);
      if (!pipeline)
        return;
      let timeStamp = ev.timeStamp !== void 0 && ev.timeStamp !== null ? ev.timeStamp : performance.now();
      if (ev.accelerationIncludingGravity !== null && ev.accelerationIncludingGravity.x !== null && ev.accelerationIncludingGravity.y !== null && ev.accelerationIncludingGravity.z !== null) {
        pipeline.motionAccelerometerSubmit(timeStamp, ev.accelerationIncludingGravity.x * profile.deviceMotionMutliplier, ev.accelerationIncludingGravity.y * profile.deviceMotionMutliplier, ev.accelerationIncludingGravity.z * profile.deviceMotionMutliplier);
      }
      if (ev.rotationRate !== null && ev.rotationRate.alpha !== null && ev.rotationRate.beta !== null && ev.rotationRate.gamma !== null && !this._hasStartedOrientation) {
        ev.timeStamp;
        pipeline.motionRotationRateSubmit(timeStamp, ev.rotationRate.alpha * Math.PI / -180, ev.rotationRate.beta * Math.PI / -180, ev.rotationRate.gamma * Math.PI / -180);
      } else if (!this._hasStartedOrientation) {
        this._startDeviceOrientation();
      }
    };
    zcout("Using ImageBitmap camera source");
    mat4_exports.fromScaling(this._cameraToDeviceTransformUserFacing, [-1, 1, -1]);
    this._video.muted = true;
    this._video.setAttribute("playsinline", "");
    this._video.setAttribute("webkit-playsinline", "");
    if (profile.videoElementInDOM) {
      this._video.style.width = "0px";
      this._video.style.height = "0px";
      document.body.appendChild(this._video);
    }
    this._video.addEventListener("loadedmetadata", () => {
      this._hadFrames = true;
    });
  }
  destroy() {
    this.pause();
    deleteCameraSource(this._impl);
  }
  _stop() {
    if (!this._currentStream)
      return;
    let tracks = this._currentStream.getTracks();
    tracks.forEach((t) => t.stop());
    this._currentStream = null;
  }
  pause() {
    this._isPaused = true;
    let p = Pipeline.get(this._pipeline);
    if (p && p.currentCameraSource === this)
      p.currentCameraSource = void 0;
    this._stopDeviceMotion();
    this._syncCamera();
  }
  start() {
    var _a;
    let p = Pipeline.get(this._pipeline);
    if (p && p.currentCameraSource !== this) {
      (_a = p.currentCameraSource) === null || _a === void 0 ? void 0 : _a.pause();
      p.currentCameraSource = this;
    }
    this._isPaused = false;
    this._startDeviceMotion();
    this._syncCamera();
  }
  _getConstraints() {
    return __awaiter4(this, void 0, void 0, function* () {
      let deviceId;
      let facingMode;
      if (this._deviceId !== _ImageBitmapCameraSource.DEFAULT_DEVICE_ID && this._deviceId !== _ImageBitmapCameraSource.USER_DEFAULT_DEVICE_ID) {
        deviceId = this._deviceId;
      } else {
        facingMode = this._deviceId === _ImageBitmapCameraSource.DEFAULT_DEVICE_ID ? "environment" : "user";
      }
      let constraints = {
        audio: false,
        video: {
          facingMode,
          width: profile.videoWidth,
          height: profile.videoHeight,
          frameRate: profile.requestHighFrameRate ? 60 : void 0,
          deviceId
        }
      };
      if (deviceId)
        return constraints;
      if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices)
        return constraints;
      let devices = yield navigator.mediaDevices.enumerateDevices();
      let hasHadCapabilities = false;
      devices = devices.filter((val) => {
        if (val.kind !== "videoinput")
          return false;
        if (val.getCapabilities) {
          hasHadCapabilities = true;
          let capabilities = val.getCapabilities();
          if (capabilities && capabilities.facingMode && capabilities.facingMode.indexOf(facingMode === "user" ? "user" : "environment") < 0)
            return false;
        }
        return true;
      });
      if (!hasHadCapabilities || devices.length === 0) {
        return constraints;
      }
      if (typeof constraints.video === "object") {
        zcout("choosing device ID", devices[devices.length - 1].deviceId);
        constraints.video.deviceId = devices[devices.length - 1].deviceId;
      }
      return constraints;
    });
  }
  getFrame(currentlyProcessing) {
    var _a, _b;
    if (!this._context)
      return;
    if (!this._hadFrames)
      return;
    if (currentlyProcessing)
      return;
    let currentTime = performance.now();
    if (currentTime < this._lastFrameTime + 25)
      return;
    this._lastFrameTime = currentTime;
    if (this._canvas.width !== this._video.videoWidth)
      this._canvas.width = this._video.videoWidth;
    if (this._canvas.height !== this._video.videoHeight)
      this._canvas.height = this._video.videoHeight;
    this._context.drawImage(this._video, 0, 0);
    const imageBitmap = this._canvas.transferToImageBitmap();
    let rotation = cameraRotationForScreenOrientation(false);
    let pipeline = Pipeline.get(this._pipeline);
    if (!pipeline)
      return;
    let focalLength = 300 * profile.dataWidth / 320;
    this._cameraModel[0] = focalLength;
    this._cameraModel[1] = focalLength;
    this._cameraModel[2] = profile.dataWidth * 0.5;
    this._cameraModel[3] = profile.dataHeight * 0.5;
    let token = pipeline.registerToken({
      dataWidth: this._canvas.width,
      dataHeight: this._canvas.height,
      texture: void 0,
      userFacing: this._isUserFacing,
      cameraSource: this,
      cameraModel: this._cameraModel.slice(),
      cameraToDevice: this._isUserFacing ? this._cameraToDeviceTransformUserFacing : this._cameraToDeviceTransform
    });
    (_b = (_a = Pipeline.get(this._pipeline)) === null || _a === void 0 ? void 0 : _a.sendImageBitmapToWorker) === null || _b === void 0 ? void 0 : _b.call(_a, imageBitmap, rotation, this._isUserFacing, token, this._cameraModel, this._isUserFacing ? this._cameraToDeviceTransformUserFacing : this._cameraToDeviceTransform);
    return;
  }
  _getUserMedia() {
    return __awaiter4(this, void 0, void 0, function* () {
      let constraints = yield this._getConstraints();
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia)
        return yield navigator.mediaDevices.getUserMedia(constraints);
      return yield new Promise((resolve, reject) => {
        navigator.getUserMedia(constraints, resolve, reject);
      });
    });
  }
  _syncCamera() {
    return __awaiter4(this, void 0, void 0, function* () {
      if (this._currentStream && this._isPaused) {
        this._stop();
        return;
      }
      if (this._currentStream && this._activeDeviceId !== this._deviceId)
        this._stop();
      if (!this._isPaused) {
        this._activeDeviceId = this._deviceId;
        this._currentStream = yield this._getUserMedia();
        if (this._isPaused) {
          yield this._syncCamera();
          return;
        }
        this._isUserFacing = false;
        if (this._currentStream) {
          let videoTracks = this._currentStream.getVideoTracks();
          if (videoTracks.length > 0) {
            this._isUserFacing = videoTracks[0].getSettings().facingMode === "user";
          }
        }
        this._video.src = "";
        this._video.loop = false;
        this._video.muted = true;
        this._video.srcObject = this._currentStream;
        this._video.play();
      }
    });
  }
  _startDeviceOrientation() {
    if (this._hasStartedOrientation)
      return;
    this._hasStartedOrientation = true;
    window.addEventListener("deviceorientation", (ev) => {
      let pipeline = Pipeline.get(this._pipeline);
      if (!pipeline)
        return;
      let timeStamp = ev.timeStamp !== void 0 && ev.timeStamp !== null ? ev.timeStamp : performance.now();
      if (ev.alpha === null || ev.beta === null || ev.gamma === null)
        return;
      pipeline.motionAttitudeSubmit(timeStamp, ev.alpha, ev.beta, ev.gamma);
    });
  }
  _startDeviceMotion() {
    window.addEventListener("devicemotion", this._deviceMotionListener, false);
  }
  _stopDeviceMotion() {
    window.removeEventListener("devicemotion", this._deviceMotionListener);
  }
  uploadGL(info) {
    const pipeline = Pipeline.get(this._pipeline);
    const gl = pipeline === null || pipeline === void 0 ? void 0 : pipeline.glContext;
    if (!info || info.texture || !info.frame || !pipeline || !gl)
      return;
    let texture = pipeline.getVideoTexture();
    if (!texture)
      return;
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, info.frame);
    gl.bindTexture(gl.TEXTURE_2D, null);
    info.texture = texture;
    info.frame.close();
    delete info.frame;
  }
};
ImageBitmapCameraSource.USER_DEFAULT_DEVICE_ID = "Simulated User Default Device ID: a908df7f-5661-4d20-b227-a1c15d2fdb4b";
ImageBitmapCameraSource.DEFAULT_DEVICE_ID = "Simulated Default Device ID: a908df7f-5661-4d20-b227-a1c15d2fdb4b";

// node_modules/@zappar/zappar-cv/lib/mstp-camera-source.js
var __awaiter5 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var MSTPCameraSource = class _MSTPCameraSource extends Source {
  constructor(_impl, _pipeline, _deviceId) {
    super();
    this._impl = _impl;
    this._pipeline = _pipeline;
    this._deviceId = _deviceId;
    this._currentStream = null;
    this._activeDeviceId = null;
    this._isPaused = true;
    this._isUserFacing = false;
    this._cameraToScreenRotation = 0;
    this._hasStartedOrientation = false;
    this._deviceMotionListener = (ev) => {
      let pipeline = Pipeline.get(this._pipeline);
      if (!pipeline)
        return;
      let timeStamp = ev.timeStamp !== void 0 && ev.timeStamp !== null ? ev.timeStamp : performance.now();
      if (ev.accelerationIncludingGravity !== null && ev.accelerationIncludingGravity.x !== null && ev.accelerationIncludingGravity.y !== null && ev.accelerationIncludingGravity.z !== null) {
        pipeline.motionAccelerometerSubmit(timeStamp, ev.accelerationIncludingGravity.x * profile.deviceMotionMutliplier, ev.accelerationIncludingGravity.y * profile.deviceMotionMutliplier, ev.accelerationIncludingGravity.z * profile.deviceMotionMutliplier);
      }
      if (ev.rotationRate !== null && ev.rotationRate.alpha !== null && ev.rotationRate.beta !== null && ev.rotationRate.gamma !== null && !this._hasStartedOrientation) {
        ev.timeStamp;
        pipeline.motionRotationRateSubmit(timeStamp, ev.rotationRate.alpha * Math.PI / -180, ev.rotationRate.beta * Math.PI / -180, ev.rotationRate.gamma * Math.PI / -180);
      } else if (!this._hasStartedOrientation) {
        this._startDeviceOrientation();
      }
    };
    zcout("Using MSTP camera source");
  }
  destroy() {
    this.pause();
    deleteCameraSource(this._impl);
  }
  _stop() {
    if (!this._currentStream)
      return;
    let tracks = this._currentStream.getTracks();
    tracks.forEach((t) => t.stop());
    this._currentStream = null;
  }
  pause() {
    this._isPaused = true;
    let p = Pipeline.get(this._pipeline);
    if (p && p.currentCameraSource === this)
      p.currentCameraSource = void 0;
    this._stopDeviceMotion();
    this._syncCamera();
  }
  start() {
    var _a;
    let p = Pipeline.get(this._pipeline);
    if (p && p.currentCameraSource !== this) {
      (_a = p.currentCameraSource) === null || _a === void 0 ? void 0 : _a.pause();
      p.currentCameraSource = this;
    }
    this._isPaused = false;
    this._startDeviceMotion();
    this._syncCamera();
  }
  _getConstraints() {
    return __awaiter5(this, void 0, void 0, function* () {
      let deviceId;
      let facingMode;
      if (this._deviceId !== _MSTPCameraSource.DEFAULT_DEVICE_ID && this._deviceId !== _MSTPCameraSource.USER_DEFAULT_DEVICE_ID) {
        deviceId = this._deviceId;
      } else {
        facingMode = this._deviceId === _MSTPCameraSource.DEFAULT_DEVICE_ID ? "environment" : "user";
      }
      let constraints = {
        audio: false,
        video: {
          facingMode,
          width: profile.videoWidth,
          height: profile.videoHeight,
          frameRate: profile.requestHighFrameRate ? 60 : 30,
          deviceId
        }
      };
      if (deviceId)
        return constraints;
      if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices)
        return constraints;
      let devices = yield navigator.mediaDevices.enumerateDevices();
      let hasHadCapabilities = false;
      devices = devices.filter((val) => {
        if (val.kind !== "videoinput")
          return false;
        if (val.getCapabilities) {
          hasHadCapabilities = true;
          let capabilities = val.getCapabilities();
          if (capabilities && capabilities.facingMode && capabilities.facingMode.indexOf(facingMode === "user" ? "user" : "environment") < 0)
            return false;
        }
        return true;
      });
      if (!hasHadCapabilities || devices.length === 0) {
        return constraints;
      }
      if (typeof constraints.video === "object") {
        zcout("choosing device ID", devices[devices.length - 1].deviceId);
        constraints.video.deviceId = devices[devices.length - 1].deviceId;
      }
      return constraints;
    });
  }
  getFrame(allowRead) {
    var _a, _b;
    let rotation = cameraRotationForScreenOrientation(false);
    if (rotation != this._cameraToScreenRotation) {
      (_b = (_a = Pipeline.get(this._pipeline)) === null || _a === void 0 ? void 0 : _a.sendCameraToScreenRotationToWorker) === null || _b === void 0 ? void 0 : _b.call(_a, rotation);
      this._cameraToScreenRotation = rotation;
    }
    return;
  }
  _getUserMedia() {
    return __awaiter5(this, void 0, void 0, function* () {
      let constraints = yield this._getConstraints();
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia)
        return yield navigator.mediaDevices.getUserMedia(constraints);
      return yield new Promise((resolve, reject) => {
        navigator.getUserMedia(constraints, resolve, reject);
      });
    });
  }
  _syncCamera() {
    return __awaiter5(this, void 0, void 0, function* () {
      if (this._currentStream && this._isPaused) {
        this._stop();
        return;
      }
      if (this._currentStream && this._activeDeviceId !== this._deviceId)
        this._stop();
      if (!this._isPaused) {
        this._activeDeviceId = this._deviceId;
        this._currentStream = yield this._getUserMedia();
        if (this._isPaused) {
          yield this._syncCamera();
          return;
        }
        this._isUserFacing = false;
        if (this._currentStream) {
          let videoTracks = this._currentStream.getVideoTracks();
          if (videoTracks.length > 0) {
            this._isUserFacing = videoTracks[0].getSettings().facingMode === "user";
            let processor = new MediaStreamTrackProcessor({
              track: videoTracks[0]
            });
            let p = Pipeline.get(this._pipeline);
            if (p)
              p.sendCameraStreamToWorker(this._impl, processor.readable, this._isUserFacing);
          }
        }
      }
    });
  }
  _startDeviceOrientation() {
    if (this._hasStartedOrientation)
      return;
    this._hasStartedOrientation = true;
    window.addEventListener("deviceorientation", (ev) => {
      let pipeline = Pipeline.get(this._pipeline);
      if (!pipeline)
        return;
      let timeStamp = ev.timeStamp !== void 0 && ev.timeStamp !== null ? ev.timeStamp : performance.now();
      if (ev.alpha === null || ev.beta === null || ev.gamma === null)
        return;
      pipeline.motionAttitudeSubmit(timeStamp, ev.alpha, ev.beta, ev.gamma);
    });
  }
  _startDeviceMotion() {
    window.addEventListener("devicemotion", this._deviceMotionListener, false);
  }
  _stopDeviceMotion() {
    window.removeEventListener("devicemotion", this._deviceMotionListener);
  }
  uploadGL(info) {
    const pipeline = Pipeline.get(this._pipeline);
    const gl = pipeline === null || pipeline === void 0 ? void 0 : pipeline.glContext;
    if (!info || info.texture || !info.frame || !pipeline || !gl)
      return;
    let texture = pipeline.getVideoTexture();
    if (!texture)
      return;
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, info.frame);
    gl.bindTexture(gl.TEXTURE_2D, null);
    info.texture = texture;
    info.frame.close();
    delete info.frame;
  }
};
MSTPCameraSource.USER_DEFAULT_DEVICE_ID = "Simulated User Default Device ID: a908df7f-5661-4d20-b227-a1c15d2fdb4b";
MSTPCameraSource.DEFAULT_DEVICE_ID = "Simulated Default Device ID: a908df7f-5661-4d20-b227-a1c15d2fdb4b";

// node_modules/@zappar/zappar-cv/lib/camera-source-map.js
var latest2 = 1;
var byId2 = /* @__PURE__ */ new Map();
function getNextCameraSourceId() {
  return latest2++;
}
function setCameraSourceId(id, c) {
  byId2.set(id, c);
}
function getCameraSource(id) {
  return byId2.get(id);
}
function deleteCameraSource(id) {
  byId2.delete(id);
}
function createCameraSource(p, deviceId) {
  let ret = getNextCameraSourceId();
  if (profile.preferMediaStreamTrackProcessorCamera && "MediaStreamTrackProcessor" in window && "MediaStreamTrackGenerator" in window)
    setCameraSourceId(ret, new MSTPCameraSource(ret, p, deviceId));
  else if (profile.preferImageBitmapCamera && typeof OffscreenCanvas !== "undefined")
    setCameraSourceId(ret, new ImageBitmapCameraSource(ret, p, deviceId));
  else
    setCameraSourceId(ret, new CameraSource(ret, p, deviceId));
  zcout("camera_source_t initialized");
  return ret;
}

// node_modules/@zappar/zappar-cv/lib/drawpreviewmesh.js
var PreviewMeshDraw = class {
  constructor(_gl) {
    this._gl = _gl;
  }
  dispose() {
    if (this._vbo)
      this._gl.deleteBuffer(this._vbo);
    if (this._uvbo)
      this._gl.deleteBuffer(this._uvbo);
    if (this._ibo)
      this._gl.deleteBuffer(this._ibo);
    if (this._shader)
      this._gl.deleteProgram(this._shader.prog);
    this._vbo = void 0;
    this._uvbo = void 0;
    this._ibo = void 0;
    this._shader = void 0;
  }
  _generateIBO(indices, gl) {
    if (this._ibo && this._lastIndices === indices)
      return this._ibo;
    this._lastIndices = indices;
    if (!this._ibo)
      this._ibo = gl.createBuffer();
    if (!this._ibo)
      throw new Error("Unable to create buffer object");
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._ibo);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    return this._ibo;
  }
  _generateVBO(face, gl) {
    if (!this._vbo)
      this._vbo = gl.createBuffer();
    if (!this._vbo)
      throw new Error("Unable to create buffer object");
    gl.bindBuffer(gl.ARRAY_BUFFER, this._vbo);
    gl.bufferData(gl.ARRAY_BUFFER, face, gl.STATIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    return this._vbo;
  }
  _generateUVBO(face, gl) {
    if (!this._uvbo)
      this._uvbo = gl.createBuffer();
    if (!this._uvbo)
      throw new Error("Unable to create buffer object");
    gl.bindBuffer(gl.ARRAY_BUFFER, this._uvbo);
    gl.bufferData(gl.ARRAY_BUFFER, face, gl.STATIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    return this._uvbo;
  }
  draw(matrix, tracker, indx) {
    var _a;
    const o = tracker.getPreviewMesh(indx);
    const image = (_a = tracker.getTargetInfo(indx).preview) === null || _a === void 0 ? void 0 : _a.image;
    if (!o || !image)
      return;
    if (!image.complete)
      return;
    let gl = this._gl;
    let shader2 = this._getShader(gl);
    let v = this._generateVBO(o.vertices, gl);
    let n = this._generateUVBO(o.uvs, gl);
    let i = this._generateIBO(o.indices, gl);
    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.CULL_FACE);
    gl.useProgram(shader2.prog);
    gl.uniformMatrix4fv(shader2.unif_matrix, false, matrix);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, loadTexture2(gl, image));
    gl.uniform1i(shader2.unif_skinSampler, 0);
    gl.bindBuffer(gl.ARRAY_BUFFER, v);
    gl.vertexAttribPointer(shader2.attr_position, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(shader2.attr_position);
    gl.bindBuffer(gl.ARRAY_BUFFER, n);
    gl.vertexAttribPointer(shader2.attr_textureCoord, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(shader2.attr_textureCoord);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, i);
    gl.drawElements(gl.TRIANGLES, o.indices.length, gl.UNSIGNED_SHORT, 0);
    gl.disableVertexAttribArray(shader2.attr_position);
    gl.disableVertexAttribArray(shader2.attr_textureCoord);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
  }
  _getShader(gl) {
    if (this._shader)
      return this._shader;
    let prog = gl.createProgram();
    if (!prog)
      throw new Error("Unable to create program");
    let vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexShaderSrc5);
    let fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSrc5);
    gl.attachShader(prog, vertexShader);
    gl.attachShader(prog, fragmentShader);
    linkProgram(gl, prog);
    let unif_matrix = gl.getUniformLocation(prog, "matrix");
    if (!unif_matrix)
      throw new Error("Unable to get uniform location mattrix");
    let unif_skinSampler = gl.getUniformLocation(prog, "skinSampler");
    if (!unif_skinSampler)
      throw new Error("Unable to get uniform location skinSampler");
    this._shader = {
      prog,
      unif_matrix,
      unif_skinSampler,
      attr_position: gl.getAttribLocation(prog, "position"),
      attr_textureCoord: gl.getAttribLocation(prog, "textureCoord")
    };
    return this._shader;
  }
};
var texturesByElement = /* @__PURE__ */ new Map();
function loadTexture2(gl, elm) {
  let existing = texturesByElement.get(elm);
  if (existing)
    return existing;
  existing = gl.createTexture() || void 0;
  if (!existing)
    throw new Error("Unable to create texture");
  texturesByElement.set(elm, existing);
  gl.bindTexture(gl.TEXTURE_2D, existing);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  const level = 0;
  const internalFormat = gl.RGBA;
  const srcFormat = gl.RGBA;
  const srcType = gl.UNSIGNED_BYTE;
  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
  gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, srcFormat, srcType, elm);
  elm.addEventListener("load", () => {
    if (!existing)
      return;
    gl.bindTexture(gl.TEXTURE_2D, existing);
    const level2 = 0;
    const internalFormat2 = gl.RGBA;
    const srcFormat2 = gl.RGBA;
    const srcType2 = gl.UNSIGNED_BYTE;
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.texImage2D(gl.TEXTURE_2D, level2, internalFormat2, srcFormat2, srcType2, elm);
  });
  return existing;
}
var vertexShaderSrc5 = `
#ifndef GL_ES
#define highp
#define mediump
#define lowp
#endif

uniform mat4 matrix;
attribute vec4 position;
attribute vec2 textureCoord;

varying highp vec2 vTextureCoord;

void main()
{
    gl_Position = matrix * position;
    vTextureCoord = textureCoord;
}`;
var fragmentShaderSrc5 = `
#define highp mediump
#ifdef GL_ES
    // define default precision for float, vec, mat.
    precision highp float;
#else
#define highp
#define mediump
#define lowp
#endif

varying highp vec2 vTextureCoord;
uniform sampler2D skinSampler;

void main()
{
    gl_FragColor = texture2D(skinSampler, vTextureCoord);
}`;

// node_modules/@zappar/zappar-cv/lib/pipeline.js
var byId3 = /* @__PURE__ */ new Map();
var identity3 = mat4_exports.create();
var Pipeline = class _Pipeline {
  constructor(_client, _impl, _mgr) {
    this._client = _client;
    this._impl = _impl;
    this._mgr = _mgr;
    this.pendingMessages = [];
    this.cameraTokens = /* @__PURE__ */ new Map();
    this.nextCameraToken = 1;
    this.tokensInFlight = 0;
    this.videoTextures = [];
    this.cameraPixelArrays = [];
    this._sequenceRecordDeviceAttitudeMatrices = true;
    this._sequenceRecorderFirstCameraToken = 0;
    this.onGLContextReset = new Event2();
  }
  static create(client2, mgr) {
    let ret = client2.pipeline_create();
    byId3.set(ret, new _Pipeline(client2, ret, mgr));
    return ret;
  }
  static get(p) {
    return byId3.get(p);
  }
  frameUpdate(client2) {
    for (let msg of this.pendingMessages) {
      client2.processMessages(msg);
      this._mgr.postOutgoingMessage({
        t: "buf",
        p: this._impl,
        d: msg
      }, [msg]);
    }
    this.pendingMessages = [];
    this.cleanOldFrames();
  }
  cleanOldFrames() {
    var _a, _b;
    let currentToken = this._client.pipeline_camera_frame_user_data(this._impl);
    if (!currentToken)
      return;
    for (let t of this.cameraTokens) {
      if (t[0] < currentToken) {
        if (t[1].texture)
          this.videoTextures.push(t[1].texture);
        (_b = (_a = t[1].frame) === null || _a === void 0 ? void 0 : _a.close) === null || _b === void 0 ? void 0 : _b.call(_a);
        this.cameraTokens.delete(t[0]);
      }
    }
  }
  cameraTokenReturn(msg) {
    if (this._sequenceRecorder && this._sequenceRecordDeviceAttitudeMatrices && msg.token >= this._sequenceRecorderFirstCameraToken) {
      let info = this.cameraTokens.get(msg.token);
      if (info) {
        if (msg.att)
          this._sequenceRecorder.appendAttitudeMatrix(msg.att);
        info.data = msg.d;
        this._sequenceRecorder.appendCameraFrame(info);
      }
    }
    this.cameraPixelArrays.push(msg.d);
    this.tokensInFlight--;
  }
  sequenceRecordStart(expectedFrames) {
    if (!this._sequenceRecorder)
      this._sequenceRecorder = new SequenceRecorder(expectedFrames);
    this._sequenceRecorder.start();
    this._sequenceRecorderFirstCameraToken = this.nextCameraToken;
  }
  sequenceRecordStop() {
    var _a;
    (_a = this._sequenceRecorder) === null || _a === void 0 ? void 0 : _a.stop();
  }
  sequenceRecordData() {
    var _a;
    return ((_a = this._sequenceRecorder) === null || _a === void 0 ? void 0 : _a.data()) || new Uint8Array(0);
  }
  sequenceRecordClear() {
    delete this._sequenceRecorder;
  }
  sequenceRecordDeviceAttitudeMatrices(v) {
    this._sequenceRecordDeviceAttitudeMatrices = v;
  }
  getVideoTexture() {
    return this.videoTextures.pop();
  }
  destroy() {
    this._client.pipeline_destroy(this._impl);
    byId3.delete(this._impl);
  }
  getCurrentCameraInfo() {
    let currentToken = this._client.pipeline_camera_frame_user_data(this._impl);
    if (!currentToken)
      return void 0;
    return this.cameraTokens.get(currentToken);
  }
  cameraFrameDrawGL(screenWidth, screenHeight, mirror) {
    if (!this.glContext)
      return;
    let token = this.getCurrentCameraInfo();
    if (!token)
      return;
    if (!this._cameraDraw)
      this._cameraDraw = new CameraDraw(this.glContext);
    this._cameraDraw.drawCameraFrame(screenWidth, screenHeight, token, mirror === true);
  }
  glContextLost() {
    if (this._cameraDraw)
      this._cameraDraw.dispose();
    if (this._faceDraw)
      this._faceDraw.dispose();
    if (this._imageTargetPreviewDraw)
      this._imageTargetPreviewDraw.dispose();
    if (this._faceProjectDraw)
      this._faceProjectDraw.dispose();
    delete this._cameraDraw;
    delete this._faceDraw;
    delete this._imageTargetPreviewDraw;
    delete this._faceProjectDraw;
    disposeDrawPlane();
    this.onGLContextReset.emit();
    for (let tex of this.videoTextures) {
      if (this.glContext)
        this.glContext.deleteTexture(tex);
    }
    this.videoTextures = [];
    for (let info of this.cameraTokens) {
      if (this.glContext && info[1].texture)
        this.glContext.deleteTexture(info[1].texture);
      info[1].texture = void 0;
    }
    this.glContext = void 0;
  }
  glContextSet(gl, texturePool) {
    this.glContextLost();
    this.glContext = gl;
    texturePool = texturePool || [];
    for (let i = 0; i < 4; i++) {
      let tex = texturePool[i] || gl.createTexture();
      if (tex) {
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        this.videoTextures.push(tex);
      }
    }
    gl.bindTexture(gl.TEXTURE_2D, null);
  }
  drawFace(projectionMatrix2, cameraMatrix, targetMatrix, o) {
    if (!this.glContext)
      return;
    if (!this._faceDraw)
      this._faceDraw = new FaceDraw(this.glContext);
    let mat = mat4_exports.create();
    mat4_exports.multiply(mat, projectionMatrix2, cameraMatrix);
    mat4_exports.multiply(mat, mat, targetMatrix);
    this._faceDraw.drawFace(mat, o);
  }
  drawImageTargetPreview(projectionMatrix2, cameraMatrix, targetMatrix, indx, o) {
    if (!this.glContext)
      return;
    if (!this._imageTargetPreviewDraw)
      this._imageTargetPreviewDraw = new PreviewMeshDraw(this.glContext);
    let mat = mat4_exports.create();
    mat4_exports.multiply(mat, projectionMatrix2, cameraMatrix);
    mat4_exports.multiply(mat, mat, targetMatrix);
    this._imageTargetPreviewDraw.draw(mat, o, indx);
  }
  drawFaceProject(matrix, vertices, uvMatrix, uvs, indices, texture) {
    if (!this.glContext)
      return;
    if (!this._faceProjectDraw)
      this._faceProjectDraw = new FaceDrawProject(this.glContext);
    this._faceProjectDraw.drawFace(matrix, vertices, uvMatrix, uvs, indices, texture);
  }
  cameraFrameTexture() {
    var _a;
    return (_a = this.getCurrentCameraInfo()) === null || _a === void 0 ? void 0 : _a.texture;
  }
  cameraFrameTextureMatrix(sw, sh, mirror) {
    let info = this.getCurrentCameraInfo();
    if (!info)
      return mat4_exports.create();
    return cameraFrameTextureMatrix(info.dataWidth, info.dataHeight, sw, sh, info.uvTransform || identity3, mirror);
  }
  cameraFrameUserFacing() {
    var _a;
    return ((_a = this.getCurrentCameraInfo()) === null || _a === void 0 ? void 0 : _a.userFacing) || false;
  }
  cameraPoseWithAttitude(mirror) {
    let res = applyScreenCounterRotation(this.getCurrentCameraInfo(), this._client.pipeline_camera_frame_camera_attitude(this._impl));
    if (mirror) {
      let scale5 = mat4_exports.create();
      mat4_exports.fromScaling(scale5, [-1, 1, 1]);
      mat4_exports.multiply(res, scale5, res);
      mat4_exports.multiply(res, res, scale5);
    }
    mat4_exports.invert(res, res);
    return res;
  }
  videoFrameFromWorker(msg) {
    let tokenId = this.nextCameraToken++;
    const cameraSource = getCameraSource(msg.source);
    if (!cameraSource)
      return;
    this.cameraTokens.set(tokenId, {
      dataWidth: msg.w,
      dataHeight: msg.h,
      texture: void 0,
      frame: msg.d,
      userFacing: msg.userFacing,
      uvTransform: msg.uvTransform,
      cameraModel: msg.cameraModel,
      cameraToDevice: msg.cameraToDevice,
      cameraSource
    });
    this.cleanOldFrames();
  }
  imageBitmapFromWorker(msg) {
    let data = this.cameraTokens.get(msg.tokenId);
    if (!data)
      return;
    data.dataWidth = msg.dataWidth;
    data.dataHeight = msg.dataHeight;
    data.frame = msg.frame;
    data.userFacing = msg.userFacing;
    data.uvTransform = msg.uvTransform;
    this.tokensInFlight--;
    this.cleanOldFrames();
  }
  uploadGL() {
    var _a, _b;
    let info = this.getCurrentCameraInfo();
    (_b = (_a = info === null || info === void 0 ? void 0 : info.cameraSource) === null || _a === void 0 ? void 0 : _a.uploadGL) === null || _b === void 0 ? void 0 : _b.call(_a, info);
  }
  registerToken(info) {
    let tokenId = this.nextCameraToken++;
    this.cameraTokens.set(tokenId, info);
    this.tokensInFlight++;
    return tokenId;
  }
  processGL() {
    if (!this.glContext) {
      zcerr("no GL context for camera frames - please call pipeline_gl_context_set");
      return;
    }
    if (!this.currentCameraSource)
      return;
    if (this.tokensInFlight > 0) {
      this.currentCameraSource.getFrame(true);
      return;
    }
    this.currentCameraSource.getFrame(false);
  }
  motionAccelerometerSubmit(timestamp, x, y, z2) {
    var _a;
    if (!this._sequenceRecordDeviceAttitudeMatrices)
      (_a = this._sequenceRecorder) === null || _a === void 0 ? void 0 : _a.appendAccelerometer(timestamp, x, y, z2);
    this._client.pipeline_motion_accelerometer_submit(this._impl, timestamp, x, y, z2);
  }
  motionRotationRateSubmit(timestamp, x, y, z2) {
    var _a;
    if (!this._sequenceRecordDeviceAttitudeMatrices)
      (_a = this._sequenceRecorder) === null || _a === void 0 ? void 0 : _a.appendRotationRate(timestamp, x, y, z2);
    this._client.pipeline_motion_rotation_rate_submit(this._impl, timestamp, x, y, z2);
  }
  motionAttitudeSubmit(timestamp, x, y, z2) {
    var _a;
    if (!this._sequenceRecordDeviceAttitudeMatrices)
      (_a = this._sequenceRecorder) === null || _a === void 0 ? void 0 : _a.appendAttitude(timestamp, x, y, z2);
    this._client.pipeline_motion_attitude_submit(this._impl, timestamp, x, y, z2);
  }
  motionAttitudeMatrix(m) {
    this._client.pipeline_motion_attitude_matrix_submit(this._impl, m);
  }
  sendCameraStreamToWorker(source, stream, userFacing) {
    let msg = {
      t: "streamC2S",
      p: this._impl,
      s: stream,
      userFacing,
      source
    };
    this._mgr.postOutgoingMessage(msg, [msg.s]);
  }
  sendCameraToScreenRotationToWorker(rot) {
    let msg = {
      p: this._impl,
      t: "cameraToScreenC2S",
      r: rot
    };
    this._mgr.postOutgoingMessage(msg, []);
  }
  sendImageBitmapToWorker(img, rot, userFacing, tokenId, cameraModel, cameraToDevice) {
    let msg = {
      p: this._impl,
      t: "imageBitmapC2S",
      i: img,
      r: rot,
      tokenId,
      userFacing,
      cameraModel,
      cameraToDevice
    };
    this._mgr.postOutgoingMessage(msg, [img]);
  }
  sendDataToWorker(data, token, width, height, userFacing, cameraToDevice, cameraModel) {
    let msg = {
      d: data,
      p: this._impl,
      width,
      height,
      token,
      userFacing,
      c2d: cameraToDevice,
      cm: cameraModel,
      t: "cameraFrameC2S"
    };
    this._mgr.postOutgoingMessage(msg, [data]);
  }
};
function applyScreenCounterRotation(info, inp) {
  let userFacing = false;
  userFacing = info ? info.userFacing : false;
  let mult = mat4_exports.create();
  mat4_exports.fromRotation(mult, cameraRotationForScreenOrientation(userFacing) * Math.PI / 180, [0, 0, 1]);
  mat4_exports.multiply(mult, mult, inp);
  return mult;
}

// node_modules/@zappar/zappar-cv/lib/facelandmarkdata.js
var landmarkData = { 0: [{ mean: [0.235, 0.2344, 0.7305], identity: [8e-3, 87e-4, 24e-4, -26e-4, 6e-4, -22e-4, 5e-4, 33e-4, 26e-4, 17e-4, -55e-4, -8e-4, 11e-4, 59e-4, 0, 2e-4, 1e-3, -1e-3, -44e-4, -11e-4, -1e-4, 24e-4, 19e-4, -9e-4, 4e-4, -15e-4, 0, 38e-4, 13e-4, 3e-4, 2e-3, -21e-4, 18e-4, 23e-4, 11e-4, 12e-4, -11e-4, -17e-4, 9e-4, -12e-4, -8e-4, 7e-4, -17e-4, 29e-4, -29e-4, 8e-4, -27e-4, 8e-4, -17e-4, 4e-4, 9e-4, -1e-3, -3e-4, 8e-4, -16e-4, -3e-4, -7e-4, 16e-4, -9e-4, 21e-4, -5e-4, 11e-4, -24e-4, -1e-4, 6e-4, 1e-4, -26e-4, -4e-4, -3e-4, -9e-4, 5e-4, 3e-4, -8e-4, -1e-3, -4e-4, -8e-4, 22e-4, -14e-4, -1e-4, -23e-4, 0, -18e-4, 7e-4, -36e-4, 17e-4, 17e-4, -18e-4, -2e-4, -4e-4, -9e-4, -8e-4, 3e-4, 12e-4, 9e-4, -4e-4, -16e-4, 5e-4, -13e-4, 11e-4, 23e-4, 29e-4, 24e-4, 17e-4, -27e-4, -4e-4, -1e-3, -18e-4, -15e-4, -1e-3, 1e-3, -13e-4, -1e-4, -2e-4, 7e-4, 3e-4, 3e-4, -16e-4, 9e-4, -21e-4, 4e-4, 14e-4, 2e-3, -7e-4, -4e-4, 2e-4, -4e-4, -6e-4, -9e-4, 15e-4, 4e-4, -4e-4, 5e-4, -15e-4, 9e-4, 3e-4, 3e-4, -2e-4, -8e-4, -9e-4, 23e-4, 4e-4, 1e-4, -4e-4, -1e-4, 7e-4, 2e-4, 1e-3, 1e-4, -29e-4, -5e-4], expression: [0, 3e-4, 52e-4, -7e-4, -51e-4, -0.0103, 0, 19e-4, 27e-4, -54e-4, 0.0135, 0.035, -5e-4, -6e-4, 25e-4, -45e-4, -0.0557, -3e-3, -0.0191, -0.1199, 0.0548, -36e-4, -0.0682, -0.0167, 2e-4, -85e-4, -85e-4, 44e-4, 41e-4, -0.0568, 44e-4, 0.179, 65e-4, -17e-4, -0.1006, 36e-4, -0.0267, -0.3279, 0.0301, -11e-4, -0.0173, -1e-3, 46e-4, 0.2808, 0.0207, 0.0162, 0.238, -0.0225, 17e-4, 0.1041, 0.0203, 5e-4, 0.0161, 31e-4, -0.0436, 0.6504, 0.0873, -99e-4, 0.1039, 48e-4, -0.0254, 0.2534, -42e-4, 3e-3, -0.0106, -0.0153, -0.0118, 0.0252, 9e-4, -71e-4, 99e-4, 7e-3, -0.0724, 0.0461, -0.0235, 0.0833, 4e-3, 0.0141, -0.0219, 0.0132, -42e-4, -0.0179, 45e-4, -0.0215, 0.3638, 54e-4, -0.0445] }, { mean: [0.2358, 0.1466, 0.7183], identity: [77e-4, 93e-4, 1e-4, -22e-4, 0, -41e-4, 5e-4, 22e-4, 28e-4, 18e-4, -38e-4, -13e-4, 1e-3, 44e-4, -2e-4, 0, 17e-4, -16e-4, -43e-4, -2e-4, -1e-4, 23e-4, 9e-4, 5e-4, -7e-4, -4e-4, -17e-4, 3e-3, 7e-4, 6e-4, 11e-4, -18e-4, 5e-4, 18e-4, -8e-4, 4e-4, -23e-4, -6e-4, -3e-4, -15e-4, -14e-4, -1e-4, -18e-4, 27e-4, -26e-4, 3e-4, -31e-4, 11e-4, -26e-4, -11e-4, 12e-4, -13e-4, -2e-4, 7e-4, -21e-4, 21e-4, 4e-4, 12e-4, -1e-3, 2e-3, -3e-4, 2e-4, -26e-4, -3e-4, 1e-3, 1e-4, -18e-4, -1e-3, 9e-4, -11e-4, 1e-3, 4e-4, -8e-4, -7e-4, -1e-3, -3e-4, 7e-4, -5e-4, -6e-4, -19e-4, -5e-4, -2e-3, 7e-4, -27e-4, 14e-4, 13e-4, 6e-4, -5e-4, -3e-4, -3e-4, -1e-3, 0, 19e-4, 1e-4, 6e-4, -12e-4, 4e-4, -9e-4, 4e-4, 25e-4, 3e-4, 24e-4, 17e-4, -9e-4, -15e-4, -15e-4, -1e-3, -23e-4, -1e-3, -5e-4, -4e-4, 8e-4, 9e-4, 7e-4, 2e-4, 7e-4, -9e-4, 9e-4, -13e-4, 1e-4, 9e-4, 2e-4, 6e-4, -6e-4, -8e-4, -4e-4, -7e-4, 8e-4, 19e-4, 3e-4, 15e-4, 2e-4, -15e-4, -3e-4, 0, 6e-4, 3e-4, 6e-4, -6e-4, 2e-4, 5e-4, -4e-4, 12e-4, -4e-4, 2e-4, -8e-4, 6e-4, -4e-4, 2e-4, -21e-4], expression: [-34e-4, 54e-4, 69e-4, 4e-3, 6e-4, -0.0104, -3e-4, 36e-4, 25e-4, 65e-4, 0.0296, 0.0208, -9e-4, 0.0154, 29e-4, -0.0167, 0.0124, 4e-3, -0.0102, 0.0351, 0.028, -0.019, 0.0146, -35e-4, -23e-4, -69e-4, -51e-4, -0.01, 0.0262, -0.028, 0.0112, 0.082, 0.023, -19e-4, -0.066, -0.0104, -0.0408, 0.0164, 75e-4, -74e-4, 0.0367, 41e-4, 0.0517, -0.0207, 45e-4, 0.0291, -0.0672, -0.0129, 0.0345, -0.1558, -0.0106, 37e-4, -0.0437, -21e-4, 0.0854, -0.1121, 0.0187, 41e-4, 72e-4, 11e-4, 0.0193, -0.0143, -0.0119, 5e-3, -0.02, -0.0122, -8e-3, 0.0527, 36e-4, -6e-3, 0.0222, 7e-3, -0.0429, 0.046, -46e-4, 0.0226, -59e-4, 0.0202, -0.0173, 87e-4, 0, -67e-4, -95e-4, -0.0153, 0.1506, -17e-4, 21e-4] }], 1: [{ mean: [-0.2271, 0.2323, 0.7319], identity: [-84e-4, 97e-4, 18e-4, 41e-4, 2e-4, -2e-3, -12e-4, 36e-4, 19e-4, -9e-4, -63e-4, -1e-3, -3e-4, 53e-4, 6e-4, 1e-4, 5e-4, -15e-4, 44e-4, -25e-4, -15e-4, -2e-3, 16e-4, -6e-4, 2e-4, -13e-4, 0, -22e-4, 2e-4, 2e-4, -25e-4, -14e-4, 15e-4, 8e-4, 2e-4, 12e-4, 6e-4, -6e-4, 17e-4, 0, 3e-4, -1e-4, 24e-4, 25e-4, -29e-4, -15e-4, -15e-4, 1e-4, 31e-4, -16e-4, 7e-4, 19e-4, 6e-4, 2e-3, 9e-4, 1e-3, -14e-4, -2e-3, -15e-4, 29e-4, 1e-4, 5e-4, -23e-4, 8e-4, -11e-4, 19e-4, 17e-4, -3e-4, -11e-4, -3e-4, 11e-4, -8e-4, 19e-4, -22e-4, 1e-4, 15e-4, 17e-4, -8e-4, -11e-4, -22e-4, 3e-4, 22e-4, 6e-4, -3e-3, -2e-4, 0, -17e-4, -2e-4, 0, 1e-4, 4e-4, 12e-4, 19e-4, -14e-4, 4e-4, -17e-4, -12e-4, -11e-4, 21e-4, -29e-4, 26e-4, 18e-4, -23e-4, -29e-4, 1e-4, 14e-4, -19e-4, -4e-4, -4e-4, 23e-4, -16e-4, 0, -9e-4, 14e-4, -15e-4, 15e-4, -16e-4, -11e-4, -22e-4, 1e-4, -18e-4, 27e-4, -13e-4, 4e-4, -1e-4, -5e-4, 11e-4, -2e-4, 15e-4, 5e-4, -9e-4, -1e-4, 29e-4, 6e-4, 0, -3e-4, 7e-4, -8e-4, -5e-4, 25e-4, 3e-4, 2e-4, -8e-4, -1e-4, 3e-4, 0, 14e-4, 2e-4, -24e-4, 1e-4], expression: [-25e-4, -9e-4, 6e-3, 4e-3, -27e-4, -0.0113, -8e-4, 1e-3, 31e-4, -16e-4, 0.0144, 0.0382, -3e-4, -5e-4, 35e-4, -44e-4, -0.0511, -14e-4, -7e-4, -0.1007, 0.0582, -6e-4, -0.0606, -0.0165, 5e-4, -87e-4, -93e-4, 36e-4, 57e-4, -0.0576, -39e-4, 0.1488, 0.0127, 16e-4, -0.0666, -9e-4, -0.0153, 0.3162, -0.0445, -21e-4, 23e-4, 43e-4, -33e-4, 0.2382, 63e-4, -0.0217, 0.167, -0.039, 97e-4, -0.1144, -0.0189, -0.0145, 0.6831, 0.0632, -12e-4, -0.1959, -0.0133, 4e-4, 0.1108, -3e-4, 62e-4, 0.2593, -0.0161, -18e-4, -51e-4, -0.012, 0.0162, 0.016, -22e-4, -52e-4, -0.0201, 0.0101, 0.0115, 0.0365, -0.024, -59e-4, 0.0188, -0.0336, 0.0352, 0.0224, -0.0229, 0.0146, 86e-4, -0.0273, -32e-4, 0.0103, -0.0112] }, { mean: [-0.2288, 0.1541, 0.7202], identity: [-82e-4, 0.0101, 2e-4, 36e-4, -7e-4, -37e-4, -8e-4, 24e-4, 22e-4, -13e-4, -45e-4, -13e-4, -6e-4, 45e-4, -4e-4, 4e-4, 12e-4, -14e-4, 42e-4, -1e-3, -7e-4, -19e-4, 3e-4, -2e-4, 12e-4, -4e-4, -12e-4, -18e-4, -4e-4, -1e-4, -14e-4, -12e-4, 1e-4, 1e-4, -17e-4, 1e-3, 15e-4, -1e-4, 6e-4, 1e-4, 0, -6e-4, 28e-4, 21e-4, -25e-4, -2e-3, -15e-4, 7e-4, 28e-4, -23e-4, 9e-4, 13e-4, 1e-4, 16e-4, 12e-4, 32e-4, -6e-4, -13e-4, -11e-4, 21e-4, 3e-4, -5e-4, -24e-4, 4e-4, -4e-4, 14e-4, 15e-4, -8e-4, -3e-4, 3e-4, 17e-4, -6e-4, 2e-3, -18e-4, -3e-4, 9e-4, 1e-4, 2e-4, -6e-4, -15e-4, -4e-4, 22e-4, 7e-4, -23e-4, 0, -2e-4, -2e-4, -3e-4, -1e-4, 6e-4, -2e-4, 6e-4, 22e-4, -3e-4, 13e-4, -14e-4, -5e-4, -3e-4, 13e-4, -27e-4, 6e-4, 25e-4, -23e-4, -8e-4, -13e-4, 17e-4, -9e-4, -19e-4, 1e-4, 8e-4, -7e-4, -4e-4, 0, 1e-3, -1e-3, 19e-4, -8e-4, -15e-4, -6e-4, -2e-4, -11e-4, 8e-4, 1e-4, 9e-4, -8e-4, -4e-4, 6e-4, 7e-4, 21e-4, -4e-4, 7e-4, -5e-4, 21e-4, -7e-4, -4e-4, -9e-4, 8e-4, 3e-4, 1e-4, 3e-4, 1e-4, 9e-4, 1e-3, -5e-4, 5e-4, -1e-3, 1e-3, 4e-4, -5e-4, -12e-4], expression: [8e-4, 37e-4, 78e-4, -4e-4, 5e-4, -0.012, -2e-4, -46e-4, 33e-4, -89e-4, 0.0295, 0.0221, -24e-4, -84e-4, 13e-4, 57e-4, 0.0125, 49e-4, -36e-4, 0.0373, 0.0285, 0.0115, 0.0135, -35e-4, 48e-4, 0.0108, -33e-4, 0.0106, 0.0281, -0.0301, -82e-4, 0.0803, 0.0244, -7e-4, -0.0725, -0.0105, -0.0247, -36e-4, -0.0143, -45e-4, -0.029, 2e-4, -0.0303, 93e-4, -21e-4, -0.0196, -0.0754, -0.0211, 0.0326, 0.1246, 6e-3, -0.0804, -0.1499, 0.0109, 0.0182, -29e-4, -14e-4, -35e-4, 72e-4, -8e-4, -0.0152, -0.0108, -0.0166, -73e-4, -0.0144, -95e-4, 0.0101, 0.047, -18e-4, -4e-3, -0.0189, 27e-4, 0.0104, 0.0298, -42e-4, -96e-4, 0.0191, -0.0217, 0.0228, 0.0226, -0.0105, 47e-4, -48e-4, -0.0172, 61e-4, -43e-4, -16e-4] }], 2: { mean: [0.5396, 0.2028, 0.2496], identity: [0.0204, 0.0146, -0.0182, -52e-4, 0.0158, -38e-4, -25e-4, -0.0108, -6e-3, 85e-4, -44e-4, 29e-4, 42e-4, 1e-3, 95e-4, 15e-4, -34e-4, -64e-4, -57e-4, 7e-4, 26e-4, 7e-4, 37e-4, -6e-4, 37e-4, 26e-4, 24e-4, 5e-4, -19e-4, -13e-4, 3e-3, -28e-4, 18e-4, -9e-4, 2e-3, -47e-4, 4e-3, -3e-3, 31e-4, -27e-4, -26e-4, -17e-4, 16e-4, 14e-4, -4e-4, 21e-4, -2e-3, 0, 17e-4, 7e-4, -4e-4, -7e-4, -18e-4, -9e-4, 2e-4, -12e-4, 1e-4, -5e-4, -11e-4, 4e-4, 2e-4, 11e-4, 1e-4, 8e-4, 17e-4, -13e-4, 25e-4, 17e-4, 1e-3, 2e-4, 3e-4, 5e-4, -4e-4, -1e-4, -5e-4, 7e-4, -22e-4, -29e-4, 6e-4, -8e-4, -6e-4, 6e-4, -5e-4, 5e-4, 13e-4, 3e-4, -5e-4, -3e-3, 7e-4, 2e-4, 16e-4, -4e-4, 0, 0, 4e-4, 1e-4, 14e-4, 12e-4, 1e-4, 4e-4, -1e-4, 8e-4, 9e-4, 4e-4, -4e-4, 9e-4, -2e-4, 1e-3, 9e-4, 4e-4, 1e-4, 7e-4, 7e-4, 1e-3, -17e-4, -8e-4, 2e-4, 17e-4, -3e-4, -1e-4, 4e-4, 5e-4, 7e-4, 5e-4, -1e-4, -6e-4, -1e-4, 1e-4, -3e-4, -7e-4, -2e-4, -5e-4, 0, -3e-4, 3e-4, 8e-4, -2e-4, -3e-4, 5e-4, 1e-4, -7e-4, -1e-3, -2e-4, 3e-4, 4e-4, -1e-4, 7e-4, 0, 4e-4, 4e-4], expression: [1e-4, -4e-4, 1e-4, 0, 5e-4, 2e-4, 0, 0, 3e-4, -2e-4, 3e-4, 5e-4, -1e-4, 2e-4, 8e-4, 1e-4, -2e-4, -5e-4, -3e-4, 6e-4, 5e-4, 0, 1e-4, 2e-4, 1e-4, -1e-4, -6e-4, -2e-4, 5e-4, 0, -4e-4, 4e-4, 16e-4, 4e-4, -4e-4, -15e-4, 0, 1e-4, 1e-4, -3e-4, 3e-4, 19e-4, -2e-4, 7e-4, 4e-4, 4e-4, -8e-4, -15e-4, 13e-4, -16e-4, -69e-4, 4e-4, -6e-4, -19e-4, 0, -1e-4, 5e-4, -3e-4, 2e-4, 14e-4, -3e-4, 6e-4, 11e-4, 4e-4, -3e-4, -32e-4, -6e-4, 8e-4, 25e-4, -3e-4, 3e-4, 15e-4, -1e-4, 1e-4, 3e-4, -1e-4, 0, 0, -3e-4, 4e-4, 19e-4, 1e-4, 0, -8e-4, -1e-4, 1e-4, 5e-4] }, 3: { mean: [-0.5464, 0.2141, 0.26], identity: [-0.0207, 0.0172, -0.0176, 68e-4, 0.0148, -51e-4, 42e-4, -0.0101, -58e-4, -87e-4, -59e-4, 45e-4, -56e-4, 17e-4, 97e-4, -48e-4, -4e-3, -44e-4, 19e-4, 2e-4, 41e-4, -52e-4, 41e-4, 2e-4, -27e-4, 6e-4, 2e-3, -27e-4, -33e-4, -6e-4, -4e-3, 9e-4, -12e-4, -1e-4, -26e-4, 21e-4, -3e-3, -25e-4, 52e-4, 25e-4, 22e-4, -1e-4, -8e-4, 13e-4, 1e-3, 4e-4, 18e-4, 14e-4, 6e-4, -5e-4, -15e-4, -39e-4, 14e-4, -1e-4, 8e-4, -2e-4, 6e-4, -5e-4, -38e-4, -12e-4, -18e-4, -3e-4, 1e-3, 9e-4, 12e-4, 24e-4, -24e-4, -7e-4, -16e-4, -16e-4, 3e-4, -1e-3, -14e-4, -14e-4, 1e-3, -3e-4, -7e-4, -12e-4, 3e-4, 6e-4, 3e-4, -5e-4, 3e-4, 12e-4, 6e-4, -8e-4, 4e-4, 4e-4, 8e-4, -2e-4, -14e-4, 3e-4, 0, 23e-4, -3e-4, -12e-4, -13e-4, 11e-4, -2e-4, -14e-4, -1e-4, 14e-4, 0, 3e-4, 3e-4, -8e-4, -5e-4, -7e-4, -7e-4, -2e-4, 3e-4, 5e-4, 2e-4, -1e-4, 11e-4, -14e-4, 1e-4, -15e-4, -1e-4, -3e-4, 0, -1e-3, -1e-4, -8e-4, 8e-4, -8e-4, -2e-4, -11e-4, -3e-4, -4e-4, 1e-4, -2e-4, 3e-4, -7e-4, 0, 3e-4, 1e-4, -8e-4, 5e-4, 1e-4, 4e-4, 14e-4, -6e-4, -1e-3, -3e-4, -2e-4, 1e-4, -1e-4, -1e-4, 7e-4], expression: [-3e-4, -1e-4, 6e-4, 4e-4, 0, -7e-4, 0, -3e-4, -2e-4, -4e-4, 12e-4, 8e-4, 1e-4, -5e-4, -7e-4, -4e-4, 0, 1e-4, -4e-4, 17e-4, 7e-4, 0, 1e-4, 3e-4, 0, 4e-4, 4e-4, 5e-4, 1e-4, -1e-3, -7e-4, 22e-4, 26e-4, 5e-4, -24e-4, -23e-4, 0, 1e-4, 3e-4, 0, -13e-4, -15e-4, 6e-4, 14e-4, 8e-4, -2e-4, -25e-4, -23e-4, -3e-4, 49e-4, 6e-3, -2e-4, -7e-4, -2e-4, 0, -19e-4, -18e-4, -2e-4, 17e-4, 17e-4, 3e-4, 15e-4, 7e-4, 1e-4, -23e-4, -36e-4, 2e-4, 23e-4, 17e-4, 0, -5e-4, -3e-4, -3e-4, 4e-4, 2e-4, -1e-4, -3e-4, -5e-4, 1e-4, 18e-4, 25e-4, 1e-4, -6e-4, -11e-4, 0, 1e-4, 1e-4] }, 4: { mean: [18e-4, 0.1864, 0.853], identity: [-11e-4, 0.0134, 85e-4, 9e-4, -25e-4, -7e-4, -3e-4, 33e-4, 4e-4, -5e-4, -47e-4, -2e-3, 7e-4, 26e-4, -69e-4, -1e-4, 36e-4, 72e-4, 5e-4, -8e-4, -47e-4, 4e-4, -8e-4, -1e-3, 0, 2e-4, -36e-4, -2e-4, -1e-3, -48e-4, -1e-4, 18e-4, 44e-4, -7e-4, -2e-4, 43e-4, 3e-4, 2e-3, -31e-4, 0, -7e-4, 13e-4, 0, 37e-4, 33e-4, -16e-4, -12e-4, 2e-3, -1e-4, -27e-4, 51e-4, 5e-4, 8e-4, 7e-4, -17e-4, 54e-4, 23e-4, -3e-4, 32e-4, 1e-4, 0, 7e-4, -5e-4, -11e-4, 2e-4, 8e-4, 0, -33e-4, -8e-4, -7e-4, 7e-4, 33e-4, 5e-4, -3e-4, 29e-4, -1e-4, -24e-4, -11e-4, -2e-3, -15e-4, -19e-4, 2e-4, 7e-4, 31e-4, 6e-4, 12e-4, 0, 0, -21e-4, 0, -9e-4, -11e-4, -11e-4, -2e-4, 15e-4, 1e-3, 13e-4, 8e-4, 1e-3, -3e-4, 9e-4, 27e-4, -2e-4, -11e-4, -11e-4, 6e-4, 7e-4, 2e-4, 1e-4, -5e-4, -22e-4, 11e-4, -14e-4, 9e-4, 3e-4, 2e-4, 0, -6e-4, -4e-4, -11e-4, -7e-4, 1e-3, -12e-4, 6e-4, -12e-4, -15e-4, 3e-4, -9e-4, -13e-4, -13e-4, 7e-4, 1e-3, -11e-4, -13e-4, 15e-4, 4e-4, 1e-4, 4e-4, -1e-4, -16e-4, -16e-4, 9e-4, -7e-4, -24e-4, 5e-4, -1e-4, -17e-4, -2e-4, 3e-4, -9e-4], expression: [-17e-4, 19e-4, 97e-4, 3e-3, -0.0103, -93e-4, 9e-4, 6e-4, 23e-4, -17e-4, -0.0204, 0.0376, 33e-4, -34e-4, 33e-4, -26e-4, -0.0322, 0.0396, -32e-4, -0.0947, 0.0942, -7e-4, -0.0175, 0.0266, -1e-3, -6e-4, 16e-4, 25e-4, 0.0157, -0.0142, -22e-4, 0.037, 0.015, 21e-4, -0.0102, -0.0107, 36e-4, 55e-4, -51e-4, 21e-4, 3e-4, -3e-4, 4e-4, -0.0177, 74e-4, -6e-4, -0.0357, 0.0149, -66e-4, 9e-4, 13e-4, -31e-4, 16e-4, 95e-4, 2e-3, 52e-4, 35e-4, -3e-4, 53e-4, -82e-4, 2e-3, 22e-4, -71e-4, -11e-4, 5e-4, 55e-4, 11e-4, 3e-4, -0.0126, -4e-4, 3e-4, -23e-4, -15e-4, 59e-4, 63e-4, -42e-4, -23e-4, 55e-4, 19e-4, 17e-4, -75e-4, 6e-4, -8e-4, 18e-4, 12e-4, 12e-4, -5e-4] }, 5: { mean: [-2e-3, -0.0469, 1.0039], identity: [-17e-4, 18e-4, 0.0156, 6e-4, -38e-4, 5e-4, 4e-4, 13e-4, 2e-3, -4e-4, -15e-4, -51e-4, 5e-4, -7e-4, -55e-4, -1e-4, -9e-4, 8e-3, -2e-4, 36e-4, -53e-4, 4e-4, -26e-4, -16e-4, 7e-4, 9e-4, -9e-3, -3e-4, 7e-4, -84e-4, 15e-4, 21e-4, 32e-4, -15e-4, 18e-4, 46e-4, -3e-4, -4e-4, -1e-4, 8e-4, -44e-4, -7e-4, -8e-4, 7e-4, 48e-4, -24e-4, -3e-4, 24e-4, 2e-4, -51e-4, 58e-4, -6e-4, 28e-4, 18e-4, -21e-4, 35e-4, 57e-4, 11e-4, 65e-4, 0, -2e-4, 11e-4, 3e-3, -27e-4, 8e-4, 7e-4, 3e-4, -39e-4, -2e-3, -2e-4, -15e-4, 34e-4, 12e-4, -25e-4, 24e-4, -2e-4, 4e-4, -42e-4, -24e-4, -1e-3, -23e-4, 16e-4, -7e-4, 39e-4, 1e-4, -5e-4, 18e-4, 3e-4, -2e-4, -9e-4, -15e-4, 3e-4, -7e-4, -1e-4, -2e-4, 23e-4, 32e-4, 2e-3, -13e-4, 13e-4, -38e-4, 45e-4, 1e-4, -31e-4, 1e-4, 19e-4, -1e-4, 16e-4, 13e-4, 0, -2e-3, 23e-4, 2e-4, 11e-4, 18e-4, -24e-4, 6e-4, -17e-4, 2e-3, -8e-4, -21e-4, 7e-4, 11e-4, 8e-4, 4e-4, -1e-3, 12e-4, 2e-4, -6e-4, -27e-4, -5e-4, 1e-3, -9e-4, 1e-4, -1e-4, 8e-4, -11e-4, 22e-4, -1e-3, -5e-4, -11e-4, 16e-4, -15e-4, 8e-4, -3e-4, 9e-4, 13e-4, -7e-4, -7e-4, -2e-4], expression: [-18e-4, -0.0168, 88e-4, 0.0389, 0.1026, 0.0414, 0.2201, -0.0262, -16e-4, -17e-4, 0.0612, -0.0298, -0.0323, 93e-4, 13e-4, -5e-3, 0.2207, 0.1315, -4e-4, 0.0858, -0.0303, -0.0133, 0.015, -8e-3, 0.1454, 0.0114, 0.0177, -77e-4, 0.1022, 0.0356, -23e-4, 0.1088, 0.0232, 3e-3, -0.0706, 0.0347, -1e-4, 4e-3, -11e-4, 0.0397, -96e-4, -33e-4, 29e-4, -0.01, -83e-4, -6e-4, -0.0135, 16e-4, -87e-4, -19e-4, 22e-4, -4e-3, -87e-4, 0.0105, 8e-4, -5e-3, 69e-4, 28e-4, 0.0409, -0.0391, 3e-3, 0.0103, 51e-4, 26e-4, 0.0776, -83e-4, -62e-4, -0.0567, 0.0268, 0.0175, 17e-4, 0.0156, -43e-4, 0.0299, -0.0395, -15e-4, 51e-4, -0.0148, 0.0125, 35e-4, 0.0603, 0.0109, -0.0645, -0.0257, 2e-3, 6e-4, -8e-4] }, 6: { mean: [-6e-4, -0.1542, 0.8789], identity: [-7e-4, -32e-4, 0.01, 0, -27e-4, 31e-4, 6e-4, 5e-4, -6e-4, -3e-4, 13e-4, -49e-4, -2e-4, -2e-3, -46e-4, 8e-4, -11e-4, 54e-4, 2e-4, 43e-4, -27e-4, 3e-4, -22e-4, -19e-4, 8e-4, 32e-4, -69e-4, 0, 4e-4, -71e-4, 16e-4, 27e-4, 39e-4, -17e-4, 9e-4, 31e-4, -1e-4, -5e-4, -4e-4, 7e-4, -26e-4, -12e-4, -5e-4, 6e-4, 2e-4, -14e-4, -13e-4, 19e-4, -2e-4, -53e-4, 31e-4, -6e-4, 16e-4, 23e-4, -13e-4, 21e-4, 29e-4, 8e-4, 52e-4, 0, 4e-4, 0, 37e-4, -26e-4, 3e-4, 2e-3, -2e-4, -24e-4, 4e-4, -4e-4, -12e-4, 8e-4, 7e-4, -23e-4, 5e-4, 0, 14e-4, -22e-4, -16e-4, 0, -12e-4, 8e-4, -7e-4, 14e-4, -6e-4, -12e-4, -3e-4, 2e-4, 12e-4, -3e-4, -2e-3, -1e-4, 1e-4, -2e-4, -16e-4, 9e-4, 2e-3, 19e-4, 0, 6e-4, -22e-4, 16e-4, 1e-4, -17e-4, -13e-4, 1e-3, 9e-4, -1e-4, 11e-4, 3e-4, -7e-4, 14e-4, 8e-4, 13e-4, 11e-4, -2e-3, 0, -15e-4, 14e-4, 1e-3, -15e-4, 7e-4, 3e-4, 1e-3, -1e-4, 12e-4, 7e-4, 6e-4, -4e-4, -13e-4, -12e-4, -9e-4, -11e-4, 2e-4, -5e-4, 5e-4, 4e-4, 2e-4, 1e-4, 0, 5e-4, 5e-4, -14e-4, 15e-4, -9e-4, 5e-4, 14e-4, -8e-4, -8e-4, 12e-4], expression: [8e-4, 0.0481, 0.1653, 0.0784, 0.1008, -0.3992, 0.5088, -0.02, 0.0542, 1e-3, 0.3723, -0.0151, -0.0986, 0.0283, -33e-4, -0.0121, 0.2634, 0.1202, 36e-4, -0.0529, -0.0245, -0.0297, -0.1085, 0.0495, 0.3264, 83e-4, 4e-4, -0.0314, 0.1459, -0.1142, -3e-3, 1e-4, 0.1154, -35e-4, -0.0285, -0.0184, -1e-4, 12e-4, 35e-4, 0.079, -0.0103, 43e-4, 0.011, -4e-3, -0.0774, -47e-4, -0.023, 0.0284, -48e-4, -1e-3, 0.0149, -39e-4, 46e-4, 0.0528, -6e-4, 63e-4, 0.0376, 96e-4, 0.0558, -0.0295, 0, -0.0311, -0.0634, 62e-4, 0.0176, -0.0154, -0.0109, -0.1149, 0.0192, 0.0326, 0.0121, 0.0237, 34e-4, 0.0262, -0.0778, 14e-4, -45e-4, -0.0203, 77e-4, 0.0588, 0.0575, 8e-3, -0.0557, -95e-4, 32e-4, 54e-4, -42e-4] }, 7: { mean: [38e-4, -0.2927, 0.833], identity: [6e-4, -0.0109, 73e-4, -6e-4, -44e-4, 17e-4, -1e-4, -22e-4, -6e-4, -3e-4, 65e-4, -14e-4, -6e-4, -51e-4, -46e-4, 3e-4, -29e-4, 3e-3, 2e-4, 38e-4, -6e-4, 0, -12e-4, 6e-4, -4e-4, 53e-4, -75e-4, -2e-4, -7e-4, -63e-4, 14e-4, 26e-4, 19e-4, -22e-4, 18e-4, 28e-4, -1e-4, -12e-4, 11e-4, 9e-4, 19e-4, -19e-4, -1e-4, 12e-4, -22e-4, -3e-4, -12e-4, 4e-4, -8e-4, 3e-4, -3e-4, 0, 17e-4, 21e-4, -4e-4, 12e-4, 22e-4, -3e-4, 26e-4, -3e-4, 4e-4, -26e-4, 32e-4, -19e-4, 3e-4, 15e-4, 1e-4, -15e-4, 13e-4, -1e-4, 1e-4, -29e-4, 0, -2e-4, -28e-4, -7e-4, 19e-4, -3e-4, -2e-4, 12e-4, 9e-4, 4e-4, -1e-3, -2e-3, -16e-4, 11e-4, -1e-4, 3e-4, 21e-4, 2e-4, -14e-4, -9e-4, -1e-4, 0, -2e-4, -1e-3, 15e-4, 18e-4, 1e-4, 7e-4, 8e-4, 17e-4, 1e-3, -9e-4, 1e-4, 4e-4, 23e-4, -1e-4, 12e-4, 1e-4, -8e-4, 2e-4, 18e-4, 6e-4, 3e-4, 1e-4, 12e-4, -3e-4, 2e-3, -6e-4, 0, -1e-4, -22e-4, 4e-4, 5e-4, 11e-4, 2e-4, -13e-4, -23e-4, 6e-4, 6e-4, -5e-4, -5e-4, 9e-4, 2e-4, 2e-4, 11e-4, -3e-4, 11e-4, 15e-4, 11e-4, 3e-4, 2e-4, 8e-4, -4e-4, -8e-4, 3e-4, 0, 12e-4, -1e-4], expression: [0.026, 0.1107, 0.3257, 0.1917, 0.3206, -1.1348, 1.0791, -0.035, 0.1549, -0.0103, 0.6953, 1e-4, -0.3262, 0.068, 0.0219, -44e-4, 0.3643, 0.2178, 0.0168, -0.2478, -0.1321, -0.0414, -0.3782, -0.0617, 0.5088, -31e-4, -0.0311, -0.0497, 0.0948, -0.385, 0.0148, -0.2224, -0.1415, -74e-4, 0.0863, -0.203, 3e-4, -81e-4, 57e-4, 0.1164, -39e-4, 15e-4, -24e-4, 0.0505, 0.1532, 39e-4, -0.0148, -0.0753, 0.0163, 58e-4, -0.0339, 36e-4, 0.0252, -0.0569, -41e-4, 0.0163, -0.0361, 35e-4, -0.018, 0.1266, 0, -0.0163, -46e-4, 0.0133, -0.1656, 0.2134, 0.0191, 57e-4, 0.0734, 0.0681, 39e-4, -0.0144, 0.029, -0.074, -0.046, 0.0122, 72e-4, -0.0162, -0.0349, -0.1234, 0.0212, -0.0355, 0.0535, 0.1218, 43e-4, -0.024, 16e-4] }, 8: { mean: [-18e-4, -0.3037, 0.8491], identity: [2e-4, -0.0112, 77e-4, -4e-4, -44e-4, 24e-4, 1e-4, -21e-4, -4e-4, -4e-4, 66e-4, -2e-3, -4e-4, -52e-4, -44e-4, 3e-4, -32e-4, 39e-4, 4e-4, 42e-4, -3e-4, 2e-4, -12e-4, -2e-4, -2e-4, 52e-4, -83e-4, -1e-4, -8e-4, -56e-4, 17e-4, 24e-4, 19e-4, -23e-4, 2e-3, 27e-4, -2e-4, -13e-4, 2e-3, 9e-4, 17e-4, -28e-4, -2e-4, 12e-4, -26e-4, 0, -16e-4, 2e-4, -5e-4, 3e-4, -1e-3, -1e-4, 16e-4, 16e-4, -3e-4, 12e-4, 12e-4, -3e-4, 27e-4, -3e-4, 3e-4, -26e-4, 37e-4, -17e-4, 1e-4, 16e-4, 1e-4, -15e-4, 24e-4, 1e-4, 2e-4, -39e-4, 0, -3e-4, -33e-4, -6e-4, 17e-4, -4e-4, -4e-4, 12e-4, 18e-4, 2e-4, -12e-4, -2e-3, -17e-4, 13e-4, -1e-3, 3e-4, 21e-4, 4e-4, -12e-4, -6e-4, -2e-4, 0, -4e-4, -9e-4, 16e-4, 17e-4, 4e-4, 7e-4, 7e-4, 1e-3, 9e-4, -8e-4, 5e-4, 5e-4, 23e-4, 1e-3, 13e-4, 2e-4, -4e-4, 2e-4, 17e-4, 8e-4, 3e-4, -1e-4, 9e-4, -4e-4, 19e-4, -5e-4, 3e-4, 0, -25e-4, 3e-4, 3e-4, 11e-4, 1e-4, -15e-4, -1e-3, 7e-4, 7e-4, -7e-4, -7e-4, 8e-4, 0, 1e-4, 13e-4, -4e-4, 12e-4, 14e-4, 17e-4, 4e-4, 2e-4, 3e-4, -3e-4, -9e-4, 1e-4, 0, 1e-3, -4e-4], expression: [-92e-4, 2.8809, 1.416, 0.2018, 1.1982, -0.9351, 1.4492, -0.1902, 0.1749, 0.0305, -0.167, -0.1572, -0.7354, -0.0492, 0.0115, 0.0608, 0.2971, 0.1179, 46e-4, -0.0997, -41e-4, -0.0104, 0.3379, -0.1854, 9e-3, 0.0366, -0.0583, 0.0269, -29e-4, -0.4175, -8e-4, 0.1794, 0.0752, -0.0135, 0.1158, 0.1234, 5e-4, 3e-3, -32e-4, 0.1034, -0.0504, -55e-4, -76e-4, -0.0772, 0.224, 47e-4, 0.0229, -0.1044, 0.0162, -0.0161, -0.0241, -83e-4, -0.1388, -0.0434, -0.0125, -0.0997, -0.0327, -0.0111, 0.1576, -0.3911, 0.0199, 0.2522, 0.142, 59e-4, -0.0721, -45e-4, 0.031, -0.1136, -0.1685, 0.0641, 0.0142, 0.0312, 0.0426, -0.1366, 0.1011, 0.0101, -0.0157, 18e-4, -0.0103, -0.0344, 0.0907, 16e-4, 0.1168, -0.0806, 0.0104, -57e-4, 0.0111] }, 9: [{ mean: [38e-4, -0.2927, 0.833], identity: [6e-4, -0.0109, 73e-4, -6e-4, -44e-4, 17e-4, -1e-4, -22e-4, -6e-4, -3e-4, 65e-4, -14e-4, -6e-4, -51e-4, -46e-4, 3e-4, -29e-4, 3e-3, 2e-4, 38e-4, -6e-4, 0, -12e-4, 6e-4, -4e-4, 53e-4, -75e-4, -2e-4, -7e-4, -63e-4, 14e-4, 26e-4, 19e-4, -22e-4, 18e-4, 28e-4, -1e-4, -12e-4, 11e-4, 9e-4, 19e-4, -19e-4, -1e-4, 12e-4, -22e-4, -3e-4, -12e-4, 4e-4, -8e-4, 3e-4, -3e-4, 0, 17e-4, 21e-4, -4e-4, 12e-4, 22e-4, -3e-4, 26e-4, -3e-4, 4e-4, -26e-4, 32e-4, -19e-4, 3e-4, 15e-4, 1e-4, -15e-4, 13e-4, -1e-4, 1e-4, -29e-4, 0, -2e-4, -28e-4, -7e-4, 19e-4, -3e-4, -2e-4, 12e-4, 9e-4, 4e-4, -1e-3, -2e-3, -16e-4, 11e-4, -1e-4, 3e-4, 21e-4, 2e-4, -14e-4, -9e-4, -1e-4, 0, -2e-4, -1e-3, 15e-4, 18e-4, 1e-4, 7e-4, 8e-4, 17e-4, 1e-3, -9e-4, 1e-4, 4e-4, 23e-4, -1e-4, 12e-4, 1e-4, -8e-4, 2e-4, 18e-4, 6e-4, 3e-4, 1e-4, 12e-4, -3e-4, 2e-3, -6e-4, 0, -1e-4, -22e-4, 4e-4, 5e-4, 11e-4, 2e-4, -13e-4, -23e-4, 6e-4, 6e-4, -5e-4, -5e-4, 9e-4, 2e-4, 2e-4, 11e-4, -3e-4, 11e-4, 15e-4, 11e-4, 3e-4, 2e-4, 8e-4, -4e-4, -8e-4, 3e-4, 0, 12e-4, -1e-4], expression: [0.026, 0.1107, 0.3257, 0.1917, 0.3206, -1.1348, 1.0791, -0.035, 0.1549, -0.0103, 0.6953, 1e-4, -0.3262, 0.068, 0.0219, -44e-4, 0.3643, 0.2178, 0.0168, -0.2478, -0.1321, -0.0414, -0.3782, -0.0617, 0.5088, -31e-4, -0.0311, -0.0497, 0.0948, -0.385, 0.0148, -0.2224, -0.1415, -74e-4, 0.0863, -0.203, 3e-4, -81e-4, 57e-4, 0.1164, -39e-4, 15e-4, -24e-4, 0.0505, 0.1532, 39e-4, -0.0148, -0.0753, 0.0163, 58e-4, -0.0339, 36e-4, 0.0252, -0.0569, -41e-4, 0.0163, -0.0361, 35e-4, -0.018, 0.1266, 0, -0.0163, -46e-4, 0.0133, -0.1656, 0.2134, 0.0191, 57e-4, 0.0734, 0.0681, 39e-4, -0.0144, 0.029, -0.074, -0.046, 0.0122, 72e-4, -0.0162, -0.0349, -0.1234, 0.0212, -0.0355, 0.0535, 0.1218, 43e-4, -0.024, 16e-4] }, { mean: [-18e-4, -0.3037, 0.8491], identity: [2e-4, -0.0112, 77e-4, -4e-4, -44e-4, 24e-4, 1e-4, -21e-4, -4e-4, -4e-4, 66e-4, -2e-3, -4e-4, -52e-4, -44e-4, 3e-4, -32e-4, 39e-4, 4e-4, 42e-4, -3e-4, 2e-4, -12e-4, -2e-4, -2e-4, 52e-4, -83e-4, -1e-4, -8e-4, -56e-4, 17e-4, 24e-4, 19e-4, -23e-4, 2e-3, 27e-4, -2e-4, -13e-4, 2e-3, 9e-4, 17e-4, -28e-4, -2e-4, 12e-4, -26e-4, 0, -16e-4, 2e-4, -5e-4, 3e-4, -1e-3, -1e-4, 16e-4, 16e-4, -3e-4, 12e-4, 12e-4, -3e-4, 27e-4, -3e-4, 3e-4, -26e-4, 37e-4, -17e-4, 1e-4, 16e-4, 1e-4, -15e-4, 24e-4, 1e-4, 2e-4, -39e-4, 0, -3e-4, -33e-4, -6e-4, 17e-4, -4e-4, -4e-4, 12e-4, 18e-4, 2e-4, -12e-4, -2e-3, -17e-4, 13e-4, -1e-3, 3e-4, 21e-4, 4e-4, -12e-4, -6e-4, -2e-4, 0, -4e-4, -9e-4, 16e-4, 17e-4, 4e-4, 7e-4, 7e-4, 1e-3, 9e-4, -8e-4, 5e-4, 5e-4, 23e-4, 1e-3, 13e-4, 2e-4, -4e-4, 2e-4, 17e-4, 8e-4, 3e-4, -1e-4, 9e-4, -4e-4, 19e-4, -5e-4, 3e-4, 0, -25e-4, 3e-4, 3e-4, 11e-4, 1e-4, -15e-4, -1e-3, 7e-4, 7e-4, -7e-4, -7e-4, 8e-4, 0, 1e-4, 13e-4, -4e-4, 12e-4, 14e-4, 17e-4, 4e-4, 2e-4, 3e-4, -3e-4, -9e-4, 1e-4, 0, 1e-3, -4e-4], expression: [-92e-4, 2.8809, 1.416, 0.2018, 1.1982, -0.9351, 1.4492, -0.1902, 0.1749, 0.0305, -0.167, -0.1572, -0.7354, -0.0492, 0.0115, 0.0608, 0.2971, 0.1179, 46e-4, -0.0997, -41e-4, -0.0104, 0.3379, -0.1854, 9e-3, 0.0366, -0.0583, 0.0269, -29e-4, -0.4175, -8e-4, 0.1794, 0.0752, -0.0135, 0.1158, 0.1234, 5e-4, 3e-3, -32e-4, 0.1034, -0.0504, -55e-4, -76e-4, -0.0772, 0.224, 47e-4, 0.0229, -0.1044, 0.0162, -0.0161, -0.0241, -83e-4, -0.1388, -0.0434, -0.0125, -0.0997, -0.0327, -0.0111, 0.1576, -0.3911, 0.0199, 0.2522, 0.142, 59e-4, -0.0721, -45e-4, 0.031, -0.1136, -0.1685, 0.0641, 0.0142, 0.0312, 0.0426, -0.1366, 0.1011, 0.0101, -0.0157, 18e-4, -0.0103, -0.0344, 0.0907, 16e-4, 0.1168, -0.0806, 0.0104, -57e-4, 0.0111] }], 10: { mean: [-7e-3, -0.6338, 0.7695], identity: [1e-4, -0.0296, 89e-4, -6e-4, -73e-4, -65e-4, -1e-4, -29e-4, -31e-4, -2e-4, 0.0128, 65e-4, 0, -0.0116, -0.014, -1e-4, -37e-4, -52e-4, -5e-4, 28e-4, 3e-3, -4e-4, 41e-4, 15e-4, 6e-4, 88e-4, -76e-4, -11e-4, -15e-4, -73e-4, 7e-4, -11e-4, 19e-4, -11e-4, -5e-4, 31e-4, -1e-4, -18e-4, 9e-4, 18e-4, 38e-4, 68e-4, -4e-4, -1e-4, 61e-4, 24e-4, 24e-4, -66e-4, -6e-4, 51e-4, 14e-4, 2e-3, 5e-3, -35e-4, 1e-4, -34e-4, -4e-3, -7e-4, 1e-3, -8e-4, 1e-4, -5e-4, -21e-4, 2e-4, 45e-4, -43e-4, -12e-4, -24e-4, -14e-4, 6e-4, 34e-4, 27e-4, -8e-4, -53e-4, 14e-4, 1e-4, 13e-4, -18e-4, 6e-4, -15e-4, 29e-4, -2e-4, -35e-4, 1e-4, -2e-3, 12e-4, 48e-4, 11e-4, 1e-4, -2e-4, -3e-4, -12e-4, 33e-4, 6e-4, 2e-3, -33e-4, 4e-4, 28e-4, 2e-4, 8e-4, -1e-4, -18e-4, 8e-4, 17e-4, 1e-4, 9e-4, 8e-4, 3e-4, 19e-4, -1e-3, 1e-3, -7e-4, -13e-4, 0, 1e-4, 32e-4, -1e-4, 1e-4, 11e-4, -4e-4, 5e-4, -7e-4, 18e-4, -3e-4, 2e-4, 7e-4, 8e-4, -14e-4, 7e-4, 15e-4, -6e-4, -1e-4, -4e-4, 19e-4, -9e-4, -6e-4, -6e-4, -12e-4, 2e-4, -12e-4, -8e-4, 4e-4, 6e-4, -11e-4, 3e-4, 9e-4, -4e-4, 6e-4, -7e-4, -4e-4], expression: [-0.0603, 2.0527, 1.9014, 0.1025, 0.6143, 0.3804, 0.7881, -0.1023, -0.0764, 0.0454, -0.2487, -0.5073, -0.6704, -0.031, -0.0181, 0.0466, 0.0651, -0.0726, -33e-4, -22e-4, 0.2944, 0.0101, 0.1669, -0.5225, -0.4685, 0.0236, 79e-4, 0.011, 0.2173, 0.4529, 0.0121, -0.2104, -0.0673, 0.0225, -0.4023, 0.0317, -9e-4, 76e-4, -32e-4, 0.0333, 0.0523, 0.0129, -1e-3, -0.0319, -0.0139, 15e-4, -44e-4, 0.0247, -5e-4, 0.0161, 61e-4, 74e-4, 0.0776, -0.0176, 7e-3, 0.055, -0.017, 52e-4, -0.1819, 0.0294, -0.0161, -0.0337, 0.0226, -8e-3, -0.0297, 0.1967, -95e-4, 0.0383, 0.2039, 0.0434, 0.0271, -64e-4, -37e-4, -0.0294, -0.024, 24e-4, -0.0137, -0.0209, -31e-4, 0.0628, 0.1003, -0.0126, -0.056, -97e-4, -12e-4, -41e-4, 0.0162] }, 11: { mean: [0.2505, 0.3833, 0.7793], identity: [98e-4, 0.012, 77e-4, -6e-4, -3e-4, 0, 1e-4, 82e-4, -7e-4, 19e-4, -36e-4, -12e-4, 2e-4, 0.0119, -39e-4, 1e-3, 1e-4, 31e-4, -36e-4, -59e-4, -7e-4, 26e-4, 28e-4, -11e-4, 9e-4, -32e-4, 8e-4, 29e-4, 43e-4, 3e-4, 25e-4, -9e-4, 47e-4, 16e-4, 22e-4, 18e-4, -1e-3, 25e-4, -3e-3, -1e-3, 33e-4, 34e-4, 4e-4, -52e-4, 24e-4, -2e-4, 1e-3, -14e-4, -6e-4, 38e-4, -15e-4, -6e-4, -1e-3, -11e-4, -4e-4, -1e-3, 4e-4, -7e-4, 36e-4, -8e-4, -2e-4, -19e-4, 5e-4, 3e-4, -6e-4, -24e-4, -17e-4, -14e-4, 6e-4, -4e-4, -31e-4, -13e-4, -6e-4, 42e-4, 2e-4, -2e-4, -2e-3, -3e-4, 8e-4, 18e-4, -5e-4, -6e-4, -2e-4, -6e-4, 25e-4, 19e-4, 1e-3, 8e-4, -15e-4, -12e-4, -1e-4, -6e-4, -4e-4, 23e-4, -1e-3, 6e-4, -2e-4, -1e-3, 0, -9e-4, -2e-3, -11e-4, 1e-4, 0, -1e-4, 5e-4, 6e-4, 9e-4, -6e-4, 5e-4, 8e-4, -1e-4, -2e-4, -17e-4, -6e-4, -4e-4, 4e-4, -6e-4, 12e-4, 4e-4, 3e-4, -7e-4, 3e-4, -2e-4, 6e-4, 1e-4, 5e-4, -19e-4, -6e-4, 4e-4, 7e-4, -1e-4, 1e-4, 5e-4, 1e-3, -6e-4, -2e-3, -7e-4, -5e-4, 5e-4, 3e-4, 7e-4, 14e-4, 0, 5e-4, -5e-4, -2e-4, 3e-4, -6e-4, -1e-4], expression: [-9e-4, -3e-4, 32e-4, -3e-3, -34e-4, -31e-4, 14e-4, 0, 4e-4, -0.0139, -0.0764, 0.0275, -2e-3, -89e-4, 31e-4, -0.0503, -0.0771, 0.038, -0.1323, -0.3523, 0.1368, -0.0474, -0.0564, 0.0296, -45e-4, 7e-3, -13e-4, 0.0153, 0.1259, -0.0464, 0.0866, 0.2175, -0.0786, -0.0413, -0.1248, 0.0448, -0.1777, -0.4607, 0.1782, -5e-4, -5e-3, 16e-4, 0.0629, 0.1506, -0.0624, 0.0545, 0.2576, -0.0864, -0.0231, -0.0552, 0.0244, -0.0136, -0.0359, 0.0169, -0.1158, -0.2996, 0.1214, -0.0235, -0.0354, 0.0165, -0.0745, -0.1079, 0.0475, -0.0116, -39e-4, 12e-4, 13e-4, -0.0108, -8e-4, 44e-4, -27e-4, -1e-4, -0.0694, 0.0363, 71e-4, 0.1462, -0.136, 47e-4, 9e-3, -0.0177, 38e-4, -0.0271, 0.0118, 11e-4, -0.0399, -0.0111, 0.0123] }, 12: { mean: [-0.2981, 0.3828, 0.7563], identity: [-0.0116, 0.014, 54e-4, 18e-4, 5e-4, 0, -4e-4, 68e-4, -13e-4, -19e-4, -48e-4, -5e-4, 5e-4, 0.0108, -36e-4, -29e-4, -18e-4, 29e-4, 43e-4, -77e-4, 6e-4, -17e-4, 2e-3, -11e-4, -14e-4, -35e-4, 15e-4, -24e-4, 11e-4, 4e-4, -48e-4, 2e-4, 29e-4, -1e-4, -1e-4, 3e-3, 19e-4, 35e-4, -16e-4, -4e-4, 39e-4, 19e-4, 1e-4, -64e-4, 4e-3, 3e-4, 2e-3, -21e-4, 17e-4, 11e-4, -1e-3, 26e-4, 25e-4, -5e-4, 2e-4, -3e-4, -5e-4, -7e-4, 9e-4, -4e-4, -1e-3, -22e-4, 1e-3, 9e-4, -14e-4, 7e-4, 11e-4, -1e-3, -5e-4, -8e-4, -17e-4, -21e-4, 9e-4, 36e-4, 5e-4, 4e-4, -31e-4, 6e-4, -15e-4, 27e-4, 2e-4, 1e-4, -11e-4, 2e-4, -11e-4, -18e-4, 4e-4, -13e-4, -2e-4, 7e-4, 9e-4, -3e-4, 1e-3, -21e-4, 8e-4, 6e-4, -9e-4, 4e-4, -7e-4, 8e-4, -2e-3, -13e-4, 0, 7e-4, -12e-4, -1e-4, 14e-4, 14e-4, -1e-4, 13e-4, 6e-4, 6e-4, -14e-4, -15e-4, -9e-4, 1e-4, 1e-4, 9e-4, 7e-4, 0, 1e-4, -1e-3, -4e-4, 0, -5e-4, 1e-4, -3e-4, 4e-4, -5e-4, -1e-4, -11e-4, 2e-4, 0, 1e-4, 8e-4, 8e-4, 0, -7e-4, -8e-4, 0, 2e-4, -1e-4, 1e-3, 3e-4, 4e-4, -2e-4, 0, 5e-4, 18e-4, -1e-4], expression: [0, -4e-4, 28e-4, 36e-4, -8e-4, -26e-4, -15e-4, -8e-4, 3e-4, 75e-4, -0.0608, 0.025, 19e-4, -76e-4, 33e-4, 0.0379, -0.0437, 0.0335, 0.0964, -0.2452, 0.1233, 0.0368, -0.0251, 0.0253, 33e-4, 97e-4, -21e-4, -95e-4, 0.1171, -0.0475, -0.064, 0.1548, -0.0718, 0.0228, -0.0831, 0.0343, -0.1924, 0.6206, -0.2771, 21e-4, -0.0143, 56e-4, -0.0705, 0.2522, -0.1116, -0.0692, 0.4229, -0.1592, -93e-4, 0.05, -0.0185, 0.0948, -0.3196, 0.1437, -0.0184, 0.0194, -0.0131, 0.0205, -0.0353, 0.0201, 0.0676, -0.135, 0.0672, 0.0137, -0.0311, 0.0118, 3e-4, -77e-4, -2e-4, -0.0151, 4e-4, -58e-4, 0.029, -0.0139, 0.0163, 0.1324, 0.1819, -39e-4, 0.0406, 0.0501, 17e-4, 0.0331, 0.0161, 62e-4, -0.0235, -0.0446, 47e-4] } };

// node_modules/@zappar/zappar-cv/lib/facelandmark.js
var latestFaceLandmark = 1;
var faceLandmarkById = /* @__PURE__ */ new Map();
function createFaceLandmark(n) {
  let ret = latestFaceLandmark++;
  faceLandmarkById.set(ret, new FaceLandmark(n));
  zcout("face_landmark_t initialized");
  return ret;
}
function destroyFaceLandmark(m) {
  faceLandmarkById.delete(m);
}
function getFaceLandmark(m) {
  return faceLandmarkById.get(m);
}
var FaceLandmark = class {
  constructor(_name) {
    this._name = _name;
    this.anchor_pose = mat4_exports.create();
  }
  _getVertex(identity4, expression, data) {
    let vert = data.mean.slice();
    for (let i = 0; i < 50; i++) {
      vert[0] += identity4[i] * data.identity[i * 3 + 0];
      vert[1] += identity4[i] * data.identity[i * 3 + 1];
      vert[2] += identity4[i] * data.identity[i * 3 + 2];
    }
    for (let i = 0; i < 29; i++) {
      vert[0] += expression[i] * data.expression[i * 3 + 0];
      vert[1] += expression[i] * data.expression[i * 3 + 1];
      vert[2] += expression[i] * data.expression[i * 3 + 2];
    }
    return vert;
  }
  update(identity4, expression, mirrored) {
    let vert;
    let data = landmarkData[this._name.toString()];
    if (!data)
      return;
    if (Array.isArray(data)) {
      vert = this._getVertex(identity4, expression, data[0]);
      let b = this._getVertex(identity4, expression, data[1]);
      vert[0] = 0.5 * (vert[0] + b[0]);
      vert[1] = 0.5 * (vert[1] + b[1]);
      vert[2] = 0.5 * (vert[2] + b[2]);
    } else {
      vert = this._getVertex(identity4, expression, data);
    }
    if (mirrored)
      vert[0] *= -1;
    mat4_exports.fromTranslation(this.anchor_pose, vert);
  }
};

// node_modules/@zappar/zappar-cv/lib/compatibility.js
function getUnsupportedMessage() {
  let ret = document.createElement("div");
  let idealBrowser = "a recent web browser";
  if (navigator.userAgent.match(/Android/i)) {
    idealBrowser = "Chrome for Android";
    window.location.href = "googlechrome://navigate?url=" + encodeURI(window.location.href);
    setTimeout(() => {
      window.location.href = "samsunginternet://open?url=" + encodeURI(window.location.href);
    }, 2e3);
  } else if (navigator.userAgent.match(/iPhone|iPod|iPad/i)) {
    idealBrowser = "Safari";
    ret.classList.add("zee-launcher-browser-safari");
  }
  ret.classList.add("zee-launcher-unsupported");
  ret.innerHTML = `
            <style>.zee-launcher-unsupported {
               display: flex;
               flex-direction: column;
               height: 100%;
               justify-content: center;
               position: absolute;
               width: 100%;
               height: 100%;
               top: 0;
               left: 0;
               align-items: center;
               }
               .zee-launcher-browser-logo {
               background-image: url("data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg version='1.1' viewBox='0 0 210 211' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg transform='translate(-82 -146)' fill-rule='nonzero' stroke='%23ffffff' stroke-width='2'%3E%3Cg transform='translate(83 146.5)'%3E%3Cpath d='m55.146 88.785l-32.039-49.472c19.962-24.947 49.904-38.684 80.517-38.81 17.739-0.12642 35.855 4.4246 52.336 13.99 18.2 10.619 32.039 25.874 40.846 43.404l-86.095-4.5511c-24.365-1.4327-47.556 12.347-55.565 35.439zm13.797 16.224c0 19.468 15.684 35.229 35.059 35.229 19.374 0 35.059-15.76 35.059-35.229 0-19.468-15.684-35.229-35.059-35.229-19.374 0-35.059 15.718-35.059 35.229zm132.06-37.588l-58.585 3.034c15.894 18.668 16.145 45.595 2.7678 66.243l-47.01 72.648c19.5 1.0535 39.588-3.2447 57.788-13.864 45.039-26.126 63.282-80.908 45.039-128.06zm-144.93 57.647l-39.126-77.326c-10.694 16.434-16.942 36.156-16.942 57.267 0 52.253 38.078 95.53 87.856 103.2l26.713-52.59c-24.155 4.5511-47.472-8.765-58.501-30.551z'/%3E%3C/g%3E%3C/g%3E%3C/g%3E%3C/svg%3E%0A");
               width: 211px;
               height: 211px;
               margin-bottom: 25%;
               margin-top: -60px;
               background-repeat: no-repeat;
               }
               .zee-launcher-browser-safari .zee-launcher-browser-logo {
               background-image: url("data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg version='1.1' viewBox='0 0 211 211' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg transform='translate(-82 -146)' fill-rule='nonzero' stroke='%23ffffff' stroke-width='2'%3E%3Cpath d='m180 251.86c0-4.0385 2.9377-7.855 7.2552-7.855 3.9614 0 7.7448 2.8402 7.7448 7.145 0 4.0385-2.8487 7.855-7.1662 7.855-4.0059 0-7.8338-2.9734-7.8338-7.145zm112-0.35503c0 57.728-46.772 104.5-104.5 104.5s-104.5-46.772-104.5-104.5 46.772-104.5 104.5-104.5 104.5 46.772 104.5 104.5zm-12-1c0-51.649-41.851-93.5-93.5-93.5s-93.5 41.851-93.5 93.5 41.851 93.5 93.5 93.5 93.5-41.851 93.5-93.5zm-30.624 40.983c0 1.5095 5.4495 4.2768 6.8328 5.1154-11.486 17.401-29.26 29.938-49.423 34.928l-1.8444-7.757c-0.12576-1.0482-0.79646-1.174-1.7606-1.174-0.79646 0-1.2576 1.174-1.1737 1.7611l1.8444 7.8828c-5.5753 1.174-11.234 1.7611-16.935 1.7611-15.217 0-30.182-4.2768-43.177-12.202 0.71263-1.174 5.1141-7.5474 5.1141-8.4698 0-0.79666-0.71263-1.5095-1.5091-1.5095-1.6348 0-5.1141 6.9603-6.1621 8.344-17.522-11.615-30.182-29.602-35.044-50.148l8.0066-1.761c0.92222-0.25158 1.1737-0.92246 1.1737-1.7611 0-0.79667-1.1737-1.2579-1.8444-1.174l-7.8389 1.803c-1.048-5.3251-1.6348-10.692-1.6348-16.143 0-15.556 4.4015-30.86 12.66-43.984 1.1737 0.71281 6.749 4.5284 7.6712 4.5284 0.79646 0 1.5091-0.58702 1.5091-1.3837 0-1.6353-6.1621-4.7381-7.5455-5.7024 11.821-17.275 29.805-29.728 50.219-34.34l1.7606 7.757c0.25152 0.92246 0.92222 1.174 1.7606 1.174 0.83838 0 1.2576-1.174 1.1737-1.8449l-1.7606-7.6732c5.1141-0.92246 10.312-1.5095 15.552-1.5095 15.552 0 30.727 4.4026 43.973 12.663-0.79646 1.174-4.5273 6.6249-4.5273 7.5474 0 0.79667 0.58687 1.5095 1.3833 1.5095 1.6348 0 4.7369-6.0379 5.5753-7.4216 17.187 11.615 29.469 29.351 34.248 49.561l-6.4975 1.3837c-1.048 0.25158-1.1737 0.92246-1.1737 1.8449 0 0.79667 1.1737 1.2579 1.7606 1.174l6.6232-1.5095c1.048 5.3251 1.6348 10.776 1.6348 16.227 0 15.221-4.1919 30.189-12.073 43.062-1.1737-0.58702-6.0364-4.0672-6.9586-4.0672-0.8803 0-1.5929 0.71281-1.5929 1.5095zm-14.876-98.483c-5.2178 4.88-53.863 49.48-55.228 51.8l-38.772 64.2c5.0974-4.76 53.863-49.6 55.108-51.72l38.892-64.28z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
               }
               .zee-launcher-unsupported-message {
               text-align: center;
               width: 250px;
               font-family: sans-serif;
               color: #ffffff;
               }
               .zee-launcher-unsupported-message-copy {
               border: 1px solid #ffffff;
               border-radius: 5px;
               margin-top: 10px;
               }
               #zee-launcher-unsupported-message-input {
               border: none;
               padding: 10px;
               border-radius: 0px;
               border-right: 1px solid #344B60;
               height: 40px;
               color: #ffffff;
               background-color: black;
               box-sizing: border-box;
               width: calc(100% - 65px);
               margin-left: 5px;
               }
               #zee-launcher-unsupported-message-button {
               background: none;
               border: none;
               outline: none;
               text-transform: uppercase;
               color: #ffffff;
               height: 40px;
               display: inline-block;
               width: 59px;
               }
               .zee-launcher-unsupported-message-before-copy {
               height: 100px;
               display: flex;
               flex-direction: column;
               justify-content: center;
               margin-top: 20px;
               }
               .zee-launcher-unsupported-message-copied .zee-launcher-unsupported-message-before-copy {
               display: none;
               }
               .zee-launcher-unsupported-message-after-copy {
               display: none;
               }
               .zee-launcher-unsupported-message-copied .zee-launcher-unsupported-message-after-copy {
               height: 100px;
               display: flex;
               flex-direction: column;
               justify-content: center;
               margin-top: 20px;
               }
            </style>
            <div class="zee-launcher-browser-logo"></div>
            <div class="zee-launcher-unsupported-message">Open with ${idealBrowser} to access this content.</div>
            <div class="zee-launcher-unsupported-message-before-copy">
               <div class="zee-launcher-unsupported-message ">Tap below to copy the address for easy pasting into ${idealBrowser}.</div>
               <div class="zee-launcher-unsupported-message-copy"><input id="zee-launcher-unsupported-message-input" type="text/"><button id="zee-launcher-unsupported-message-button">Copy</button></div>
            </div>
            <div class="zee-launcher-unsupported-message zee-launcher-unsupported-message-after-copy">COPIED! Now paste into ${idealBrowser}'s address bar to experience the content.</div>
    `;
  let inpElm = ret.querySelector("#zee-launcher-unsupported-message-input") || document.createElement("input");
  inpElm.value = window.location.href;
  let btnElm = ret.querySelector("#zee-launcher-unsupported-message-button") || document.createElement("button");
  let onCopyPressed = () => {
    if (navigator.userAgent.match(/iPhone|iPod|iPad/i)) {
      let r = document.createRange();
      r.selectNodeContents(inpElm);
      let sel = window.getSelection();
      if (!sel)
        return;
      sel.removeAllRanges();
      sel.addRange(r);
      inpElm.setSelectionRange(0, 999999999);
    } else {
      inpElm.select();
    }
    document.execCommand("copy");
    inpElm.blur();
    ret.classList.toggle("zee-launcher-unsupported-message-copied", true);
  };
  btnElm.addEventListener("click", onCopyPressed);
  inpElm.addEventListener("click", onCopyPressed);
  return ret;
}
var incompatibleUI = () => {
  const zapparCompatibility = document.createElement("div");
  zapparCompatibility.append(getUnsupportedMessage());
  Object.assign(zapparCompatibility.style, {
    position: "fixed",
    width: "100%",
    height: "100%",
    top: "0px",
    left: "0px",
    zIndex: 1001,
    backgroundColor: "rgba(0, 0, 0, 0.9)",
    fontFamily: "sans-serif",
    color: "white",
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
    justifyContent: "center"
  });
  zapparCompatibility.classList.add("zee_launcher_compatibility");
  document.body.append(zapparCompatibility);
};
function isSupportedBrowser() {
  if (typeof Promise !== "function")
    return false;
  if (typeof WebAssembly !== "object")
    return false;
  if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices || !navigator.mediaDevices.getUserMedia)
    return false;
  return true;
}
var compatibility_default = {
  incompatible: () => !isSupportedBrowser(),
  incompatible_ui: incompatibleUI
};

// node_modules/@zappar/zappar-cv/lib/sequencesource.js
var latest3 = 1;
var byId4 = /* @__PURE__ */ new Map();
var SequenceSource = class _SequenceSource extends Source {
  constructor(_impl, _pipeline) {
    super();
    this._impl = _impl;
    this._pipeline = _pipeline;
    this._packetNumber = 0;
    this._motionUpdatesQueued = 0;
    this._motionUpdatesSent = 0;
    this._minFrameGapMs = 0;
    this._lastUpdateTime = 0;
  }
  static create(p) {
    let ret = latest3++;
    byId4.set(ret, new _SequenceSource(ret, p));
    zcout("sequence_source_source_t initialized");
    return ret;
  }
  static get(m) {
    return byId4.get(m);
  }
  loadFromMemory(data) {
    try {
      this._decoder = new SequenceDecoder(data);
      this._packetNumber = 0;
      this._lastUpdateTime = 0;
    } catch (err) {
      zcerr("Unable to decode sequence:", err);
    }
  }
  maxPlaybackFpsSet(fps) {
    if (fps <= 0) {
      this._minFrameGapMs = 0;
      return;
    }
    this._minFrameGapMs = 1e3 / fps;
  }
  setTime(t) {
    if (t < 0)
      delete this._time;
    else
      this._time = t;
  }
  getFrame(currentlyProcessing) {
    var _a;
    let pipeline = Pipeline.get(this._pipeline);
    if (!pipeline)
      return;
    if (!this._decoder)
      return;
    this._submitMotionUpdates(pipeline);
    if (this._motionUpdatesQueued > this._motionUpdatesSent)
      return;
    if (currentlyProcessing)
      return;
    let curTime = (_a = this._time) !== null && _a !== void 0 ? _a : performance.now();
    if (curTime < this._lastUpdateTime + this._minFrameGapMs)
      return;
    if (this._packetNumber >= this._decoder.numberPackets)
      return;
    let packet = this._decoder.dataByPacket.get(this._packetNumber);
    if (packet.type != SequenceRecorderPacketType.CAMERA_FRAME)
      return;
    this._packetNumber++;
    let pixels = pipeline.cameraPixelArrays.pop();
    while (pixels) {
      if (pixels.byteLength === packet.greyscale.byteLength)
        break;
      pixels = pipeline.cameraPixelArrays.pop();
    }
    if (!pixels) {
      pixels = new ArrayBuffer(packet.greyscale.byteLength);
    }
    new Uint8Array(pixels).set(packet.greyscale);
    this._lastUpdateTime = curTime;
    let info = {
      data: pixels,
      cameraSourceData: packet.greyscale,
      cameraModel: packet.cameraModel,
      cameraToDevice: packet.cameraToDevice,
      dataWidth: packet.width,
      dataHeight: packet.height,
      texture: void 0,
      userFacing: packet.userFacing,
      uvTransform: mat4_exports.create(),
      cameraSource: this
    };
    this._submitMotionUpdates(pipeline);
    const token = pipeline.registerToken(info);
    pipeline.sendDataToWorker(info.data || new ArrayBuffer(0), token, info.dataWidth, info.dataHeight, info.userFacing, info.cameraToDevice, info.cameraModel);
  }
  destroy() {
    byId4.delete(this._impl);
    this.pause();
  }
  start() {
    var _a;
    let p = Pipeline.get(this._pipeline);
    if (p && p.currentCameraSource !== this) {
      (_a = p.currentCameraSource) === null || _a === void 0 ? void 0 : _a.pause();
      p.currentCameraSource = this;
    }
  }
  pause() {
    let p = Pipeline.get(this._pipeline);
    if (p && p.currentCameraSource === this)
      p.currentCameraSource = void 0;
  }
  uploadGL(info) {
    let pipeline = Pipeline.get(this._pipeline);
    if (!pipeline)
      return;
    let gl = pipeline === null || pipeline === void 0 ? void 0 : pipeline.glContext;
    if (!gl)
      return;
    if (!info.texture)
      info.texture = pipeline.getVideoTexture();
    if (!info.texture)
      return;
    if (!info.cameraSourceData)
      return;
    gl.bindTexture(gl.TEXTURE_2D, info.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, info.dataWidth, info.dataHeight, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, new Uint8Array(info.cameraSourceData));
    gl.bindTexture(gl.TEXTURE_2D, null);
  }
  _submitMotionUpdates(pipeline) {
    let pendingMotionUpdate = false;
    while (this._packetNumber < this._decoder.numberPackets) {
      let packet = this._decoder.dataByPacket.get(this._packetNumber);
      if (packet.type == SequenceRecorderPacketType.CAMERA_FRAME)
        break;
      switch (packet.type) {
        case SequenceRecorderPacketType.ACCELEROMETER:
          pipeline.motionAccelerometerSubmit(packet.t, packet.x, packet.y, packet.z);
          pendingMotionUpdate = true;
          break;
        case SequenceRecorderPacketType.ROTATION_RATE:
          pipeline.motionRotationRateSubmit(packet.t, packet.x, packet.y, packet.z);
          pendingMotionUpdate = true;
          break;
        case SequenceRecorderPacketType.ATTITUDE:
          pipeline.motionAttitudeSubmit(packet.t, packet.x, packet.y, packet.z);
          pendingMotionUpdate = true;
          break;
        case SequenceRecorderPacketType.ATTITUDE_MATRIX:
          pipeline.motionAttitudeMatrix(packet.attitude);
          pendingMotionUpdate = true;
          break;
      }
      this._packetNumber++;
    }
    if (pendingMotionUpdate) {
      this._motionUpdatesQueued++;
      setTimeout(() => {
        this._motionUpdatesSent++;
      }, 0);
    }
    return;
  }
};

// node_modules/@zappar/zappar-cv/lib/gfx.js
var gfx = `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="250" height="80.408" viewBox="0 0 250 80.408"><defs><filter id="a" x="0" y="1.182" width="250" height="79.226" filterUnits="userSpaceOnUse"><feOffset dy="3" input="SourceAlpha"/><feGaussianBlur stdDeviation="3" result="b"/><feFlood flood-opacity="0.161"/><feComposite operator="in" in2="b"/><feComposite in="SourceGraphic"/></filter><filter id="c" x="6.929" y="0" width="111.975" height="40.988" filterUnits="userSpaceOnUse"><feOffset dy="3" input="SourceAlpha"/><feGaussianBlur stdDeviation="3" result="d"/><feFlood flood-opacity="0.161"/><feComposite operator="in" in2="d"/><feComposite in="SourceGraphic"/></filter></defs><g transform="translate(-26.873 -414.029)"><g transform="translate(44 423.332)"><g transform="translate(0 0.635)" style="isolation:isolate"><g transform="translate(0 0)"><g transform="matrix(1, 0, 0, 1, -17.13, -9.94)" filter="url(#a)"><path d="M55.766,44.97V11.8h8.272v2.6h.089a8.258,8.258,0,0,1,7.046-3.357,11.4,11.4,0,0,1,8.5,3.686,12.667,12.667,0,0,1,3.278,8.622,12.509,12.509,0,0,1-3.25,8.57,11.353,11.353,0,0,1-8.429,3.6,9.533,9.533,0,0,1-7.229-2.95V43.378l-8.269,1.594h0Zm8-21.671a4.958,4.958,0,0,0,5.319,5.15A4.957,4.957,0,0,0,74.4,23.3a5.321,5.321,0,0,0-10.638,0ZM16.105,18.412H2.752V11.038H30.9L14.887,37.16H38.22L0,44.534ZM131.469,38.45a.761.761,0,0,1-.484-.166.582.582,0,0,1-.228-.419l-.553-3.586a12.243,12.243,0,0,1-1.782-.721l-2.789,2.084a.718.718,0,0,1-.5.176.688.688,0,0,1-.495-.214,25.864,25.864,0,0,1-3.264-3.274.754.754,0,0,1,.018-.9c.2-.277.543-.713,1.01-1.3.483-.6.832-1.05,1.068-1.374a9.614,9.614,0,0,1-.811-1.929l-3.62-.527a.631.631,0,0,1-.416-.243.728.728,0,0,1-.159-.458V21.283a.743.743,0,0,1,.159-.448.6.6,0,0,1,.376-.253l3.68-.546a9.511,9.511,0,0,1,.772-1.792c-.523-.733-1.235-1.638-2.117-2.69a.731.731,0,0,1-.2-.467.82.82,0,0,1,.178-.449,19.577,19.577,0,0,1,1.949-2.095c.953-.924,1.582-1.393,1.87-1.393a.861.861,0,0,1,.515.195l2.729,2.084a11.551,11.551,0,0,1,1.8-.741,31.446,31.446,0,0,1,.573-3.623.666.666,0,0,1,.712-.546h4.392a.757.757,0,0,1,.485.166.58.58,0,0,1,.228.419l.553,3.584a12.576,12.576,0,0,1,1.782.722l2.809-2.085a.641.641,0,0,1,.475-.176.776.776,0,0,1,.5.195,27.035,27.035,0,0,1,3.264,3.313.625.625,0,0,1,.139.429.742.742,0,0,1-.159.447c-.2.271-.525.7-1.008,1.3-.467.581-.827,1.043-1.069,1.373a11.8,11.8,0,0,1,.812,1.91l3.62.545a.626.626,0,0,1,.416.244.736.736,0,0,1,.158.457v4.325a.755.755,0,0,1-.158.449.6.6,0,0,1-.4.253l-3.66.545a12.692,12.692,0,0,1-.772,1.774c.465.653,1.177,1.559,2.117,2.688a.751.751,0,0,1,.2.488.648.648,0,0,1-.178.448,19.638,19.638,0,0,1-1.958,2.1c-.947.918-1.573,1.384-1.861,1.384a.976.976,0,0,1-.515-.176l-2.731-2.1a11.361,11.361,0,0,1-1.8.741,31.849,31.849,0,0,1-.573,3.625.668.668,0,0,1-.713.546Zm-1.385-18.491a4.935,4.935,0,0,0,0,7.053,5.12,5.12,0,0,0,7.163,0,4.931,4.931,0,0,0,0-7.053,5.117,5.117,0,0,0-7.163,0Zm69.969,14.868a18.523,18.523,0,0,1-4.932-2.073l1.705-6.1A13.441,13.441,0,0,0,200.779,29a12.14,12.14,0,0,0,4.344.818,4.644,4.644,0,0,0,2.351-.482,1.538,1.538,0,0,0,.806-1.4q0-1.5-3.25-2.242-1.061-.246-1.705-.425a12.335,12.335,0,0,1-5.358-2.589,5.5,5.5,0,0,1-1.671-4.157,6.323,6.323,0,0,1,2.547-5.267,10.993,10.993,0,0,1,6.9-1.972,21.351,21.351,0,0,1,4.552.5,25.439,25.439,0,0,1,4.736,1.557l-1.705,5.491a14.244,14.244,0,0,0-3.319-1.636,10.6,10.6,0,0,0-3.364-.561,4.227,4.227,0,0,0-2.121.426,1.357,1.357,0,0,0-.714,1.232q0,1.211,3.227,2.04.737.2,1.106.291,4.264,1.187,5.935,2.79a5.728,5.728,0,0,1,1.67,4.337A6.781,6.781,0,0,1,213,33.37a11.48,11.48,0,0,1-7.259,2.14A22.577,22.577,0,0,1,200.053,34.827ZM30.568,31.834a12.566,12.566,0,0,1-3.292-8.59,12.567,12.567,0,0,1,3.247-8.568,11.3,11.3,0,0,1,8.423-3.638,9.519,9.519,0,0,1,7.217,3V11.8h8.264V34.735H46.163V32.186h-.09c-1.32,2.071-3.951,3.308-7.038,3.308A11.412,11.412,0,0,1,30.568,31.834Zm5.245-8.545a4.95,4.95,0,0,0,5.312,5.141,4.95,4.95,0,0,0,5.312-5.141A5.023,5.023,0,0,0,41.125,18.1,5.023,5.023,0,0,0,35.813,23.289Zm69.2,11.554-3.527-10.452q-.282-.892-.505-1.8t-.412-1.8a30.821,30.821,0,0,1-.917,3.454l-.047.16L96.1,34.842H90.176l-9.925-23.1h8.632l3.552,10.223q.4,1.12.634,1.955t.377,1.635a23.558,23.558,0,0,1,.917-3.179q.093-.274.141-.411l3.528-10.223h5.056l3.5,10.2.07.183a20.724,20.724,0,0,1,.988,3.43q.141-.732.364-1.532t.647-2.058l3.574-10.223h8.678l-9.971,23.1Zm80.154-.092-8.587-9.841v9.841h-7.888V1.5L176.583,0V22.28l8.272-9.665h9.96L184.584,23.266l11.156,11.485Zm-35.09,0V11.782h8.272v3.761h.091a8.131,8.131,0,0,1,7.546-4.074h1.593V19.3a6.8,6.8,0,0,0-3.5-.761c-4.593,0-5.728,3-5.728,6.941v9.268Z" transform="translate(17.13 15.31)"/></g><g transform="matrix(1, 0, 0, 1, -17.13, -9.94)" filter="url(#c)"><path d="M3.576-12.852v-4.3H6.628a2.867,2.867,0,0,1,1.945.55A2.034,2.034,0,0,1,9.188-15a2.06,2.06,0,0,1-.615,1.608,2.784,2.784,0,0,1-1.945.542ZM2.017-18.464V-6.748H3.576v-4.792H7.153a3.569,3.569,0,0,0,2.683-.9A3.478,3.478,0,0,0,10.747-15a3.45,3.45,0,0,0-.911-2.552,3.638,3.638,0,0,0-2.683-.911Zm11.421,7.483a4.221,4.221,0,0,1,.205-1.37,2.957,2.957,0,0,1,.566-1.009,2.411,2.411,0,0,1,.845-.624A2.515,2.515,0,0,1,16.08-14.2a2.515,2.515,0,0,1,1.026.213,2.411,2.411,0,0,1,.845.624,2.957,2.957,0,0,1,.566,1.009,4.221,4.221,0,0,1,.205,1.37,4.221,4.221,0,0,1-.205,1.37,2.867,2.867,0,0,1-.566,1,2.457,2.457,0,0,1-.845.615,2.515,2.515,0,0,1-1.026.213,2.515,2.515,0,0,1-1.026-.213,2.457,2.457,0,0,1-.845-.615,2.867,2.867,0,0,1-.566-1A4.221,4.221,0,0,1,13.438-10.981Zm-1.477,0a5.573,5.573,0,0,0,.263,1.739,3.97,3.97,0,0,0,.788,1.4,3.623,3.623,0,0,0,1.3.935,4.4,4.4,0,0,0,1.772.336A4.381,4.381,0,0,0,17.86-6.9a3.641,3.641,0,0,0,1.288-.935,3.97,3.97,0,0,0,.788-1.4,5.573,5.573,0,0,0,.263-1.739,5.65,5.65,0,0,0-.263-1.748,3.96,3.96,0,0,0-.788-1.411,3.729,3.729,0,0,0-1.288-.944,4.29,4.29,0,0,0-1.78-.345,4.3,4.3,0,0,0-1.772.345,3.71,3.71,0,0,0-1.3.944,3.96,3.96,0,0,0-.788,1.411A5.65,5.65,0,0,0,11.961-10.981Zm18.28,4.234,2.708-8.484H31.5L29.6-8.29h-.033L27.8-15.231H26.27L24.564-8.29h-.033l-1.92-6.941H21.068l2.724,8.484H25.3l1.707-6.744h.033l1.723,6.744ZM40.169-11.8H35.3a2.905,2.905,0,0,1,.213-.927A2.473,2.473,0,0,1,36-13.492a2.255,2.255,0,0,1,.747-.517,2.429,2.429,0,0,1,.976-.189,2.386,2.386,0,0,1,.96.189,2.415,2.415,0,0,1,.755.509,2.391,2.391,0,0,1,.509.763A2.854,2.854,0,0,1,40.169-11.8Zm1.346,2.363H40.136a1.983,1.983,0,0,1-.747,1.247,2.414,2.414,0,0,1-1.452.41,2.889,2.889,0,0,1-1.2-.23,2.348,2.348,0,0,1-.837-.615,2.4,2.4,0,0,1-.476-.886,3.367,3.367,0,0,1-.131-1.058h6.35a6.754,6.754,0,0,0-.139-1.625,4.7,4.7,0,0,0-.624-1.575,3.716,3.716,0,0,0-1.2-1.19,3.48,3.48,0,0,0-1.879-.468,3.858,3.858,0,0,0-1.6.328,3.76,3.76,0,0,0-1.264.919,4.236,4.236,0,0,0-.829,1.395,5.105,5.105,0,0,0-.3,1.772,6.8,6.8,0,0,0,.287,1.789,3.9,3.9,0,0,0,.763,1.411,3.478,3.478,0,0,0,1.255.919,4.358,4.358,0,0,0,1.764.328,3.851,3.851,0,0,0,2.4-.722A3.39,3.39,0,0,0,41.515-9.439Zm1.526-5.793v8.484h1.395v-3.774a5.8,5.8,0,0,1,.164-1.452,2.784,2.784,0,0,1,.525-1.075,2.251,2.251,0,0,1,.952-.673,3.945,3.945,0,0,1,1.428-.23v-1.477a3.135,3.135,0,0,0-1.871.459,3.779,3.779,0,0,0-1.247,1.526h-.033v-1.789ZM54.15-11.8H49.276a2.905,2.905,0,0,1,.213-.927,2.473,2.473,0,0,1,.492-.763,2.255,2.255,0,0,1,.747-.517A2.429,2.429,0,0,1,51.7-14.2a2.386,2.386,0,0,1,.96.189,2.415,2.415,0,0,1,.755.509,2.391,2.391,0,0,1,.509.763A2.854,2.854,0,0,1,54.15-11.8ZM55.5-9.439H54.117a1.983,1.983,0,0,1-.747,1.247,2.414,2.414,0,0,1-1.452.41,2.889,2.889,0,0,1-1.2-.23,2.348,2.348,0,0,1-.837-.615,2.4,2.4,0,0,1-.476-.886,3.367,3.367,0,0,1-.131-1.058h6.35a6.754,6.754,0,0,0-.139-1.625,4.7,4.7,0,0,0-.624-1.575,3.716,3.716,0,0,0-1.2-1.19,3.48,3.48,0,0,0-1.879-.468,3.858,3.858,0,0,0-1.6.328,3.76,3.76,0,0,0-1.264.919,4.236,4.236,0,0,0-.829,1.395,5.1,5.1,0,0,0-.3,1.772,6.8,6.8,0,0,0,.287,1.789,3.9,3.9,0,0,0,.763,1.411,3.478,3.478,0,0,0,1.255.919,4.358,4.358,0,0,0,1.764.328,3.851,3.851,0,0,0,2.4-.722A3.39,3.39,0,0,0,55.5-9.439Zm2.593-1.477a5.581,5.581,0,0,1,.131-1.214,3.212,3.212,0,0,1,.427-1.05,2.221,2.221,0,0,1,.788-.738,2.4,2.4,0,0,1,1.2-.279,2.589,2.589,0,0,1,1.231.271,2.389,2.389,0,0,1,.829.714,2.985,2.985,0,0,1,.468,1.026,4.889,4.889,0,0,1,.148,1.206,4.919,4.919,0,0,1-.139,1.165,3.053,3.053,0,0,1-.451,1.026,2.4,2.4,0,0,1-.8.73,2.4,2.4,0,0,1-1.2.279,2.491,2.491,0,0,1-1.173-.263,2.332,2.332,0,0,1-.82-.706,3.122,3.122,0,0,1-.476-1.009A4.338,4.338,0,0,1,58.088-10.916Zm6.564,4.168V-18.464H63.257V-14.1h-.033a2.247,2.247,0,0,0-.566-.632,3.216,3.216,0,0,0-.714-.41,3.583,3.583,0,0,0-.755-.222,4.132,4.132,0,0,0-.706-.066,3.861,3.861,0,0,0-1.7.353,3.487,3.487,0,0,0-1.214.952,4.018,4.018,0,0,0-.722,1.4,5.985,5.985,0,0,0-.238,1.707,5.8,5.8,0,0,0,.246,1.707,4.218,4.218,0,0,0,.73,1.411,3.529,3.529,0,0,0,1.214.968,3.827,3.827,0,0,0,1.715.361,4.135,4.135,0,0,0,1.625-.312A2.053,2.053,0,0,0,63.224-7.9h.033v1.149Zm6.761-11.716V-6.748h1.395V-7.88h.033a2.247,2.247,0,0,0,.566.632,2.982,2.982,0,0,0,.714.4,3.874,3.874,0,0,0,.763.213,4.193,4.193,0,0,0,.7.066,3.94,3.94,0,0,0,1.7-.345,3.4,3.4,0,0,0,1.214-.944,4.018,4.018,0,0,0,.722-1.4,5.985,5.985,0,0,0,.238-1.707,5.8,5.8,0,0,0-.246-1.707,4.312,4.312,0,0,0-.73-1.419,3.488,3.488,0,0,0-1.214-.976,3.827,3.827,0,0,0-1.715-.361,4.043,4.043,0,0,0-1.625.32,2.088,2.088,0,0,0-1.083,1.026h-.033v-4.381Zm6.564,7.4a5.581,5.581,0,0,1-.131,1.214,3.212,3.212,0,0,1-.427,1.05,2.243,2.243,0,0,1-.779.738,2.385,2.385,0,0,1-1.206.279A2.589,2.589,0,0,1,74.2-8.052a2.389,2.389,0,0,1-.829-.714,2.985,2.985,0,0,1-.468-1.026A4.889,4.889,0,0,1,72.758-11a4.919,4.919,0,0,1,.139-1.165,3.053,3.053,0,0,1,.451-1.026,2.4,2.4,0,0,1,.8-.73,2.4,2.4,0,0,1,1.2-.279,2.491,2.491,0,0,1,1.173.263,2.332,2.332,0,0,1,.82.706,3.122,3.122,0,0,1,.476,1.009A4.338,4.338,0,0,1,77.976-11.063Zm6.449,5.448a8.871,8.871,0,0,1-.484,1.05,2.871,2.871,0,0,1-.525.7,1.782,1.782,0,0,1-.64.394,2.462,2.462,0,0,1-.812.123,3.721,3.721,0,0,1-.492-.033A2.324,2.324,0,0,1,81-3.5v-1.28a2.342,2.342,0,0,0,.418.139,1.765,1.765,0,0,0,.4.057,1.2,1.2,0,0,0,.714-.205,1.255,1.255,0,0,0,.435-.583L83.539-6.8l-3.364-8.434h1.575L84.228-8.29h.033l2.379-6.941h1.477Z" transform="translate(17.85 28.4)"/></g></g></g><g transform="translate(0 0)"><g transform="translate(0 5.371)"><path d="M11.76,24.456A11.41,11.41,0,0,1,3.292,20.8,12.564,12.564,0,0,1,0,12.206,12.569,12.569,0,0,1,3.246,3.638,11.307,11.307,0,0,1,11.67,0a9.519,9.519,0,0,1,7.217,3V.759h8.264V23.7H18.887V21.148H18.8C17.478,23.219,14.846,24.456,11.76,24.456ZM13.849,7.064A5.023,5.023,0,0,0,8.537,12.25a4.95,4.95,0,0,0,5.312,5.141A4.95,4.95,0,0,0,19.16,12.25,5.023,5.023,0,0,0,13.849,7.064Z" transform="translate(27.277 11.038)" fill="#fff"/><path d="M0,33.931V.758H8.271v2.6H8.36A8.258,8.258,0,0,1,15.406,0,11.4,11.4,0,0,1,23.9,3.686a12.665,12.665,0,0,1,3.278,8.622,12.508,12.508,0,0,1-3.25,8.57,11.351,11.351,0,0,1-8.429,3.6,9.535,9.535,0,0,1-7.229-2.95V32.337L0,33.931ZM13.317,7.07A5.028,5.028,0,0,0,8,12.259a4.957,4.957,0,0,0,5.319,5.15,4.957,4.957,0,0,0,5.319-5.15A5.028,5.028,0,0,0,13.317,7.07Z" transform="translate(55.766 11.041)" fill="#fff"/><path d="M22.836,0l3.5,10.2.07.183a20.748,20.748,0,0,1,.988,3.43q.141-.731.364-1.532t.647-2.058L31.985,0h8.678L30.691,23.1H24.764L21.237,12.647q-.282-.891-.505-1.8t-.412-1.8A30.927,30.927,0,0,1,19.4,12.51l-.047.16L15.851,23.1H9.925L0,0H8.631l3.552,10.223q.4,1.121.635,1.955t.377,1.635a23.522,23.522,0,0,1,.917-3.179q.093-.274.141-.411L17.78,0h5.056" transform="translate(80.251 11.743)" fill="#fff"/><path d="M0,34.75V1.5L7.888,0V22.28l8.272-9.665H26.12L15.889,23.266,27.045,34.75H16.475L7.888,24.91v9.84H0" transform="translate(168.695 0)" fill="#fff"/><path d="M0,21.47l1.705-6.1a13.453,13.453,0,0,0,3.952,2.342A12.145,12.145,0,0,0,10,18.534a4.643,4.643,0,0,0,2.351-.482,1.539,1.539,0,0,0,.807-1.4q0-1.5-3.25-2.241-1.06-.246-1.705-.426A12.325,12.325,0,0,1,2.846,11.4,5.5,5.5,0,0,1,1.176,7.239,6.324,6.324,0,0,1,3.722,1.972,11,11,0,0,1,10.624,0a21.365,21.365,0,0,1,4.551.5,25.45,25.45,0,0,1,4.736,1.558l-1.706,5.49a14.24,14.24,0,0,0-3.319-1.636,10.6,10.6,0,0,0-3.364-.56A4.22,4.22,0,0,0,9.4,5.782a1.356,1.356,0,0,0-.714,1.233q0,1.211,3.227,2.04.737.2,1.106.291,4.264,1.188,5.935,2.79a5.728,5.728,0,0,1,1.671,4.337,6.782,6.782,0,0,1-2.743,5.614,11.478,11.478,0,0,1-7.259,2.14,22.565,22.565,0,0,1-5.693-.683A18.517,18.517,0,0,1,0,21.47" transform="translate(195.121 11.284)" fill="#fff"/><path d="M8.273,4.075h.091A8.13,8.13,0,0,1,15.909,0H17.5V7.834A6.8,6.8,0,0,0,14,7.074c-4.593,0-5.728,3-5.728,6.941v9.268H0V.313H8.273V4.075" transform="translate(150.08 11.469)" fill="#fff"/><path d="M17.392,29.929H13a.76.76,0,0,1-.485-.166.579.579,0,0,1-.227-.419l-.553-3.586a12.3,12.3,0,0,1-1.781-.721L7.163,27.123a.719.719,0,0,1-.495.176.687.687,0,0,1-.495-.214A25.873,25.873,0,0,1,2.91,23.81a.753.753,0,0,1,.019-.9c.2-.277.542-.713,1.009-1.3.483-.6.832-1.05,1.068-1.374a9.591,9.591,0,0,1-.811-1.929l-3.62-.526a.63.63,0,0,1-.416-.243A.729.729,0,0,1,0,17.089V12.762a.746.746,0,0,1,.159-.448.6.6,0,0,1,.376-.253l3.68-.546a9.5,9.5,0,0,1,.772-1.792C4.464,8.991,3.752,8.085,2.87,7.034a.732.732,0,0,1-.2-.468.82.82,0,0,1,.179-.449A19.622,19.622,0,0,1,4.8,4.023C5.751,3.1,6.38,2.631,6.668,2.631a.859.859,0,0,1,.515.194L9.913,4.91a11.536,11.536,0,0,1,1.8-.741A31.372,31.372,0,0,1,12.287.546.665.665,0,0,1,13,0h4.392a.755.755,0,0,1,.485.166.581.581,0,0,1,.229.419l.553,3.584a12.543,12.543,0,0,1,1.781.722L23.25,2.807a.641.641,0,0,1,.475-.176.775.775,0,0,1,.495.194,27.092,27.092,0,0,1,3.264,3.313.625.625,0,0,1,.139.429.745.745,0,0,1-.159.448c-.2.271-.525.695-1.008,1.3-.467.581-.827,1.043-1.069,1.373a11.784,11.784,0,0,1,.812,1.91l3.62.545a.625.625,0,0,1,.416.244.736.736,0,0,1,.157.458v4.325a.754.754,0,0,1-.157.449.606.606,0,0,1-.4.253l-3.66.545a12.628,12.628,0,0,1-.772,1.774c.465.654,1.177,1.559,2.117,2.688a.752.752,0,0,1,.2.488.648.648,0,0,1-.177.448,19.641,19.641,0,0,1-1.959,2.1c-.947.918-1.573,1.384-1.86,1.384a.978.978,0,0,1-.515-.176l-2.731-2.1a11.429,11.429,0,0,1-1.8.741,32.016,32.016,0,0,1-.573,3.624A.668.668,0,0,1,17.392,29.929ZM15.2,9.976a4.938,4.938,0,0,0-3.582,1.463,4.935,4.935,0,0,0,0,7.053,5.12,5.12,0,0,0,7.163,0,4.932,4.932,0,0,0,0-7.053A4.938,4.938,0,0,0,15.2,9.976Z" transform="translate(118.47 8.521)" fill="#fff"/><path d="M0,33.5,16.106,7.374H2.752V0H30.9L14.887,26.122H38.22L0,33.5" transform="translate(0 11.038)" fill="#fff"/></g><path d="M3.576-12.852v-4.3H6.628a2.867,2.867,0,0,1,1.945.55A2.034,2.034,0,0,1,9.188-15a2.06,2.06,0,0,1-.615,1.608,2.784,2.784,0,0,1-1.945.542ZM2.017-18.464V-6.748H3.576v-4.792H7.153a3.569,3.569,0,0,0,2.683-.9A3.478,3.478,0,0,0,10.747-15a3.45,3.45,0,0,0-.911-2.552,3.638,3.638,0,0,0-2.683-.911Zm11.421,7.483a4.221,4.221,0,0,1,.205-1.37,2.957,2.957,0,0,1,.566-1.009,2.411,2.411,0,0,1,.845-.624A2.515,2.515,0,0,1,16.08-14.2a2.515,2.515,0,0,1,1.026.213,2.411,2.411,0,0,1,.845.624,2.957,2.957,0,0,1,.566,1.009,4.221,4.221,0,0,1,.205,1.37,4.221,4.221,0,0,1-.205,1.37,2.867,2.867,0,0,1-.566,1,2.457,2.457,0,0,1-.845.615,2.515,2.515,0,0,1-1.026.213,2.515,2.515,0,0,1-1.026-.213,2.457,2.457,0,0,1-.845-.615,2.867,2.867,0,0,1-.566-1A4.221,4.221,0,0,1,13.438-10.981Zm-1.477,0a5.573,5.573,0,0,0,.263,1.739,3.97,3.97,0,0,0,.788,1.4,3.623,3.623,0,0,0,1.3.935,4.4,4.4,0,0,0,1.772.336A4.381,4.381,0,0,0,17.86-6.9a3.641,3.641,0,0,0,1.288-.935,3.97,3.97,0,0,0,.788-1.4,5.573,5.573,0,0,0,.263-1.739,5.65,5.65,0,0,0-.263-1.748,3.96,3.96,0,0,0-.788-1.411,3.729,3.729,0,0,0-1.288-.944,4.29,4.29,0,0,0-1.78-.345,4.3,4.3,0,0,0-1.772.345,3.71,3.71,0,0,0-1.3.944,3.96,3.96,0,0,0-.788,1.411A5.65,5.65,0,0,0,11.961-10.981Zm18.28,4.234,2.708-8.484H31.5L29.6-8.29h-.033L27.8-15.231H26.27L24.564-8.29h-.033l-1.92-6.941H21.068l2.724,8.484H25.3l1.707-6.744h.033l1.723,6.744ZM40.169-11.8H35.3a2.905,2.905,0,0,1,.213-.927A2.473,2.473,0,0,1,36-13.492a2.255,2.255,0,0,1,.747-.517,2.429,2.429,0,0,1,.976-.189,2.386,2.386,0,0,1,.96.189,2.415,2.415,0,0,1,.755.509,2.391,2.391,0,0,1,.509.763A2.854,2.854,0,0,1,40.169-11.8Zm1.346,2.363H40.136a1.983,1.983,0,0,1-.747,1.247,2.414,2.414,0,0,1-1.452.41,2.889,2.889,0,0,1-1.2-.23,2.348,2.348,0,0,1-.837-.615,2.4,2.4,0,0,1-.476-.886,3.367,3.367,0,0,1-.131-1.058h6.35a6.754,6.754,0,0,0-.139-1.625,4.7,4.7,0,0,0-.624-1.575,3.716,3.716,0,0,0-1.2-1.19,3.48,3.48,0,0,0-1.879-.468,3.858,3.858,0,0,0-1.6.328,3.76,3.76,0,0,0-1.264.919,4.236,4.236,0,0,0-.829,1.395,5.105,5.105,0,0,0-.3,1.772,6.8,6.8,0,0,0,.287,1.789,3.9,3.9,0,0,0,.763,1.411,3.478,3.478,0,0,0,1.255.919,4.358,4.358,0,0,0,1.764.328,3.851,3.851,0,0,0,2.4-.722A3.39,3.39,0,0,0,41.515-9.439Zm1.526-5.793v8.484h1.395v-3.774a5.8,5.8,0,0,1,.164-1.452,2.784,2.784,0,0,1,.525-1.075,2.251,2.251,0,0,1,.952-.673,3.945,3.945,0,0,1,1.428-.23v-1.477a3.135,3.135,0,0,0-1.871.459,3.779,3.779,0,0,0-1.247,1.526h-.033v-1.789ZM54.15-11.8H49.276a2.905,2.905,0,0,1,.213-.927,2.473,2.473,0,0,1,.492-.763,2.255,2.255,0,0,1,.747-.517A2.429,2.429,0,0,1,51.7-14.2a2.386,2.386,0,0,1,.96.189,2.415,2.415,0,0,1,.755.509,2.391,2.391,0,0,1,.509.763A2.854,2.854,0,0,1,54.15-11.8ZM55.5-9.439H54.117a1.983,1.983,0,0,1-.747,1.247,2.414,2.414,0,0,1-1.452.41,2.889,2.889,0,0,1-1.2-.23,2.348,2.348,0,0,1-.837-.615,2.4,2.4,0,0,1-.476-.886,3.367,3.367,0,0,1-.131-1.058h6.35a6.754,6.754,0,0,0-.139-1.625,4.7,4.7,0,0,0-.624-1.575,3.716,3.716,0,0,0-1.2-1.19,3.48,3.48,0,0,0-1.879-.468,3.858,3.858,0,0,0-1.6.328,3.76,3.76,0,0,0-1.264.919,4.236,4.236,0,0,0-.829,1.395,5.1,5.1,0,0,0-.3,1.772,6.8,6.8,0,0,0,.287,1.789,3.9,3.9,0,0,0,.763,1.411,3.478,3.478,0,0,0,1.255.919,4.358,4.358,0,0,0,1.764.328,3.851,3.851,0,0,0,2.4-.722A3.39,3.39,0,0,0,55.5-9.439Zm2.593-1.477a5.581,5.581,0,0,1,.131-1.214,3.212,3.212,0,0,1,.427-1.05,2.221,2.221,0,0,1,.788-.738,2.4,2.4,0,0,1,1.2-.279,2.589,2.589,0,0,1,1.231.271,2.389,2.389,0,0,1,.829.714,2.985,2.985,0,0,1,.468,1.026,4.889,4.889,0,0,1,.148,1.206,4.919,4.919,0,0,1-.139,1.165,3.053,3.053,0,0,1-.451,1.026,2.4,2.4,0,0,1-.8.73,2.4,2.4,0,0,1-1.2.279,2.491,2.491,0,0,1-1.173-.263,2.332,2.332,0,0,1-.82-.706,3.122,3.122,0,0,1-.476-1.009A4.338,4.338,0,0,1,58.088-10.916Zm6.564,4.168V-18.464H63.257V-14.1h-.033a2.247,2.247,0,0,0-.566-.632,3.216,3.216,0,0,0-.714-.41,3.583,3.583,0,0,0-.755-.222,4.132,4.132,0,0,0-.706-.066,3.861,3.861,0,0,0-1.7.353,3.487,3.487,0,0,0-1.214.952,4.018,4.018,0,0,0-.722,1.4,5.985,5.985,0,0,0-.238,1.707,5.8,5.8,0,0,0,.246,1.707,4.218,4.218,0,0,0,.73,1.411,3.529,3.529,0,0,0,1.214.968,3.827,3.827,0,0,0,1.715.361,4.135,4.135,0,0,0,1.625-.312A2.053,2.053,0,0,0,63.224-7.9h.033v1.149Zm6.761-11.716V-6.748h1.395V-7.88h.033a2.247,2.247,0,0,0,.566.632,2.982,2.982,0,0,0,.714.4,3.874,3.874,0,0,0,.763.213,4.193,4.193,0,0,0,.7.066,3.94,3.94,0,0,0,1.7-.345,3.4,3.4,0,0,0,1.214-.944,4.018,4.018,0,0,0,.722-1.4,5.985,5.985,0,0,0,.238-1.707,5.8,5.8,0,0,0-.246-1.707,4.312,4.312,0,0,0-.73-1.419,3.488,3.488,0,0,0-1.214-.976,3.827,3.827,0,0,0-1.715-.361,4.043,4.043,0,0,0-1.625.32,2.088,2.088,0,0,0-1.083,1.026h-.033v-4.381Zm6.564,7.4a5.581,5.581,0,0,1-.131,1.214,3.212,3.212,0,0,1-.427,1.05,2.243,2.243,0,0,1-.779.738,2.385,2.385,0,0,1-1.206.279A2.589,2.589,0,0,1,74.2-8.052a2.389,2.389,0,0,1-.829-.714,2.985,2.985,0,0,1-.468-1.026A4.889,4.889,0,0,1,72.758-11a4.919,4.919,0,0,1,.139-1.165,3.053,3.053,0,0,1,.451-1.026,2.4,2.4,0,0,1,.8-.73,2.4,2.4,0,0,1,1.2-.279,2.491,2.491,0,0,1,1.173.263,2.332,2.332,0,0,1,.82.706,3.122,3.122,0,0,1,.476,1.009A4.338,4.338,0,0,1,77.976-11.063Zm6.449,5.448a8.871,8.871,0,0,1-.484,1.05,2.871,2.871,0,0,1-.525.7,1.782,1.782,0,0,1-.64.394,2.462,2.462,0,0,1-.812.123,3.721,3.721,0,0,1-.492-.033A2.324,2.324,0,0,1,81-3.5v-1.28a2.342,2.342,0,0,0,.418.139,1.765,1.765,0,0,0,.4.057,1.2,1.2,0,0,0,.714-.205,1.255,1.255,0,0,0,.435-.583L83.539-6.8l-3.364-8.434h1.575L84.228-8.29h.033l2.379-6.941h1.477Z" transform="translate(0.722 18.464)" fill="#fff"/></g></g></g></svg>`;

// node_modules/@zappar/zappar-cv/lib/imagetracker-previewmesh.js
function getPreviewMesh(info) {
  switch (info.type) {
    case image_target_type_t.IMAGE_TRACKER_TYPE_PLANAR:
      return planar(info);
    case image_target_type_t.IMAGE_TRACKER_TYPE_CYLINDRICAL:
      return cylindrical(info);
    case image_target_type_t.IMAGE_TRACKER_TYPE_CONICAL:
      return conical(info);
  }
  return defaultMesh();
}
function planar(info) {
  const aspectRatio = info.trainedWidth / info.trainedHeight;
  if (isNaN(aspectRatio))
    return defaultMesh();
  const scaling = info.physicalScaleFactor > 0 ? info.physicalScaleFactor : 1;
  const vertices = new Float32Array([
    -1 * aspectRatio * scaling,
    -1 * scaling,
    0,
    -1 * aspectRatio * scaling,
    scaling,
    0,
    aspectRatio * scaling,
    scaling,
    0,
    aspectRatio * scaling,
    -1 * scaling,
    0
  ]);
  const indices = new Uint16Array([0, 2, 1, 0, 3, 2]);
  const uvs = new Float32Array([
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    0
  ]);
  const normals = new Float32Array([
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1
  ]);
  return { vertices, indices, uvs, normals };
}
function defaultMesh() {
  return {
    indices: new Uint16Array(0),
    vertices: new Float32Array(0),
    normals: new Float32Array(0),
    uvs: new Float32Array(0)
  };
}
function cylindrical(info) {
  const wrap_amount = 2 * info.trainedWidth / (info.trainedHeight * info.topRadius);
  return generalConical(info, 2, false, 0, 0, 0, vec2_exports.create(), info.trainedWidth / info.trainedHeight, wrap_amount, info.physicalScaleFactor);
}
function conical(info) {
  const radius_diff = info.topRadius - info.bottomRadius;
  if (radius_diff === 0) {
    console.warn("Conical target has matching radii, using cylindrical preview mesh with a defined image size instead.");
    return cylindrical(info);
  }
  const height_3d = Math.sqrt(info.sideLength * info.sideLength - radius_diff * radius_diff);
  const flip = info.bottomRadius > info.topRadius;
  let aspect_ratio = info.trainedWidth / info.trainedHeight;
  if (isNaN(aspect_ratio))
    aspect_ratio = 1;
  const cone = !(info.bottomRadius > 0) || !(info.topRadius > 0);
  const wide = info.sideLength < 2 * Math.abs(info.topRadius - info.bottomRadius);
  const top_corner = vec2_exports.create();
  const bottom_corner = vec2_exports.create();
  const rotation_center = vec2_exports.create();
  if (cone) {
    if (wide) {
      if (flip) {
        rotation_center[1] = aspect_ratio - 1;
        const omega = Math.acos((2 - aspect_ratio) / aspect_ratio);
        top_corner[0] = aspect_ratio * Math.sin(omega);
        top_corner[1] = aspect_ratio - 1 + aspect_ratio * Math.cos(omega);
        vec2_exports.copy(bottom_corner, rotation_center);
      } else {
        rotation_center[1] = 1 - aspect_ratio;
        const omega = Math.PI + Math.acos((2 - aspect_ratio) / aspect_ratio);
        top_corner[0] = aspect_ratio * Math.sin(omega);
        top_corner[1] = 1 - aspect_ratio + aspect_ratio * Math.cos(omega);
        vec2_exports.copy(bottom_corner, rotation_center);
      }
    } else {
      if (flip) {
        rotation_center[1] = 1;
        vec2_exports.copy(bottom_corner, rotation_center);
        top_corner[0] = aspect_ratio;
        top_corner[1] = 1 - Math.sqrt(4 - Math.pow(aspect_ratio, 2));
      } else {
        rotation_center[1] = -1;
        vec2_exports.copy(bottom_corner, rotation_center);
        top_corner[0] = -aspect_ratio;
        top_corner[1] = Math.sqrt(4 - Math.pow(aspect_ratio, 2)) - 1;
      }
    }
  } else {
    if (wide) {
      if (flip) {
        rotation_center[1] = aspect_ratio - 1;
        const omega = Math.acos((2 - aspect_ratio) / aspect_ratio);
        top_corner[0] = aspect_ratio * Math.sin(omega);
        top_corner[1] = aspect_ratio - 1 + aspect_ratio * Math.cos(omega);
        bottom_corner[0] = (aspect_ratio - info.sideLength) * Math.sin(omega);
        bottom_corner[1] = aspect_ratio - 1 + (aspect_ratio - info.sideLength) * Math.cos(omega);
      } else {
        rotation_center[1] = 1 - aspect_ratio;
        const omega = Math.PI + Math.acos((2 - aspect_ratio) / aspect_ratio);
        top_corner[0] = aspect_ratio * Math.sin(omega);
        top_corner[1] = 1 - aspect_ratio + aspect_ratio * Math.cos(omega);
        bottom_corner[0] = (aspect_ratio - info.sideLength) * Math.sin(omega);
        bottom_corner[1] = 1 - aspect_ratio + (aspect_ratio - info.sideLength) * Math.cos(omega);
      }
    } else {
      const radius_ratio = flip ? info.topRadius / info.bottomRadius : info.bottomRadius / info.topRadius;
      if (flip) {
        bottom_corner[0] = radius_ratio * aspect_ratio;
        bottom_corner[1] = 1;
        top_corner[0] = aspect_ratio;
        top_corner[1] = 1 - Math.sqrt(info.sideLength * info.sideLength - (bottom_corner[0] - top_corner[0]) * (bottom_corner[0] - top_corner[0]));
        rotation_center[1] = top_corner[1] + top_corner[0] / (top_corner[0] - bottom_corner[0]) * (bottom_corner[1] - top_corner[1]);
      } else {
        bottom_corner[0] = -radius_ratio * aspect_ratio;
        bottom_corner[1] = -1;
        top_corner[0] = -aspect_ratio;
        top_corner[1] = Math.sqrt(info.sideLength * info.sideLength - (bottom_corner[0] - top_corner[0]) * (bottom_corner[0] - top_corner[0])) - 1;
        rotation_center[1] = top_corner[1] - -top_corner[0] / (bottom_corner[0] - top_corner[0]) * (top_corner[1] - bottom_corner[1]);
      }
    }
  }
  const top_from_center = vec2_exports.create();
  vec2_exports.subtract(top_from_center, top_corner, rotation_center);
  const bottom_from_center = vec2_exports.create();
  vec2_exports.subtract(bottom_from_center, bottom_corner, rotation_center);
  const top_2d_radius = vec2_exports.length(top_from_center);
  const bottom_2d_radius = vec2_exports.length(bottom_from_center);
  let max_angle = 2 * Math.abs(Math.atan(top_from_center[0] / top_from_center[1]));
  if (wide)
    max_angle = 2 * Math.PI - max_angle;
  let theta_3d = top_2d_radius * max_angle / info.topRadius;
  let theta = Math.abs(Math.atan(top_from_center[0] / top_from_center[1]));
  if (wide)
    theta = Math.PI - theta;
  return generalConical(info, height_3d, flip, theta, bottom_2d_radius, top_2d_radius, rotation_center, aspect_ratio, theta_3d, info.physicalScaleFactor);
}
function generalConical(info, height_3d, flip, theta, bottom_2d_radius, top_2d_radius, rotation_center, aspect_ratio, wrap_amount, psf) {
  if (isNaN(aspect_ratio))
    aspect_ratio = 1;
  const vertices = [];
  const uvs = [];
  const physical_scale = psf > 0 ? psf : 1;
  const scale_factor = physical_scale * 2 / height_3d;
  const subdivisons = 64;
  for (let s = 0; s <= subdivisons; ++s) {
    const angle3 = s * wrap_amount / subdivisons + (2 * Math.PI - wrap_amount) / 2;
    const bx = info.bottomRadius * Math.sin(angle3) * scale_factor;
    const bz = info.bottomRadius * Math.cos(angle3) * scale_factor;
    const tx = info.topRadius * Math.sin(angle3) * scale_factor;
    const tz = info.topRadius * Math.cos(angle3) * scale_factor;
    const btm = -1 * physical_scale;
    const top = physical_scale;
    if (flip) {
      vertices.push(bx, btm, bz);
      vertices.push(tx, top, tz);
    } else {
      vertices.push(tx, top, -tz);
      vertices.push(bx, btm, -bz);
    }
  }
  for (let s = 0; s <= subdivisons; ++s) {
    if (info.type == image_target_type_t.IMAGE_TRACKER_TYPE_CYLINDRICAL) {
      const offset = 1 - s / subdivisons;
      uvs.push(offset, 1);
      uvs.push(offset, 0);
    } else {
      let angle_2d = -(s / subdivisons - 0.5) * 2 * theta;
      if (flip) {
        angle_2d = -angle_2d + theta;
        if (angle_2d > theta)
          angle_2d = -theta + (angle_2d - theta);
      }
      const direction = vec2_exports.create();
      direction[0] = Math.sin(angle_2d);
      direction[1] = Math.cos(angle_2d);
      if (flip)
        direction[1] *= -1;
      const bottom_px = vec2_exports.create();
      vec2_exports.copy(bottom_px, direction);
      vec2_exports.scale(bottom_px, bottom_px, bottom_2d_radius);
      vec2_exports.add(bottom_px, rotation_center, bottom_px);
      const top_px = vec2_exports.create();
      vec2_exports.copy(top_px, direction);
      vec2_exports.scale(top_px, top_px, top_2d_radius);
      vec2_exports.add(top_px, rotation_center, top_px);
      uvs.push((top_px[0] + aspect_ratio) / (2 * aspect_ratio), 1 - (-top_px[1] + 1) / 2);
      uvs.push((bottom_px[0] + aspect_ratio) / (2 * aspect_ratio), 1 - (-bottom_px[1] + 1) / 2);
    }
  }
  const indices = [];
  for (let i = 0; i < subdivisons; ++i) {
    const bi = i * 2;
    indices.push(bi + 1, bi + 2, bi + 3);
    indices.push(bi + 0, bi + 2, bi + 1);
  }
  return {
    vertices: new Float32Array(vertices),
    indices: new Uint16Array(indices),
    normals: new Float32Array(0),
    uvs: new Float32Array(uvs)
  };
}

// node_modules/@zappar/zappar-cv/lib/riff-reader.js
var decoder = new TextDecoder();
var RiffReader = class {
  constructor(_data, _paddingBytes = false) {
    this._data = _data;
    this._paddingBytes = _paddingBytes;
    this.truncatedChunks = false;
    this._view = new DataView(this._data);
    this.root = this._parse();
  }
  _parse() {
    const header = decoder.decode(this._data.slice(0, 4));
    if (header !== "RIFF")
      throw new Error("Not a valid ZPT file");
    return this._parseChunk(0);
  }
  _parseChunk(offset) {
    const ident = decoder.decode(this._data.slice(offset, offset + 4));
    const length5 = this._view.getUint32(offset + 4, true);
    const data = new Uint8Array(this._data, offset + 8, length5);
    if (data.byteLength !== length5)
      this.truncatedChunks = true;
    let subchunks;
    let subident;
    if (ident === "RIFF" || ident === "LIST") {
      subident = decoder.decode(this._data.slice(offset + 8, offset + 12));
      subchunks = [];
      let currentOffset = 4;
      while (currentOffset < data.byteLength - 1) {
        const subchunk = this._parseChunk(offset + 8 + currentOffset);
        subchunks.push(subchunk);
        currentOffset += subchunk.data.byteLength + 8;
        if (this._paddingBytes && subchunk.data.byteLength & 1)
          currentOffset++;
      }
    }
    return { ident, data, subident, subchunks };
  }
  find(str4, inChunk = this.root) {
    if (inChunk.ident === str4)
      return inChunk;
    if (!inChunk.subchunks)
      return;
    for (let c of inChunk.subchunks) {
      const found = this.find(str4, c);
      if (found)
        return found;
    }
  }
  has(str4) {
    return this.find(str4) !== void 0;
  }
};

// node_modules/@zappar/zappar-cv/lib/imagetracker.js
var byId5 = /* @__PURE__ */ new Map();
var decoder2 = new TextDecoder();
var ImageTracker = class _ImageTracker {
  constructor(_client, _impl) {
    this._client = _client;
    this._impl = _impl;
    this._targets = [];
  }
  static create(pipeline, client2) {
    let ret = client2.image_tracker_create(pipeline);
    byId5.set(ret, new _ImageTracker(client2, ret));
    return ret;
  }
  static get(p) {
    return byId5.get(p);
  }
  destroy() {
    this._client.image_tracker_destroy(this._impl);
    byId5.delete(this._impl);
  }
  loadFromMemory(data) {
    this._targets.push({ data });
    this._client.image_tracker_target_load_from_memory(this._impl, data);
  }
  targetCount() {
    return this._targets.length;
  }
  getTargetInfo(i) {
    let current = this._targets[i];
    if (current && current.info)
      return current.info;
    current.info = {
      topRadius: -1,
      bottomRadius: -1,
      sideLength: -1,
      physicalScaleFactor: -1,
      trainedWidth: 0,
      trainedHeight: 0,
      type: image_target_type_t.IMAGE_TRACKER_TYPE_PLANAR
    };
    try {
      const reader = new RiffReader(current.data, false);
      const imgChunk = reader.find("IMG ");
      if (imgChunk) {
        let mimeType = "image/png";
        const mimeTypeChunk = reader.find("IMGM");
        if (mimeTypeChunk)
          mimeType = decoder2.decode(mimeTypeChunk.data);
        current.info.preview = { mimeType, compressed: imgChunk.data };
      }
      const odleChunk = reader.find("ODLE");
      if (odleChunk) {
        const odle = decoder2.decode(odleChunk.data);
        this._parseOdle(odle, current.info);
      }
    } catch (err) {
    }
    return current.info;
  }
  _parseOdle(data, info) {
    let currentOffset = 0;
    let version = "0";
    [version, currentOffset] = readLine(currentOffset, data);
    if (version === "1")
      return this._parseOdleV1(data, currentOffset, info);
    else if (version === "3")
      return this._parseOdleV3(data, currentOffset, info);
  }
  _parseOdleV1(data, currentOffset, info) {
    let treeOrFlat = "0";
    [treeOrFlat, currentOffset] = readLine(currentOffset, data);
    if (treeOrFlat !== "0" && treeOrFlat !== "1")
      return;
    let emptyLine = "";
    [emptyLine, currentOffset] = readLine(currentOffset, data);
    if (emptyLine.length !== 0)
      return;
    let infoLine = "";
    [infoLine, currentOffset] = readLine(currentOffset, data);
    const infoLineParts = infoLine.split(" ");
    if (infoLineParts.length < 5)
      return;
    info.trainedWidth = parseInt(infoLineParts[3].replace("[", ""));
    info.trainedHeight = parseInt(infoLineParts[4].replace("]", ""));
  }
  _parseOdleV3(data, currentOffset, info) {
    let treeOrFlat = "0";
    [treeOrFlat, currentOffset] = readLine(currentOffset, data);
    if (treeOrFlat !== "0" && treeOrFlat !== "1")
      return;
    let numberTargets = "0";
    [numberTargets, currentOffset] = readLine(currentOffset, data);
    const parsedTargets = parseInt(numberTargets);
    if (isNaN(parsedTargets) || parsedTargets < 1)
      return;
    let emptyLine = "";
    [emptyLine, currentOffset] = readLine(currentOffset, data);
    if (emptyLine.length !== 0)
      return;
    let infoLine = "";
    [infoLine, currentOffset] = readLine(currentOffset, data);
    const infoLineParts = infoLine.split(" ");
    if (infoLineParts.length < 6)
      return;
    const targetType = parseInt(infoLineParts[0]);
    if (targetType === 0 || targetType === 1 || targetType === 2)
      info.type = targetType;
    info.trainedWidth = parseInt(infoLineParts[4].replace("[", ""));
    info.trainedHeight = parseInt(infoLineParts[5].replace("]", ""));
    if (infoLineParts.length >= 7) {
      info.physicalScaleFactor = parseFloat(infoLineParts[6]);
      if (isNaN(info.physicalScaleFactor))
        info.physicalScaleFactor = -1;
    }
    if (infoLineParts.length >= 8) {
      info.topRadius = parseFloat(infoLineParts[7]);
      if (isNaN(info.topRadius))
        info.topRadius = -1;
      info.bottomRadius = info.topRadius;
    }
    if (infoLineParts.length >= 9) {
      info.bottomRadius = parseFloat(infoLineParts[8]);
      if (isNaN(info.bottomRadius))
        info.bottomRadius = -1;
    }
    if (infoLineParts.length >= 10) {
      info.sideLength = parseFloat(infoLineParts[9]);
      if (isNaN(info.sideLength))
        info.sideLength = -1;
    }
  }
  getDecodedPreview(i) {
    const info = this.getTargetInfo(i);
    if (!info.preview)
      return void 0;
    if (!info.preview.image) {
      const blob = new Blob([info.preview.compressed], { type: info.preview.mimeType });
      info.preview.image = new Image();
      info.preview.image.src = URL.createObjectURL(blob);
    }
    return info.preview.image;
  }
  getPreviewMesh(i) {
    const info = this.getTargetInfo(i);
    if (!info.previewMesh)
      info.previewMesh = getPreviewMesh(info);
    return info.previewMesh;
  }
};
function readLine(offset, str4) {
  let indx = str4.indexOf("\n", offset);
  return [str4.substring(offset, indx >= 0 ? indx : void 0).replace("\r", ""), indx + 1];
}

// node_modules/@zappar/zappar-cv/lib/native.js
var __awaiter6 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var client;
function initialize(opts) {
  if (client)
    return client;
  let loaded2 = false;
  launchWorker(opts === null || opts === void 0 ? void 0 : opts.worker).then(() => {
    zcout("Fully loaded");
    loaded2 = true;
  });
  let c = new zappar_client((ab) => {
    messageManager.postOutgoingMessage({
      t: "zappar",
      d: ab
    }, [ab]);
  });
  const uid = getUID();
  let hasPersistedUID = false;
  let hasSetID = false;
  try {
    const cookies = Object.fromEntries(document.cookie.split("; ").map((v) => v.split(/=(.*)/s).map(decodeURIComponent)));
    if (cookies["zw-uar-project"]) {
      const parsed = JSON.parse(cookies["zw-uar-project"]);
      if (typeof parsed === "object" && typeof parsed["id"] === "string") {
        c.impl.analytics_project_id_set(".wiz" + parsed["id"], uid);
        hasSetID = true;
      }
    }
  } catch (err) {
  }
  if (!hasSetID) {
    if (window.location.hostname.toLowerCase().indexOf(".zappar.io") > 0 || window.location.hostname.toLowerCase().indexOf(".webar.run") > 0 || window.location.hostname.toLowerCase().indexOf(".arweb.app") > 0 || window.location.hostname.toLowerCase().indexOf(".zappar-us.io") > 0 || window.location.hostname.toLowerCase().indexOf(".zappar-eu.io") > 0) {
      let pathParts = window.location.pathname.split("/");
      if (pathParts.length > 1 && pathParts[1].length > 0) {
        c.impl.analytics_project_id_set(".wiz" + pathParts[1], uid);
        hasSetID = true;
      }
    }
  }
  messageManager.onIncomingMessage.bind((msg) => {
    var _a, _b, _c, _d, _e, _f, _g;
    switch (msg.t) {
      case "zappar":
        (_a = Pipeline.get(msg.p)) === null || _a === void 0 ? void 0 : _a.pendingMessages.push(msg.d);
        break;
      case "buf":
        c.serializer.bufferReturn(msg.d);
        break;
      case "cameraFrameRecycleS2C": {
        let msgt = msg;
        (_c = (_b = Pipeline.get(msgt.p)) === null || _b === void 0 ? void 0 : _b.cameraTokenReturn) === null || _c === void 0 ? void 0 : _c.call(_b, msg);
        break;
      }
      case "videoFrameS2C": {
        let msgt = msg;
        (_e = (_d = Pipeline.get(msgt.p)) === null || _d === void 0 ? void 0 : _d.videoFrameFromWorker) === null || _e === void 0 ? void 0 : _e.call(_d, msgt);
        break;
      }
      case "imageBitmapS2C": {
        let msgt = msg;
        (_g = (_f = Pipeline.get(msgt.p)) === null || _f === void 0 ? void 0 : _f.imageBitmapFromWorker) === null || _g === void 0 ? void 0 : _g.call(_f, msgt);
        break;
      }
      case "licerr": {
        let div3 = document.createElement("div");
        div3.innerHTML = "Visit <a href='https://docs.zap.works/universal-ar/licensing/' style='color: white;'>our licensing page</a> to find out about hosting on your own domain.";
        div3.style.position = "absolute";
        div3.style.bottom = "20px";
        div3.style.width = "80%";
        div3.style.backgroundColor = "black";
        div3.style.color = "white";
        div3.style.borderRadius = "10px";
        div3.style.padding = "10px";
        div3.style.fontFamily = "sans-serif";
        div3.style.textAlign = "center";
        div3.style.left = "10%";
        div3.style.zIndex = Number.MAX_SAFE_INTEGER.toString();
        let span = document.createElement("span");
        span.innerText = " (30)";
        div3.append(span);
        let indx = 30;
        setInterval(function() {
          indx--;
          if (indx >= 0)
            span.innerText = " (" + indx.toString() + ")";
        }, 1e3);
        document.body.append(div3);
      }
      case "gfx": {
        let div3 = document.createElement("div");
        div3.innerHTML = gfx;
        div3.style.position = "absolute";
        div3.style.bottom = "20px";
        div3.style.width = "250px";
        div3.style.left = "50%";
        div3.style.marginLeft = "-125px";
        div3.style.zIndex = Number.MAX_SAFE_INTEGER.toString();
        div3.style.opacity = "0";
        div3.style.transition = "opacity 0.5s";
        document.body.append(div3);
        setTimeout(function() {
          div3.style.opacity = "1";
        }, 500);
        setTimeout(function() {
          div3.style.opacity = "0";
        }, 3e3);
        setTimeout(function() {
          div3.remove();
        }, 4e3);
      }
    }
  });
  client = Object.assign(Object.assign({}, c.impl), { loaded: () => loaded2, camera_default_device_id: (userFacing) => userFacing ? CameraSource.USER_DEFAULT_DEVICE_ID : CameraSource.DEFAULT_DEVICE_ID, camera_source_create: (p, deviceId) => createCameraSource(p, deviceId), camera_source_destroy: (cam) => {
    var _a;
    return (_a = getCameraSource(cam)) === null || _a === void 0 ? void 0 : _a.destroy();
  }, camera_source_pause: (cam) => {
    var _a;
    return (_a = getCameraSource(cam)) === null || _a === void 0 ? void 0 : _a.pause();
  }, camera_source_start: (cam) => {
    var _a;
    return (_a = getCameraSource(cam)) === null || _a === void 0 ? void 0 : _a.start();
  }, camera_count: () => 2, camera_id: (indx) => indx === 0 ? CameraSource.DEFAULT_DEVICE_ID : CameraSource.USER_DEFAULT_DEVICE_ID, camera_name: (indx) => indx === 0 ? "Rear-facing Camera" : "User-facing Camera", camera_user_facing: (indx) => indx !== 0, pipeline_create: () => Pipeline.create(c.impl, messageManager), pipeline_frame_update: (p) => {
    var _a;
    return (_a = Pipeline.get(p)) === null || _a === void 0 ? void 0 : _a.frameUpdate(c);
  }, pipeline_camera_frame_draw_gl: (pipeline, screenWidth, screenHeight, mirror) => {
    var _a;
    (_a = Pipeline.get(pipeline)) === null || _a === void 0 ? void 0 : _a.cameraFrameDrawGL(screenWidth, screenHeight, mirror);
  }, draw_plane: (gl, projectionMatrix2, cameraMatrix, targetMatrix, texture) => {
    drawPlane(gl, projectionMatrix2, cameraMatrix, targetMatrix, texture);
  }, pipeline_draw_face: (p, projectionMatrix2, cameraMatrix, targetMatrix, o) => {
    var _a;
    let obj = getFaceMesh(o);
    if (!obj) {
      zcwarn("attempting to call draw_face on a destroyed zappar_face_mesh_t");
      return new Uint16Array();
    }
    (_a = Pipeline.get(p)) === null || _a === void 0 ? void 0 : _a.drawFace(projectionMatrix2, cameraMatrix, targetMatrix, obj);
  }, pipeline_draw_face_project: (p, matrix, vertices, uvMatrix, uvs, indices, texture) => {
    var _a;
    (_a = Pipeline.get(p)) === null || _a === void 0 ? void 0 : _a.drawFaceProject(matrix, vertices, uvMatrix, uvs, indices, texture);
  }, pipeline_draw_image_target_preview: (p, projectionMatrix2, cameraMatrix, targetMatrix, o, indx) => {
    var _a;
    let obj = ImageTracker.get(o);
    if (!obj) {
      zcwarn("image tracker not found");
      return;
    }
    (_a = Pipeline.get(p)) === null || _a === void 0 ? void 0 : _a.drawImageTargetPreview(projectionMatrix2, cameraMatrix, targetMatrix, indx, obj);
  }, projection_matrix_from_camera_model: projectionMatrix, projection_matrix_from_camera_model_ext: projectionMatrix, pipeline_process_gl: (p) => {
    var _a;
    return (_a = Pipeline.get(p)) === null || _a === void 0 ? void 0 : _a.processGL();
  }, pipeline_gl_context_set: (p, gl, texturePool) => {
    var _a;
    return (_a = Pipeline.get(p)) === null || _a === void 0 ? void 0 : _a.glContextSet(gl, texturePool);
  }, pipeline_gl_context_lost: (p) => {
    var _a;
    return (_a = Pipeline.get(p)) === null || _a === void 0 ? void 0 : _a.glContextLost();
  }, pipeline_camera_frame_upload_gl: (p) => {
    var _a;
    return (_a = Pipeline.get(p)) === null || _a === void 0 ? void 0 : _a.uploadGL();
  }, pipeline_camera_frame_texture_gl: (p) => {
    var _a;
    return (_a = Pipeline.get(p)) === null || _a === void 0 ? void 0 : _a.cameraFrameTexture();
  }, pipeline_camera_frame_texture_matrix: (p, sw, sh, mirror) => {
    var _a;
    return ((_a = Pipeline.get(p)) === null || _a === void 0 ? void 0 : _a.cameraFrameTextureMatrix(sw, sh, mirror)) || mat4_exports.create();
  }, pipeline_camera_frame_user_facing: (p) => {
    var _a;
    return ((_a = Pipeline.get(p)) === null || _a === void 0 ? void 0 : _a.cameraFrameUserFacing()) || false;
  }, pipeline_camera_pose_default: () => mat4_exports.create(), pipeline_camera_pose_with_attitude: (p, mirror) => {
    var _a;
    return ((_a = Pipeline.get(p)) === null || _a === void 0 ? void 0 : _a.cameraPoseWithAttitude(mirror)) || mat4_exports.create();
  }, pipeline_camera_pose_with_origin: (p, o) => {
    let res = mat4_exports.create();
    mat4_exports.invert(res, o);
    return res;
  }, pipeline_sequence_record_clear: (p) => {
    var _a;
    return (_a = Pipeline.get(p)) === null || _a === void 0 ? void 0 : _a.sequenceRecordClear();
  }, pipeline_sequence_record_start: (p, expectedFrames) => {
    var _a;
    return (_a = Pipeline.get(p)) === null || _a === void 0 ? void 0 : _a.sequenceRecordStart(expectedFrames);
  }, pipeline_sequence_record_stop: (p) => {
    var _a;
    return (_a = Pipeline.get(p)) === null || _a === void 0 ? void 0 : _a.sequenceRecordStop();
  }, pipeline_sequence_record_device_attitude_matrices_set: (p, v) => {
    var _a;
    return (_a = Pipeline.get(p)) === null || _a === void 0 ? void 0 : _a.sequenceRecordDeviceAttitudeMatrices(v);
  }, pipeline_sequence_record_data: (p) => {
    var _a;
    return ((_a = Pipeline.get(p)) === null || _a === void 0 ? void 0 : _a.sequenceRecordData()) || new Uint8Array(0);
  }, pipeline_sequence_record_data_size: (p) => {
    var _a;
    return ((_a = Pipeline.get(p)) === null || _a === void 0 ? void 0 : _a.sequenceRecordData().byteLength) || 0;
  }, instant_world_tracker_anchor_pose_camera_relative: (o, mirror) => {
    let res = applyScreenCounterRotation(void 0, c.impl.instant_world_tracker_anchor_pose_raw(o));
    if (mirror) {
      let scale5 = mat4_exports.create();
      mat4_exports.fromScaling(scale5, [-1, 1, 1]);
      mat4_exports.multiply(res, scale5, res);
      mat4_exports.multiply(res, res, scale5);
    }
    return res;
  }, instant_world_tracker_anchor_pose: (o, cameraPose, mirror) => {
    let res = applyScreenCounterRotation(void 0, c.impl.instant_world_tracker_anchor_pose_raw(o));
    if (mirror) {
      let scale5 = mat4_exports.create();
      mat4_exports.fromScaling(scale5, [-1, 1, 1]);
      mat4_exports.multiply(res, scale5, res);
      mat4_exports.multiply(res, res, scale5);
    }
    mat4_exports.multiply(res, cameraPose, res);
    return res;
  }, instant_world_tracker_anchor_pose_set_from_camera_offset: (o, x, y, z2, orientation) => {
    let userFacing = false;
    let rotation = cameraRotationForScreenOrientation(userFacing) * Math.PI / 180;
    let rotationMat = mat4_exports.create();
    mat4_exports.fromRotation(rotationMat, -rotation, [0, 0, 1]);
    let rawVec = vec3_exports.create();
    vec3_exports.transformMat4(rawVec, [x, y, z2], rotationMat);
    c.impl.instant_world_tracker_anchor_pose_set_from_camera_offset_raw(o, rawVec[0], rawVec[1], rawVec[2], orientation);
  }, image_tracker_create: (pipeline) => ImageTracker.create(pipeline, c.impl), image_tracker_destroy: (t) => {
    var _a;
    return (_a = ImageTracker.get(t)) === null || _a === void 0 ? void 0 : _a.destroy();
  }, image_tracker_target_type: (t, i) => {
    let obj = ImageTracker.get(t);
    if (!obj) {
      zcwarn("attempting to call image_tracker_target_type on a destroyed zappar_image_tracker_t");
      return image_target_type_t.IMAGE_TRACKER_TYPE_PLANAR;
    }
    return obj.getTargetInfo(i).type;
  }, image_tracker_target_count: (t) => {
    let obj = ImageTracker.get(t);
    if (!obj) {
      zcwarn("attempting to call image_tracker_target_count on a destroyed zappar_image_tracker_t");
      return 0;
    }
    return obj.targetCount();
  }, image_tracker_target_load_from_memory: (t, data) => {
    let obj = ImageTracker.get(t);
    if (!obj) {
      zcwarn("attempting to call image_tracker_target_load_from_memory on a destroyed zappar_image_tracker_t");
      return 0;
    }
    obj.loadFromMemory(data);
  }, image_tracker_target_preview_compressed: (t, i) => {
    var _a;
    let obj = ImageTracker.get(t);
    if (!obj) {
      zcwarn("attempting to call image_tracker_target_preview_compressed on a destroyed zappar_image_tracker_t");
      return new Uint8Array(0);
    }
    return ((_a = obj.getTargetInfo(i).preview) === null || _a === void 0 ? void 0 : _a.compressed) || new Uint8Array(0);
  }, image_tracker_target_preview_compressed_mimetype: (t, i) => {
    var _a;
    let obj = ImageTracker.get(t);
    if (!obj) {
      zcwarn("attempting to call image_tracker_target_preview_compressed_mimetype on a destroyed zappar_image_tracker_t");
      return "";
    }
    return ((_a = obj.getTargetInfo(i).preview) === null || _a === void 0 ? void 0 : _a.mimeType) || "";
  }, image_tracker_target_preview_compressed_size: (t, i) => {
    var _a, _b;
    let obj = ImageTracker.get(t);
    if (!obj) {
      zcwarn("attempting to call image_tracker_target_preview_compressed_size on a destroyed zappar_image_tracker_t");
      return 0;
    }
    return ((_b = (_a = obj.getTargetInfo(i).preview) === null || _a === void 0 ? void 0 : _a.compressed) === null || _b === void 0 ? void 0 : _b.byteLength) || 0;
  }, image_tracker_target_physical_scale_factor: (t, i) => {
    let obj = ImageTracker.get(t);
    if (!obj) {
      zcwarn("attempting to call image_tracker_target_physical_scale_factor on a destroyed zappar_image_tracker_t");
      return 0;
    }
    return obj.getTargetInfo(i).physicalScaleFactor;
  }, image_tracker_target_radius_top: (t, i) => {
    let obj = ImageTracker.get(t);
    if (!obj) {
      zcwarn("attempting to call image_tracker_target_radius_top on a destroyed zappar_image_tracker_t");
      return 0;
    }
    return obj.getTargetInfo(i).topRadius;
  }, image_tracker_target_radius_bottom: (t, i) => {
    let obj = ImageTracker.get(t);
    if (!obj) {
      zcwarn("attempting to call image_tracker_target_radius_bottom on a destroyed zappar_image_tracker_t");
      return 0;
    }
    return obj.getTargetInfo(i).bottomRadius;
  }, image_tracker_target_side_length: (t, i) => {
    let obj = ImageTracker.get(t);
    if (!obj) {
      zcwarn("attempting to call image_tracker_target_side_length on a destroyed zappar_image_tracker_t");
      return 0;
    }
    return obj.getTargetInfo(i).sideLength;
  }, image_tracker_target_image: (t, i) => {
    let obj = ImageTracker.get(t);
    if (!obj) {
      zcwarn("attempting to call image_tracker_target_image on a destroyed zappar_image_tracker_t");
      return new Image();
    }
    return obj.getDecodedPreview(i);
  }, image_tracker_anchor_pose_camera_relative: (o, indx, mirror) => {
    let res = applyScreenCounterRotation(void 0, c.impl.image_tracker_anchor_pose_raw(o, indx));
    if (mirror) {
      let scale5 = mat4_exports.create();
      mat4_exports.fromScaling(scale5, [-1, 1, 1]);
      mat4_exports.multiply(res, scale5, res);
      mat4_exports.multiply(res, res, scale5);
    }
    return res;
  }, image_tracker_anchor_pose: (o, indx, cameraPose, mirror) => {
    let res = applyScreenCounterRotation(void 0, c.impl.image_tracker_anchor_pose_raw(o, indx));
    if (mirror) {
      let scale5 = mat4_exports.create();
      mat4_exports.fromScaling(scale5, [-1, 1, 1]);
      mat4_exports.multiply(res, scale5, res);
      mat4_exports.multiply(res, res, scale5);
    }
    mat4_exports.multiply(res, cameraPose, res);
    return res;
  }, image_tracker_target_preview_mesh_indices: (o, indx) => {
    let obj = ImageTracker.get(o);
    if (!obj) {
      zcwarn("attempting to call image_tracker_target_preview_mesh_indices on a destroyed zappar_image_tracker_t");
      return new Uint16Array();
    }
    return obj.getPreviewMesh(indx).indices;
  }, image_tracker_target_preview_mesh_vertices: (o, indx) => {
    let obj = ImageTracker.get(o);
    if (!obj) {
      zcwarn("attempting to call image_tracker_target_preview_mesh_vertices on a destroyed zappar_image_tracker_t");
      return new Float32Array();
    }
    return obj.getPreviewMesh(indx).vertices;
  }, image_tracker_target_preview_mesh_uvs: (o, indx) => {
    let obj = ImageTracker.get(o);
    if (!obj) {
      zcwarn("attempting to call image_tracker_target_preview_mesh_uvs on a destroyed zappar_image_tracker_t");
      return new Float32Array();
    }
    return obj.getPreviewMesh(indx).uvs;
  }, image_tracker_target_preview_mesh_normals: (o, indx) => {
    let obj = ImageTracker.get(o);
    if (!obj) {
      zcwarn("attempting to call image_tracker_target_preview_mesh_normals on a destroyed zappar_image_tracker_t");
      return new Float32Array();
    }
    return obj.getPreviewMesh(indx).normals;
  }, image_tracker_target_preview_mesh_indices_size: (o, indx) => {
    let obj = ImageTracker.get(o);
    if (!obj) {
      zcwarn("attempting to call image_tracker_target_preview_mesh_indices_size on a destroyed zappar_image_tracker_t");
      return 0;
    }
    return obj.getPreviewMesh(indx).indices.length;
  }, image_tracker_target_preview_mesh_vertices_size: (o, indx) => {
    let obj = ImageTracker.get(o);
    if (!obj) {
      zcwarn("attempting to call image_tracker_target_preview_mesh_vertices_size on a destroyed zappar_image_tracker_t");
      return 0;
    }
    return obj.getPreviewMesh(indx).vertices.length;
  }, image_tracker_target_preview_mesh_uvs_size: (o, indx) => {
    let obj = ImageTracker.get(o);
    if (!obj) {
      zcwarn("attempting to call image_tracker_target_preview_mesh_uvs_size on a destroyed zappar_image_tracker_t");
      return 0;
    }
    return obj.getPreviewMesh(indx).uvs.length;
  }, image_tracker_target_preview_mesh_normals_size: (o, indx) => {
    let obj = ImageTracker.get(o);
    if (!obj) {
      zcwarn("attempting to call image_tracker_target_preview_mesh_normals_size on a destroyed zappar_image_tracker_t");
      return 0;
    }
    return obj.getPreviewMesh(indx).normals.length;
  }, face_tracker_anchor_pose_camera_relative: (o, indx, mirror) => {
    let res = applyScreenCounterRotation(void 0, c.impl.face_tracker_anchor_pose_raw(o, indx));
    if (mirror) {
      let scale5 = mat4_exports.create();
      mat4_exports.fromScaling(scale5, [-1, 1, 1]);
      mat4_exports.multiply(res, scale5, res);
      mat4_exports.multiply(res, res, scale5);
    }
    return res;
  }, face_tracker_anchor_pose: (o, indx, cameraPose, mirror) => {
    let res = applyScreenCounterRotation(void 0, c.impl.face_tracker_anchor_pose_raw(o, indx));
    if (mirror) {
      let scale5 = mat4_exports.create();
      mat4_exports.fromScaling(scale5, [-1, 1, 1]);
      mat4_exports.multiply(res, scale5, res);
      mat4_exports.multiply(res, res, scale5);
    }
    mat4_exports.multiply(res, cameraPose, res);
    return res;
  }, face_tracker_model_load_default: (o) => __awaiter6(this, void 0, void 0, function* () {
    yield loadDefaultFaceModel(o);
  }), face_mesh_create: () => {
    return createFaceMesh();
  }, face_mesh_destroy: (m) => {
    destroyFaceMesh(m);
  }, face_mesh_indices: (m) => {
    let obj = getFaceMesh(m);
    if (!obj) {
      zcwarn("attempting to call face_mesh_indices on a destroyed zappar_face_mesh_t");
      return new Uint16Array();
    }
    return obj.getIndices();
  }, face_mesh_indices_size: (m) => {
    let obj = getFaceMesh(m);
    if (!obj) {
      zcwarn("attempting to call face_mesh_indices_size on a destroyed zappar_face_mesh_t");
      return 0;
    }
    return obj.getIndices().length;
  }, face_mesh_uvs: (m) => {
    let obj = getFaceMesh(m);
    if (!obj) {
      zcwarn("attempting to call face_mesh_uvs on a destroyed zappar_face_mesh_t");
      return new Float32Array();
    }
    return obj.getUVs();
  }, face_mesh_uvs_size: (m) => {
    let obj = getFaceMesh(m);
    if (!obj) {
      zcwarn("attempting to call face_mesh_uvs_size on a destroyed zappar_face_mesh_t");
      return 0;
    }
    return obj.getUVs().length;
  }, face_mesh_vertices: (m) => {
    let obj = getFaceMesh(m);
    if (!obj) {
      zcwarn("attempting to call face_mesh_vertices on a destroyed zappar_face_mesh_t");
      return new Float32Array();
    }
    return obj.getVertices();
  }, face_mesh_vertices_size: (m) => {
    let obj = getFaceMesh(m);
    if (!obj) {
      zcwarn("attempting to call face_mesh_vertices_size on a destroyed zappar_face_mesh_t");
      return 0;
    }
    return obj.getVertices().length;
  }, face_mesh_normals: (m) => {
    let obj = getFaceMesh(m);
    if (!obj) {
      zcwarn("attempting to call face_mesh_normals on a destroyed zappar_face_mesh_t");
      return new Float32Array();
    }
    return obj.getNormals();
  }, face_mesh_normals_size: (m) => {
    let obj = getFaceMesh(m);
    if (!obj) {
      zcwarn("attempting to call face_mesh_normals_size on a destroyed zappar_face_mesh_t");
      return 0;
    }
    return obj.getNormals().length;
  }, face_mesh_load_from_memory: (m, ab, fillMouth, fillEyeL, fillEyeR, fillNeck) => {
    let obj = getFaceMesh(m);
    if (!obj) {
      zcwarn("attempting to call face_mesh_load_from_memory on a destroyed zappar_face_mesh_t");
      return;
    }
    obj.loadFromMemory(ab, fillMouth, fillEyeL, fillEyeR, fillNeck);
  }, face_mesh_update: (m, identity4, expression, mirrored) => {
    let obj = getFaceMesh(m);
    if (!obj) {
      zcwarn("attempting to call face_mesh_update on a destroyed zappar_face_mesh_t");
      return;
    }
    obj.update(identity4, expression, mirrored);
  }, face_mesh_load_default: (m) => __awaiter6(this, void 0, void 0, function* () {
    let obj = getFaceMesh(m);
    if (!obj) {
      zcwarn("attempting to call face_mesh_load_default on a destroyed zappar_face_mesh_t");
      return;
    }
    let url = new URL("./face_mesh_face_model.zbin", import.meta.url);
    let req = yield fetch(url.toString());
    obj.loadFromMemory(yield req.arrayBuffer(), false, false, false, false);
  }), face_mesh_load_default_face: (m, fillMouth, fillEyeL, fillEyeR) => __awaiter6(this, void 0, void 0, function* () {
    let obj = getFaceMesh(m);
    if (!obj) {
      zcwarn("attempting to call face_mesh_load_default_face on a destroyed zappar_face_mesh_t");
      return;
    }
    let url = new URL("./face_mesh_face_model.zbin", import.meta.url);
    let req = yield fetch(url.toString());
    obj.loadFromMemory(yield req.arrayBuffer(), fillMouth, fillEyeL, fillEyeR, false);
  }), face_mesh_load_default_full_head_simplified: (m, fillMouth, fillEyeL, fillEyeR, fillNeck) => __awaiter6(this, void 0, void 0, function* () {
    let obj = getFaceMesh(m);
    if (!obj) {
      zcwarn("attempting to call face_mesh_load_default_full_head_simplified on a destroyed zappar_face_mesh_t");
      return;
    }
    let url = new URL("./face_mesh_full_head_simplified_model.zbin", import.meta.url);
    let req = yield fetch(url.toString());
    obj.loadFromMemory(yield req.arrayBuffer(), fillMouth, fillEyeL, fillEyeR, fillNeck);
  }), face_mesh_loaded_version: (m) => {
    let obj = getFaceMesh(m);
    if (!obj) {
      zcwarn("attempting to call face_mesh_load_default on a destroyed zappar_face_mesh_t");
      return -1;
    }
    return obj.getModelVersion();
  }, face_landmark_create: (n) => {
    return createFaceLandmark(n);
  }, face_landmark_destroy: (m) => {
    destroyFaceLandmark(m);
  }, face_landmark_update: (m, identity4, expression, mirrored) => {
    let obj = getFaceLandmark(m);
    if (!obj) {
      zcwarn("attempting to call face_landmark_update on a destroyed zappar_face_landmark_t");
      return;
    }
    obj.update(identity4, expression, mirrored);
  }, face_landmark_anchor_pose: (m) => {
    let obj = getFaceLandmark(m);
    if (!obj) {
      zcwarn("attempting to call face_landmark_anchor_pose on a destroyed zappar_face_landmark_t");
      return mat4_exports.create();
    }
    return obj.anchor_pose;
  }, html_element_source_create: (pipeline, elm) => HTMLElementSource.createVideoElementSource(pipeline, elm), html_element_source_start: (o) => {
    var _a;
    return (_a = HTMLElementSource.getVideoElementSource(o)) === null || _a === void 0 ? void 0 : _a.start();
  }, html_element_source_pause: (o) => {
    var _a;
    return (_a = HTMLElementSource.getVideoElementSource(o)) === null || _a === void 0 ? void 0 : _a.pause();
  }, html_element_source_destroy: (o) => {
    var _a;
    return (_a = HTMLElementSource.getVideoElementSource(o)) === null || _a === void 0 ? void 0 : _a.destroy();
  }, sequence_source_create: (p) => SequenceSource.create(p), sequence_source_load_from_memory: (o, data) => {
    var _a;
    return (_a = SequenceSource.get(o)) === null || _a === void 0 ? void 0 : _a.loadFromMemory(data);
  }, sequence_source_pause: (o) => {
    var _a;
    return (_a = SequenceSource.get(o)) === null || _a === void 0 ? void 0 : _a.pause();
  }, sequence_source_start: (o) => {
    var _a;
    return (_a = SequenceSource.get(o)) === null || _a === void 0 ? void 0 : _a.start();
  }, sequence_source_max_playback_fps_set: (o, fps) => {
    var _a;
    return (_a = SequenceSource.get(o)) === null || _a === void 0 ? void 0 : _a.maxPlaybackFpsSet(fps);
  }, sequence_source_time_set: (o, t) => {
    var _a;
    return (_a = SequenceSource.get(o)) === null || _a === void 0 ? void 0 : _a.setTime(t);
  }, sequence_source_destroy: (o) => {
    var _a;
    return (_a = SequenceSource.get(o)) === null || _a === void 0 ? void 0 : _a.destroy();
  }, permission_granted_all: permissionGrantedAll, permission_granted_camera: permissionGrantedCamera, permission_granted_motion: permissionGrantedMotion, permission_denied_any: permissionDeniedAny, permission_denied_camera: permissionDeniedCamera, permission_denied_motion: permissionDeniedMotion, permission_request_motion: permissionRequestMotion, permission_request_camera: permissionRequestCamera, permission_request_all: permissionRequestAll, permission_request_ui: permissionRequestUI, permission_request_ui_promise: permissionRequestUI, permission_denied_ui: permissionDeniedUI, browser_incompatible: compatibility_default.incompatible, browser_incompatible_ui: compatibility_default.incompatible_ui, log_level_set: (l) => {
    setLogLevel(l);
    c.impl.log_level_set(l);
  }, cookies_permitted: (p) => {
    if (p) {
      if (!hasPersistedUID) {
        persistUID(uid);
        hasPersistedUID = true;
      }
    } else {
      deleteUID();
    }
  } });
  return client;
}
function loadDefaultFaceModel(o) {
  return __awaiter6(this, void 0, void 0, function* () {
    let url = new URL("./face_tracking_model.zbin", import.meta.url);
    let data = yield fetch(url.toString());
    let ab = yield data.arrayBuffer();
    client === null || client === void 0 ? void 0 : client.face_tracker_model_load_from_memory(o, ab);
  });
}
function getUID() {
  let uid = window.localStorage.getItem("z_uar_lid");
  if (uid === null) {
    const destination = new Uint8Array(8);
    window.crypto.getRandomValues(destination);
    uid = "";
    for (let i = 0; i < destination.byteLength; i++) {
      const part = destination[i].toString(16);
      if (part.length === 1)
        uid += "0" + part;
      else if (part.length === 2)
        uid += part;
    }
  }
  return uid;
}
function persistUID(u) {
  window.localStorage.setItem("z_uar_lid", u);
}
function deleteUID() {
  window.localStorage.removeItem("z_uar_lid");
}

// node_modules/@zappar/zappar-cv/lib/version.js
var VERSION2 = "2.1.9";

// node_modules/@zappar/zappar-cv/lib/index.js
function initialize2(opts) {
  console.log(`Zappar CV v${VERSION2}`);
  return initialize(opts);
}

// node_modules/@zappar/zappar/lib/version.js
var VERSION3 = "2.2.7";

// node_modules/@zappar/zappar/lib/zappar.js
var __awaiter7 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var _z;
var _options;
function z() {
  if (!_z) {
    console.log(`Zappar JS v${VERSION3}`);
    _z = initialize2(_options);
  }
  return _z;
}
function cameraDefaultDeviceID(userFacing) {
  return z().camera_default_device_id(userFacing || false);
}
function projectionMatrixFromCameraModel(model, renderWidth, renderHeight, zNear = 0.1, zFar = 100) {
  return z().projection_matrix_from_camera_model_ext(model, renderWidth, renderHeight, zNear, zFar);
}
function browserIncompatible() {
  return z().browser_incompatible();
}
function browserIncompatibleUI() {
  z().browser_incompatible_ui();
}
function loaded() {
  return z().loaded();
}
function loadedPromise() {
  return __awaiter7(this, void 0, void 0, function* () {
    while (true) {
      if (loaded())
        return;
      yield delay(50);
    }
  });
}
function delay(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
function cookiesPermitted(c) {
  z().cookies_permitted(c);
}

// node_modules/@zappar/zappar/lib/imagetracker.js
var __awaiter8 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ImageTracker2 = class {
  /**
   * Constructs a new ImageTracker
   * @param _pipeline - The pipeline that this tracker will operate within.
   * @param targetFile - The .zpt target file from the source image you'd like to track.
   * @see https://docs.zap.works/universal-ar/zapworks-cli/
  */
  constructor(_pipeline, targetFile) {
    this._pipeline = _pipeline;
    this.onVisible = new Event1();
    this.onNotVisible = new Event1();
    this.onNewAnchor = new Event1();
    this.visible = /* @__PURE__ */ new Set();
    this.anchors = /* @__PURE__ */ new Map();
    this._visibleLastFrame = /* @__PURE__ */ new Set();
    this._frameUpdate = () => {
      const newAnchors = /* @__PURE__ */ new Set();
      const swap = this.visible;
      this.visible = this._visibleLastFrame;
      this._visibleLastFrame = swap;
      this.visible.clear();
      const num = this._z.image_tracker_anchor_count(this._impl);
      for (let i = 0; i < num; i++) {
        const id = this._z.image_tracker_anchor_id(this._impl, i);
        let anchor = this.anchors.get(id);
        let isNew = false;
        if (!anchor) {
          anchor = {
            onVisible: new Event(),
            onNotVisible: new Event(),
            id,
            poseCameraRelative: (mirror) => this._z.image_tracker_anchor_pose_camera_relative(this._impl, i, mirror === true),
            pose: (cameraPose, mirror) => this._z.image_tracker_anchor_pose(this._impl, i, cameraPose, mirror === true),
            visible: true
          };
          isNew = true;
          this.anchors.set(id, anchor);
          newAnchors.add(anchor);
        }
        anchor.visible = true;
        this.visible.add(anchor);
      }
      for (const anchor of newAnchors)
        this.onNewAnchor.emit(anchor);
      for (const anchor of this.visible) {
        if (!this._visibleLastFrame.has(anchor)) {
          this.onVisible.emit(anchor);
          anchor.onVisible.emit();
        } else {
          this._visibleLastFrame.delete(anchor);
        }
      }
      for (const anchor of this._visibleLastFrame) {
        anchor.visible = false;
        this.onNotVisible.emit(anchor);
        anchor.onNotVisible.emit();
      }
    };
    this._pipeline._onFrameUpdateInternal.bind(this._frameUpdate);
    this._z = z();
    this._impl = this._z.image_tracker_create(this._pipeline._getImpl());
    if (targetFile)
      this.loadTarget(targetFile);
  }
  /**
   * Destroys the image tracker.
   */
  destroy() {
    this._pipeline._onFrameUpdateInternal.unbind(this._frameUpdate);
    this.anchors.clear();
    this.visible.clear();
    this._z.image_tracker_destroy(this._impl);
  }
  /**
   * Loads a target file.
   * @param src - A URL to, or an ArrayBuffer of, the target file from the source image you'd like to track.
   * @see https://docs.zap.works/universal-ar/zapworks-cli/
   * @returns A promise that's resolved once the file is downloaded. It may still take a few frames for the tracker to fully initialize and detect images.
  */
  loadTarget(src) {
    return __awaiter8(this, void 0, void 0, function* () {
      if (typeof src === "string") {
        src = yield (yield fetch(src)).arrayBuffer();
      }
      this._targets = void 0;
      this._z.image_tracker_target_load_from_memory(this._impl, src);
    });
  }
  /**
   * Gets/sets the enabled state of the image tracker.
   * Disable when not in use to save computational resources during frame processing.
   */
  get enabled() {
    return this._z.image_tracker_enabled(this._impl);
  }
  set enabled(e) {
    this._z.image_tracker_enabled_set(this._impl, e);
  }
  /**
   * An array of information for each of the target images loaded by this tracker.
   */
  get targets() {
    if (!this._targets) {
      this._targets = [];
      const count = this._z.image_tracker_target_count(this._impl);
      for (let i = 0; i < count; i++) {
        this._targets.push(new ImageTarget(this._z, this._impl, i));
      }
    }
    return this._targets;
  }
};
var ImageTarget = class {
  constructor(_z2, _impl, _indx) {
    this._z = _z2;
    this._impl = _impl;
    this._indx = _indx;
    this.physicalScaleFactor = this._z.image_tracker_target_physical_scale_factor(this._impl, this._indx);
    if (this.physicalScaleFactor < 0)
      this.physicalScaleFactor = void 0;
    this.topRadius = this._z.image_tracker_target_radius_top(this._impl, this._indx);
    if (this.topRadius < 0)
      this.topRadius = void 0;
    this.bottomRadius = this._z.image_tracker_target_radius_bottom(this._impl, this._indx);
    if (this.bottomRadius < 0)
      this.bottomRadius = void 0;
    this.sideLength = this._z.image_tracker_target_side_length(this._impl, this._indx);
    if (this.sideLength < 0)
      this.sideLength = void 0;
  }
  /**
   * An <img> element containing the embedded preview image, or `undefined` if the target file does not contain one.
   */
  get image() {
    if (this._image === void 0) {
      this._image = this._z.image_tracker_target_image(this._impl, this._indx) || null;
    }
    return this._image || void 0;
  }
  /**
   * An object containing a mesh that represents this image target.
   */
  get preview() {
    if (this._preview === void 0) {
      this._preview = new ImageTargetPreview(this._z, this._impl, this._indx);
    }
    return this._preview;
  }
};
var ImageTargetPreview = class {
  constructor(_z2, _impl, _indx) {
    this._z = _z2;
    this._impl = _impl;
    this._indx = _indx;
    this.vertices = this._z.image_tracker_target_preview_mesh_vertices(this._impl, this._indx);
    this.indices = this._z.image_tracker_target_preview_mesh_indices(this._impl, this._indx);
    this.uvs = this._z.image_tracker_target_preview_mesh_uvs(this._impl, this._indx);
  }
};

// node_modules/@zappar/zappar/lib/instantworldtracker.js
var InstantWorldTracker = class {
  /**
   * Constructs a new InstantWorldTracker.
   * @param _pipeline - The pipeline that this tracker will operate within.
  */
  constructor(_pipeline) {
    this._pipeline = _pipeline;
    this.anchor = {
      poseCameraRelative: (mirror) => this._anchorPoseCameraRelative(mirror),
      pose: (cameraPose, mirror) => this._anchorPose(cameraPose, mirror)
    };
    this._z = z();
    this._impl = this._z.instant_world_tracker_create(this._pipeline._getImpl());
  }
  /**
   * Destroys the instant tracker.
   */
  destroy() {
    this._z.instant_world_tracker_destroy(this._impl);
  }
  _anchorPoseCameraRelative(mirror) {
    return this._z.instant_world_tracker_anchor_pose_camera_relative(this._impl, mirror === true);
  }
  _anchorPose(cameraPose, mirror) {
    return this._z.instant_world_tracker_anchor_pose(this._impl, cameraPose, mirror === true);
  }
  /**
   * Gets/sets the enabled state of the instant world tracker.
   * Disable when not in use to save computational resources during frame processing.
   */
  get enabled() {
    return this._z.instant_world_tracker_enabled(this._impl);
  }
  set enabled(e) {
    this._z.instant_world_tracker_enabled_set(this._impl, e);
  }
  /**
   * Sets the point in the user's environment that the anchor tracks from.
   *
   * The parameters passed in to this function correspond to the X, Y and Z coordinates (in camera space) of the point to track. Choosing a position with X and Y coordinates of zero, and a negative Z coordinate, will select a point on a surface directly in front of the center of the screen.
   *
   * @param orientation -  The orientation of the point in space.
   */
  setAnchorPoseFromCameraOffset(x, y, z2, orientation) {
    this._z.instant_world_tracker_anchor_pose_set_from_camera_offset(this._impl, x, y, z2, orientation || instant_world_tracker_transform_orientation_t.MINUS_Z_AWAY_FROM_USER);
  }
};

// node_modules/@zappar/zappar/lib/barcodefinder.js
var BarcodeFinder = class {
  /**
   * Constructs a new BarcodeFinder.
   * @param _pipeline - The pipeline that this BarcodeFinder will operate within.
  */
  constructor(_pipeline) {
    this._pipeline = _pipeline;
    this.onDetection = new Event1();
    this._lastDetected = [];
    this._found = [];
    this._formats = [];
    this._frameUpdate = () => {
      this._found = [];
      const num = this._z.barcode_finder_found_number(this._impl);
      for (let i = 0; i < num; i++) {
        this._found.push({
          text: this._z.barcode_finder_found_text(this._impl, i),
          format: this._z.barcode_finder_found_format(this._impl, i)
        });
      }
      if (this._found.length === 0)
        return;
      outerloop: for (const entry of this._found) {
        for (const previous of this._lastDetected) {
          if (previous.text === entry.text)
            continue outerloop;
        }
        this.onDetection.emit(entry);
      }
      this._lastDetected = this._found;
    };
    this._pipeline._onFrameUpdateInternal.bind(this._frameUpdate);
    this._z = z();
    this._impl = this._z.barcode_finder_create(this._pipeline._getImpl());
    this._formats.push.apply(this._formats, [
      barcode_format_t.AZTEC,
      barcode_format_t.CODABAR,
      barcode_format_t.CODE_39,
      barcode_format_t.CODE_93,
      barcode_format_t.CODE_128,
      barcode_format_t.DATA_MATRIX,
      barcode_format_t.EAN_8,
      barcode_format_t.EAN_13,
      barcode_format_t.ITF,
      barcode_format_t.MAXICODE,
      barcode_format_t.PDF_417,
      barcode_format_t.QR_CODE,
      barcode_format_t.RSS_14,
      barcode_format_t.RSS_EXPANDED,
      barcode_format_t.UPC_A,
      barcode_format_t.UPC_E,
      barcode_format_t.UPC_EAN_EXTENSION
    ]);
  }
  /**
   * Destroys the barcode finder.
   */
  destroy() {
    this._pipeline._onFrameUpdateInternal.unbind(this._frameUpdate);
    this._found = [];
    this._lastDetected = [];
    this._z.barcode_finder_destroy(this._impl);
  }
  /**
    * Returns an array of discovered barcodes
    */
  get found() {
    return this._found;
  }
  /**
   * Gets/sets the enabled state of the barcode finder.
   * Disable when not in use to save computational resources during frame processing.
  */
  get enabled() {
    return this._z.barcode_finder_enabled(this._impl);
  }
  set enabled(e) {
    this._z.barcode_finder_enabled_set(this._impl, e);
  }
  /**
    * Gets/sets the barcode formats to scan for.
    */
  get formats() {
    return this._formats;
  }
  set formats(f) {
    this._formats = f.slice();
    let underlying = 0;
    for (const format of this._formats) {
      underlying |= format;
    }
    this._z.barcode_finder_formats_set(this._impl, underlying);
  }
};

// node_modules/@zappar/zappar/lib/facetracker.js
var __awaiter9 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var FaceTracker = class {
  /**
   * Constructs a new FaceTracker
   * @param _pipeline - The pipeline that this tracker will operate within.
  */
  constructor(_pipeline) {
    this._pipeline = _pipeline;
    this.onVisible = new Event1();
    this.onNotVisible = new Event1();
    this.onNewAnchor = new Event1();
    this.visible = /* @__PURE__ */ new Set();
    this.anchors = /* @__PURE__ */ new Map();
    this._visibleLastFrame = /* @__PURE__ */ new Set();
    this._frameUpdate = () => {
      const newAnchors = /* @__PURE__ */ new Set();
      const swap = this.visible;
      this.visible = this._visibleLastFrame;
      this._visibleLastFrame = swap;
      this.visible.clear();
      const num = this._z.face_tracker_anchor_count(this._impl);
      for (let i = 0; i < num; i++) {
        const id = this._z.face_tracker_anchor_id(this._impl, i);
        let anchor = this.anchors.get(id);
        let isNew = false;
        if (!anchor) {
          anchor = {
            onVisible: new Event(),
            onNotVisible: new Event(),
            indx: 0,
            id,
            poseCameraRelative: (mirror) => this._z.face_tracker_anchor_pose_camera_relative(this._impl, anchor.indx, mirror === true),
            pose: (cameraPose, mirror) => this._z.face_tracker_anchor_pose(this._impl, anchor.indx, cameraPose, mirror === true),
            identity: new Float32Array(50),
            expression: new Float32Array(29),
            visible: true
          };
          isNew = true;
          this.anchors.set(id, anchor);
          newAnchors.add(anchor);
        }
        anchor.indx = i;
        anchor.visible = true;
        anchor.identity = this._z.face_tracker_anchor_identity_coefficients(this._impl, i);
        anchor.expression = this._z.face_tracker_anchor_expression_coefficients(this._impl, i);
        this.visible.add(anchor);
      }
      for (const anchor of newAnchors)
        this.onNewAnchor.emit(anchor);
      for (const anchor of this.visible) {
        if (!this._visibleLastFrame.has(anchor)) {
          this.onVisible.emit(anchor);
          anchor.onVisible.emit();
        } else {
          this._visibleLastFrame.delete(anchor);
        }
      }
      for (const anchor of this._visibleLastFrame) {
        anchor.visible = false;
        this.onNotVisible.emit(anchor);
        anchor.onNotVisible.emit();
      }
    };
    this._pipeline._onFrameUpdateInternal.bind(this._frameUpdate);
    this._z = z();
    this._impl = this._z.face_tracker_create(this._pipeline._getImpl());
  }
  /**
    * Destroys the face tracker.
   */
  destroy() {
    this._pipeline._onFrameUpdateInternal.unbind(this._frameUpdate);
    this.anchors.clear();
    this.visible.clear();
    this._z.face_tracker_destroy(this._impl);
  }
  /**
   * Loads face tracking model data.
   * @param src - A URL to, or ArrayBuffer of, model data.
   * @returns A promise that's resolved once the model is loaded. It may still take a few frames for the tracker to fully initialize and detect faces.
  */
  loadModel(src) {
    return __awaiter9(this, void 0, void 0, function* () {
      if (typeof src === "string") {
        src = yield (yield fetch(src)).arrayBuffer();
      }
      this._z.face_tracker_model_load_from_memory(this._impl, src);
    });
  }
  /**
   * Loads the default face tracking model.
   * @returns A promise that's resolved once the model is loaded. It may still take a few frames for the tracker to fully initialize and detect faces.
  */
  loadDefaultModel() {
    return __awaiter9(this, void 0, void 0, function* () {
      yield this._z.face_tracker_model_load_default(this._impl);
    });
  }
  /**
   * Gets/sets the enabled state of the face tracker.
   * Disable when not in use to save computational resources during frame processing.
   */
  get enabled() {
    return this._z.face_tracker_enabled(this._impl);
  }
  set enabled(e) {
    this._z.face_tracker_enabled_set(this._impl, e);
  }
  /**
   * Gets/sets the maximum number of faces to track.
   *
   * By default only one face is tracked in any given frame. Increasing this number may reduce runtime performance.
   */
  get maxFaces() {
    return this._z.face_tracker_max_faces(this._impl);
  }
  set maxFaces(m) {
    this._z.face_tracker_max_faces_set(this._impl, m);
  }
};

// node_modules/@zappar/zappar/lib/facemesh.js
var __awaiter10 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var FaceMesh2 = class {
  /**
   * Constructs a new FaceMesh.
   * @see https://docs.zap.works/universal-ar/javascript/face-tracking/
  */
  constructor() {
    this._z = z();
    this._impl = this._z.face_mesh_create();
  }
  /**
   * Destroys the face mesh.
   */
  destroy() {
    this._z.face_mesh_destroy(this._impl);
  }
  /**
   * Loads the data for a face mesh.
   * @param src - A URL or ArrayBuffer of the source mesh data.
   * @param fillMouth - If true, fills this face feature with polygons.
   * @param fillEyeLeft - If true, fills this face feature with polygons.
   * @param fillEyeRight - If true, fills this face feature with polygons.
   * @param fillNeck - If true, fills this face feature with polygons.
   * @returns A promise that's resolved once the data is loaded.
   */
  load(src, fillMouth, fillEyeLeft, fillEyeRight, fillNeck) {
    return __awaiter10(this, void 0, void 0, function* () {
      if (!src) {
        this.loadDefault();
        return;
      } else if (typeof src === "string") {
        src = yield (yield fetch(src)).arrayBuffer();
      }
      this._z.face_mesh_load_from_memory(this._impl, src, fillMouth || false, fillEyeLeft || false, fillEyeRight || false, fillNeck || false);
    });
  }
  /**
    * Loads the default face mesh data.
    * @returns A promise that's resolved once the data is loaded.
    */
  loadDefault() {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this._z.face_mesh_load_default(this._impl);
    });
  }
  /**
    * Loads the default face mesh.
    * @param fillMouth - If true, fills this face feature with polygons.
    * @param fillEyeLeft - If true, fills this face feature with polygons.
    * @param fillEyeRight - If true, fills this face feature with polygons.
    * @returns A promise that's resolved once the data is loaded.
    */
  loadDefaultFace(fillMouth, fillEyeLeft, fillEyeRight) {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this._z.face_mesh_load_default_face(this._impl, fillMouth || false, fillEyeLeft || false, fillEyeRight || false);
    });
  }
  /**
    * The full head simplified mesh covers the whole of the user's head, including some neck.
    * It's ideal for drawing into the depth buffer in order to mask out the back of 3D models placed on the user's head.
    * @param fillMouth - If true, fills this face feature with polygons.
    * @param fillEyeLeft - If true, fills this face feature with polygons.
    * @param fillEyeRight - If true, fills this face feature with polygons.
    * @param fillNeck - If true, fills this face feature with polygons.
    * @returns A promise that's resolved once the data is loaded.
    */
  loadDefaultFullHeadSimplified(fillMouth, fillEyeLeft, fillEyeRight, fillNeck) {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this._z.face_mesh_load_default_full_head_simplified(this._impl, fillMouth || false, fillEyeLeft || false, fillEyeRight || false, fillNeck || false);
    });
  }
  /**
    * Update the face mesh directly from a [[FaceAnchor]].
    * @param f - The face anchor.
    * @param mirror - Pass `true` to mirror the location in the X-axis.
    */
  updateFromFaceAnchor(f, mirror) {
    this._z.face_mesh_update(this._impl, f.identity, f.expression, mirror || false);
  }
  /**
    * Updates the face mesh directly from a identity and expression coefficients.
    * @param identity - The identity coefficients.
    * @param expression - The expression coefficients.
    * @param mirror - Pass `true` to mirror the location in the X-axis.
   */
  updateFromIdentityExpression(identity4, expression, mirror) {
    this._z.face_mesh_update(this._impl, identity4, expression, mirror || false);
  }
  /**
   *
   * @returns The vertices of the mesh.
   */
  get vertices() {
    return this._z.face_mesh_vertices(this._impl);
  }
  /**
   * @returns The indices of the mesh.
   */
  get indices() {
    return this._z.face_mesh_indices(this._impl);
  }
  /**
   * @returns The UVs of the mesh.
   */
  get uvs() {
    return this._z.face_mesh_uvs(this._impl);
  }
  /**
   * @returns The normals of the mesh.
   */
  get normals() {
    return this._z.face_mesh_normals(this._impl);
  }
  /**
   * @ignore
  */
  _getImpl() {
    return this._impl;
  }
};

// node_modules/@zappar/zappar/lib/camerasource.js
var CameraSource2 = class {
  /**
   * Constructs a new CameraSource.
   * @param _pipeline - The pipeline that this tracker will operate within.
   * @param deviceId - The camera device ID which will be used as the source.
   * @see https://docs.zap.works/universal-ar/javascript/pipelines-and-camera-processing/
  */
  constructor(pipeline, deviceId) {
    this._z = z();
    this._impl = this._z.camera_source_create(pipeline._getImpl(), deviceId);
  }
  /**
  * Destroys the camera source.
  */
  destroy() {
    this._z.camera_source_destroy(this._impl);
  }
  /**
  * Starts the camera source.
  *
  * Starting a given source pauses any other sources within the same pipeline.
  */
  start() {
    this._z.camera_source_start(this._impl);
  }
  /**
  * Pauses the camera source.
  */
  pause() {
    this._z.camera_source_pause(this._impl);
  }
};

// node_modules/@zappar/zappar/lib/htmlelementsource.js
var HTMLElementSource2 = class {
  /**
   * Constructs a new HTMLElementSource.
   * @param pipeline - The pipeline that this tracker will operate within.
   * @param element -  The HTML source element.
  */
  constructor(pipeline, element) {
    this._z = z();
    this._impl = this._z.html_element_source_create(pipeline._getImpl(), element);
  }
  /**
  * Destroys the source.
  */
  destroy() {
    this._z.html_element_source_destroy(this._impl);
  }
  /**
  * Starts the source sending frames into the pipeline.
  *
  * Starting a given source pauses any other sources within the same pipeline.
  */
  start() {
    this._z.html_element_source_start(this._impl);
  }
  /**
  * Pauses the source.
  */
  pause() {
    this._z.html_element_source_pause(this._impl);
  }
};

// node_modules/@zappar/zappar/lib/sequencesource.js
var __awaiter11 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SequenceSource2 = class {
  /**
   * Constructs a new SequenceSource.
   * @param _pipeline - The pipeline that this source will operate within.
  */
  constructor(pipeline) {
    this._z = z();
    this._impl = this._z.sequence_source_create(pipeline._getImpl());
  }
  /**
  * Destroys the sequence source.
  */
  destroy() {
    this._z.sequence_source_destroy(this._impl);
  }
  /**
  * Starts the sequence source.
  *
  * Starting a given source pauses any other sources within the same pipeline.
  */
  start() {
    this._z.sequence_source_start(this._impl);
  }
  /**
  * Pauses the sequence source.
  */
  pause() {
    this._z.sequence_source_pause(this._impl);
  }
  /**
   * Loads sequence data.
   * @param src - A URL to, or an ArrayBuffer of, the sequence data you'd like to play back.
   * @returns A promise that's resolved once the data is downloaded.
  */
  load(src) {
    return __awaiter11(this, void 0, void 0, function* () {
      if (typeof src === "string") {
        src = yield (yield fetch(src)).arrayBuffer();
      }
      this._z.sequence_source_load_from_memory(this._impl, src);
    });
  }
  /**
   * Manually set the current time for the sequence.
   * @param t The time in ms, or `undefined` to use the system time.
   */
  setTime(t) {
    this._z.sequence_source_time_set(this._impl, t !== null && t !== void 0 ? t : -1);
  }
};

// node_modules/@zappar/zappar/lib/pipeline.js
var Pipeline2 = class {
  /**
   * Constructs a new Pipeline.
  */
  constructor() {
    this.onFrameUpdate = new Event();
    this._onFrameUpdateInternal = new Event();
    this._lastFrameNumber = -1;
    this._z = z();
    this._impl = this._z.pipeline_create();
  }
  /**
   * Destroys the pipeline.
   */
  destroy() {
    this._z.pipeline_destroy(this._impl);
  }
  /**
   * Updates the pipeline and trackers to expose tracking data from the most recently processed camera frame.
   */
  frameUpdate() {
    this._z.pipeline_frame_update(this._impl);
    const frameNumber = this._z.pipeline_frame_number(this._impl);
    if (frameNumber !== this._lastFrameNumber) {
      this._lastFrameNumber = frameNumber;
      this._onFrameUpdateInternal.emit();
      this.onFrameUpdate.emit();
    }
  }
  /**
   * @ignore
  */
  _getImpl() {
    return this._impl;
  }
  /**
   * Sets the WebGL context used for the processing and upload of camera textures.
   * @param gl - The WebGL context.
  */
  glContextSet(gl) {
    this._z.pipeline_gl_context_set(this._impl, gl);
  }
  /**
   * Informs the pipeline that the GL context is lost and should not be used.
  */
  glContextLost() {
    this._z.pipeline_gl_context_lost(this._impl);
  }
  /**
   * Returns the most recent camera frame texture.
  */
  cameraFrameTextureGL() {
    return this._z.pipeline_camera_frame_texture_gl(this._impl);
  }
  /**
   * Returns a matrix that you can use to transform the UV coordinates of the following full-screen quad in order to render the camera texture:
   *
   * Vertex 0: `-1, -1, 0`
   *
   * UV 0: `0, 0`
   *
   * Vertex 1: `-1, 1, 0`
   *
   * UV 1: `0, 1`
   *
   * Vertex 2: `1, -1, 0`
   *
   * UV 1: `1, 0`
   *
   * Vertex 3: `1, 1, 0`
   *
   * UV 1: `1, 1`
   *
   * @param renderWidth - The width of the canvas.
   * @param renderHeight - The height of the canvas.
   * @param mirror - Pass `true` to mirror the camera image in the X-axis.
   * @returns A 4x4 column-major transformation matrix.
  */
  cameraFrameTextureMatrix(renderWidth, renderHeight, mirror) {
    return this._z.pipeline_camera_frame_texture_matrix(this._impl, renderWidth, renderHeight, mirror === true);
  }
  /**
   * Draw the camera to the screen as a full screen quad.
   *
   * Please note this function modifies some GL state during its operation so you may need to reset the following GL state if you use it:
   * - The currently bound texture 2D is set to `null` (e.g. `gl.bindTexture(gl.TEXTURE_2D, null)`)
   * - The currently bound array buffer is set to `null` (e.g. `gl.bindBuffer(gl.ARRAY_BUFFER, null);`)
   * - The currently bound program is set to `null` (e.g. `gl.useProgram(null)`)
   * - The currently active texture is set to `gl.TEXTURE0` (e.g. `gl.activeTexture(gl.TEXTURE0)`)
   * - These features are disabled: `gl.SCISSOR_TEST`, `gl.DEPTH_TEST`, `gl.BLEND`, `gl.CULL_FACE`
   * @param renderWidth - The width of the canvas.
   * @param renderHeight - The height of the canvas.
   * @param mirror - Pass `true` to mirror the camera image in the X-axis.
  */
  cameraFrameDrawGL(renderWidth, renderHeight, mirror) {
    this._z.pipeline_camera_frame_draw_gl(this._impl, renderWidth, renderHeight, mirror);
  }
  /**
   * Uploads the current camera frame to a WebGL texture.
  */
  cameraFrameUploadGL() {
    this._z.pipeline_camera_frame_upload_gl(this._impl);
  }
  /**
   * Prepares camera frames for processing.
   *
   * Call this function on your pipeline once an animation frame (e.g. during your `requestAnimationFrame` function) in order to process incoming camera frames.
   *
   * Please note this function modifies some GL state during its operation so you may need to reset the following GL state if you use it:
   * - The currently bound framebuffer is set to `null` (e.g. `gl.bindFramebuffer(gl.FRAMEBUFFER, null)`)
   * - The currently bound texture 2D is set to `null` (e.g. `gl.bindTexture(gl.TEXTURE_2D, null)`)
   * - The currently bound array buffer is set to `null` (e.g. `gl.bindBuffer(gl.ARRAY_BUFFER, null);`)
   * - The currently bound element array buffer is set to `null` (e.g. `gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null)`)
   * - The currently bound program is set to `null` (e.g. `gl.useProgram(null)`)
   * - The currently active texture is set to `gl.TEXTURE0` (e.g. `gl.activeTexture(gl.TEXTURE0)`)
   * - These features are disabled: `gl.SCISSOR_TEST`, `gl.DEPTH_TEST`, `gl.BLEND`, `gl.CULL_FACE`
   * - The pixel store flip-Y mode is disabled (e.g. `gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false)`)
   * - The viewport is changed (e.g. `gl.viewport(...)`)
   * - The clear color is changed (e.g. `gl.clearColor(...)`)
  */
  processGL() {
    this._z.pipeline_process_gl(this._impl);
  }
  /**
   * Returns the camera model (i.e. the intrinsic camera parameters) for the current frame.
  */
  cameraModel() {
    return this._z.pipeline_camera_model(this._impl);
  }
  /**
   * Returns a transformation where the camera sits, stationary, at the origin of world space, and points down the negative Z axis.
   *
   * In this mode, tracked anchors move in world space as the user moves the device or tracked objects in the real world.
   *
   * @returns A 4x4 column-major transformation matrix
  */
  cameraPoseDefault() {
    return this._z.pipeline_camera_pose_default(this._impl);
  }
  /**
   * Returns a transformation where the camera sits at the origin of world space, but rotates as the user rotates the physical device.
   *
   * When the Zappar library initializes, the negative Z axis of world space points forward in front of the user.
   *
   * In this mode, tracked anchors move in world space as the user moves the device or tracked objects in the real world.
   *
   * @param mirror -  Pass `true` to mirror the location in the X-axis.
   * @returns A 4x4 column-major transformation matrix
  */
  cameraPoseWithAttitude(mirror) {
    return this._z.pipeline_camera_pose_with_attitude(this._impl, mirror || false);
  }
  /**
   * Returns a transformation with the (camera-relative) origin specified by the supplied parameter.
   *
   * This is used with the `poseCameraRelative(...) : Float32Array` functions provided by the various anchor types to allow a given anchor (e.g. a tracked image or face) to be the origin of world space.
   *
   * In this case the camera moves and rotates in world space around the anchor at the origin.
   *
   * @param o - The origin matrix.
   * @returns A 4x4 column-major transformation matrix
  */
  cameraPoseWithOrigin(o) {
    return this._z.pipeline_camera_pose_with_origin(this._impl, o);
  }
  /**
    * Returns true if the current camera frame came from a user-facing camera
   */
  cameraFrameUserFacing() {
    return this._z.pipeline_camera_frame_user_facing(this._impl);
  }
  /**
    * @ignore
   */
  drawFace(projectionMatrix2, cameraMatrix, targetMatrix, m) {
    this._z.pipeline_draw_face(this._impl, projectionMatrix2, cameraMatrix, targetMatrix, m._getImpl());
  }
  /**
    * Returns the number of the current frame.
   */
  frameNumber() {
    return this._z.pipeline_frame_number(this._impl);
  }
  /**
   * Start recording camera and motion data into memory. This data can then used with SequenceSource to replay the sequence.
   *
   * @param expectedFrames - The number of camera frames you expect to capture. If supplied, memory will be pre-allocated to improve performance
   */
  sequenceRecordStart(expectedFrames) {
    if (expectedFrames === void 0)
      expectedFrames = 30 * 5;
    this._z.pipeline_sequence_record_start(this._impl, expectedFrames);
  }
  /**
   * Stop recording camera and motion data.
   */
  sequenceRecordStop() {
    this._z.pipeline_sequence_record_stop(this._impl);
  }
  /**
   * Remove any camera and motion data currently stored in memory.
   */
  sequenceRecordClear() {
    this._z.pipeline_sequence_record_clear(this._impl);
  }
  /**
   * Get the data captured by sequence recording.
   *
   * @returns A Uint8Array of packed camera and motion data
   */
  sequenceRecordData() {
    return this._z.pipeline_sequence_record_data(this._impl);
  }
};

// node_modules/@zappar/zappar/lib/facelandmark.js
var FaceLandmark2 = class {
  /**
   * Constructs a new FaceLanmdmark.
   * @param _name - The name of the landmark to track.
   * @see https://docs.zap.works/universal-ar/javascript/face-tracking/
  */
  constructor(_name) {
    this._name = _name;
    this.pose = mat4_exports.create();
    this._z = z();
    this._impl = this._z.face_landmark_create(this._name);
  }
  /**
   * Destroys the face landmark.
   */
  destroy() {
    this._z.face_landmark_destroy(this._impl);
  }
  /**
   * Updates pose directly from the expression and identity in a [[FaceAnchor]].
   * @param f - The anchor to derive the expression and identity from.
   * @param mirror - Pass `true` to mirror the location in the X-axis.
  */
  updateFromFaceAnchor(f, mirror) {
    this._z.face_landmark_update(this._impl, f.identity, f.expression, mirror || false);
    this.pose = this._z.face_landmark_anchor_pose(this._impl);
  }
  /**
   * Updates pose directly from identity and expression coefficients.
   * @param identity  - The identity coefficients.
   * @param expression - The expression coefficients.
   * @param mirror - Pass `true` to mirror the location in the X-axis.
  */
  updateFromIdentityExpression(identity4, expression, mirror) {
    this._z.face_landmark_update(this._impl, identity4, expression, mirror || false);
    this.pose = this._z.face_landmark_anchor_pose(this._impl);
  }
  /**
   * @ignore
  */
  _getImpl() {
    return this._impl;
  }
};

// node_modules/@zappar/zappar/lib/permission.js
var __awaiter12 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Permission;
(function(Permission2) {
  Permission2[Permission2["CAMERA"] = 0] = "CAMERA";
  Permission2[Permission2["MOTION"] = 1] = "MOTION";
})(Permission || (Permission = {}));
function permissionGranted(onlyPermsission) {
  switch (onlyPermsission) {
    case Permission.CAMERA:
      return z().permission_granted_camera();
    case Permission.MOTION:
      return z().permission_granted_motion();
    default:
      return z().permission_granted_all();
  }
}
function permissionDenied(onlyPermission) {
  switch (onlyPermission) {
    case Permission.CAMERA:
      return z().permission_denied_camera();
    case Permission.MOTION:
      return z().permission_denied_motion();
    default:
      return z().permission_denied_any();
  }
}
function permissionRequest(onlyPermission) {
  switch (onlyPermission) {
    case Permission.CAMERA:
      z().permission_request_camera();
      break;
    case Permission.MOTION:
      z().permission_request_motion();
      break;
    default:
      z().permission_request_all();
      break;
  }
  return new Promise((resolve) => __awaiter12(this, void 0, void 0, function* () {
    while (true) {
      yield _nextFrame();
      switch (onlyPermission) {
        case Permission.CAMERA:
          if (z().permission_granted_camera()) {
            resolve(true);
            return;
          }
          if (z().permission_denied_camera()) {
            resolve(false);
            return;
          }
          break;
        case Permission.MOTION:
          if (z().permission_granted_motion()) {
            resolve(true);
            return;
          }
          if (z().permission_denied_motion()) {
            resolve(false);
            return;
          }
          break;
        default:
          if (z().permission_granted_camera() && z().permission_granted_motion()) {
            resolve(true);
            return;
          }
          if (z().permission_denied_camera() || z().permission_denied_motion()) {
            resolve(false);
            return;
          }
          break;
      }
    }
  }));
}
function permissionRequestUI2() {
  return __awaiter12(this, void 0, void 0, function* () {
    return yield z().permission_request_ui_promise();
  });
}
function permissionDeniedUI2() {
  return z().permission_denied_ui();
}
function _nextFrame() {
  return new Promise((resolve) => requestAnimationFrame(() => resolve()));
}

// node_modules/@zappar/zappar/lib/loglevel.js
function setLogLevel2(l) {
  z().log_level_set(l);
}

// node_modules/@zappar/zappar-threejs/lib/three.js
var THREE = three_module_exports;

// node_modules/@zappar/zappar-threejs/lib/defaultpipeline.js
var defaultPipeline;
var onFrameUpdate = new Event();
function getDefaultPipeline() {
  if (!defaultPipeline) {
    defaultPipeline = new Pipeline2();
    defaultPipeline.onFrameUpdate.bind(() => onFrameUpdate.emit());
  }
  return defaultPipeline;
}
var ImageTracker3 = class extends ImageTracker2 {
  /**
   * Constructs a new ImageTracker.
   * @param targetFile - The .zpt target file from the source image you'd like to track.
   * @param pipeline - The pipeline that this tracker will operate within.
   * @see https://docs.zap.works/universal-ar/zapworks-cli/
   */
  constructor(targetFile, pipeline) {
    super(pipeline || getDefaultPipeline(), targetFile);
  }
};
var BarcodeFinder2 = class extends BarcodeFinder {
  /**
   * Constructs a new BarcodeFinder.
   * @param pipeline - The pipeline that this tracker will operate within.
   */
  constructor(pipeline) {
    super(pipeline || getDefaultPipeline());
  }
};
var FaceTracker2 = class extends FaceTracker {
  /**
   * Constructs a new FaceTracker.
   * @param _pipeline - The pipeline that this tracker will operate within.
   */
  constructor(pipeline) {
    super(pipeline || getDefaultPipeline());
  }
};
var InstantWorldTracker2 = class extends InstantWorldTracker {
  /**
   * Constructs a new InstantWorldTracker.
   * @param _pipeline - The pipeline that this tracker will operate within.
   */
  constructor(pipeline) {
    super(pipeline || getDefaultPipeline());
  }
};
var CameraSource3 = class extends CameraSource2 {
  /**
   * Constructs a new CameraSource.
   * @param _pipeline - The pipeline that this source will operate within.
   * @param deviceId - The camera device ID which will be used as the source.
   * @see https://docs.zap.works/universal-ar/javascript/pipelines-and-camera-processing/
   */
  constructor(deviceId, pipeline) {
    super(pipeline || getDefaultPipeline(), deviceId);
  }
};
var HTMLElementSource3 = class extends HTMLElementSource2 {
  /**
   * Constructs a new HTMLElementSource.
   * @param element -  The HTML source element.
   * @param pipeline - The pipeline that this tracker will operate within.
   */
  constructor(element, pipeline) {
    super(pipeline || getDefaultPipeline(), element);
  }
};
function glContextSet(gl) {
  getDefaultPipeline().glContextSet(gl);
}
function glContextLost() {
  getDefaultPipeline().glContextLost();
}

// node_modules/@zappar/zappar-threejs/lib/cameraTexture.js
var vertexShaderSource = `
      precision highp float;
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
      }
    `;
var fragmentShaderSource = `
      precision highp float;
      uniform sampler2D u_texture;
      varying vec2 vUv;
      void main() {
        vec4 texColor = texture2D(u_texture, vUv);
        texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
        gl_FragColor = texColor;
      }
    `;
var CameraTexture = class extends THREE.Texture {
  constructor() {
    super();
    this.MirrorMode = CameraMirrorMode.None;
    this.onTextureUpdated = new Event1();
    this.viewMatrix = new THREE.Matrix4();
    this.textureMatrix3 = new THREE.Matrix3();
  }
  /**
   * Override three.js update function since we update the camera texture ourselves.
   */
  update() {
  }
  // eslint-disable-line class-methods-use-this
  /**
   * Processes camera frames and updates the texture.
   * @param renderer - The Three.js WebGL renderer.
   * @param pipeline - A ZapparThree Pipeline.
   */
  updateFromPipeline(renderer, pipeline) {
    pipeline.cameraFrameUploadGL();
    const texture = pipeline.cameraFrameTextureGL();
    if (!texture)
      return;
    const properties = renderer.properties.get(this);
    properties.__webglTexture = texture;
    properties.__webglInit = true;
    this.viewMatrix.fromArray(pipeline.cameraFrameTextureMatrix(renderer.domElement.width, renderer.domElement.height, this.MirrorMode === CameraMirrorMode.Poses));
    this.textureMatrix3.setFromMatrix4(this.viewMatrix);
    this.textureMatrix3.elements[6] = this.viewMatrix.elements[12];
    this.textureMatrix3.elements[7] = this.viewMatrix.elements[13];
    this.textureMatrix3.elements[8] = 1;
    this.matrixAutoUpdate = false;
    this.matrix = this.textureMatrix3;
    this.onTextureUpdated.emit({ texture: this, renderer });
  }
  dispose() {
    super.dispose();
  }
};
var InlineDecoder = class {
  constructor(cameraTexture) {
    this.shaderScene = new THREE.Scene();
    this.shaderRenderTarget = new THREE.WebGLRenderTarget(1024, 1024);
    this.shaderCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
    this.intermediateRenderTarget = new THREE.WebGLRenderTarget(1024, 1024);
    zcout("Inline decoder initialized");
    this.shaderMaterial = new THREE.ShaderMaterial({
      uniforms: {
        u_texture: { value: null }
      },
      vertexShader: vertexShaderSource,
      fragmentShader: fragmentShaderSource
    });
    const shaderPlane = new THREE.PlaneGeometry(2, 2);
    const shaderQuad = new THREE.Mesh(shaderPlane, this.shaderMaterial);
    this.shaderScene.add(shaderQuad);
    this.shaderRenderTarget.texture.generateMipmaps = false;
    this.shaderRenderTarget.texture.minFilter = THREE.LinearFilter;
    this.shaderRenderTarget.texture.magFilter = THREE.LinearFilter;
    shaderQuad.position.z = -1;
    this.shaderMaterial.uniforms.u_texture.value = cameraTexture;
    cameraTexture.onTextureUpdated.bind(({ texture, renderer }) => {
      this.update(renderer, texture);
    });
  }
  /**
   * Get the texture of the render target.
   * @public
   * @returns THREE.Texture The texture of the render target.
   */
  get texture() {
    return this.shaderRenderTarget.texture;
  }
  /**
   * Updates the shader uniform with a new texture and renders the shader scene to the target texture.
   */
  update(renderer, cameraTexture) {
    let decoderRequired = true;
    if (THREE.SRGBColorSpace && renderer.outputColorSpace) {
      decoderRequired = renderer.outputColorSpace === THREE.SRGBColorSpace;
    } else if (THREE.sRGBEncoding && renderer.outputEncoding) {
      decoderRequired = renderer.outputEncoding === THREE.sRGBEncoding;
    }
    if (!decoderRequired)
      return;
    const previousRenderTarget = renderer.getRenderTarget();
    this.shaderMaterial.uniforms.u_texture.value = cameraTexture;
    renderer.setRenderTarget(this.intermediateRenderTarget);
    renderer.render(this.shaderScene, this.shaderCamera);
    this.shaderRenderTarget.texture = this.intermediateRenderTarget.texture;
    renderer.setRenderTarget(previousRenderTarget);
    this.texture.matrixAutoUpdate = false;
    this.texture.matrix = cameraTexture.matrix;
    const properties = renderer.properties.get(cameraTexture);
    const renderTargetProperties = renderer.properties.get(this.texture);
    properties.__webglTexture = renderTargetProperties.__webglTexture;
    properties.__webglInit = true;
  }
  /**
   * Releases the resources held by this object.
   * @public
   */
  dispose() {
    this.shaderRenderTarget.dispose();
  }
};

// node_modules/@zappar/zappar-threejs/lib/camera.js
var CameraPoseMode;
(function(CameraPoseMode2) {
  CameraPoseMode2[CameraPoseMode2["Default"] = 0] = "Default";
  CameraPoseMode2[CameraPoseMode2["Attitude"] = 1] = "Attitude";
  CameraPoseMode2[CameraPoseMode2["AnchorOrigin"] = 2] = "AnchorOrigin";
})(CameraPoseMode || (CameraPoseMode = {}));
var CameraMirrorMode;
(function(CameraMirrorMode2) {
  CameraMirrorMode2[CameraMirrorMode2["None"] = 0] = "None";
  CameraMirrorMode2[CameraMirrorMode2["Poses"] = 1] = "Poses";
  CameraMirrorMode2[CameraMirrorMode2["CSS"] = 2] = "CSS";
})(CameraMirrorMode || (CameraMirrorMode = {}));
var CameraDirection;
(function(CameraDirection2) {
  CameraDirection2[CameraDirection2["None"] = 0] = "None";
  CameraDirection2[CameraDirection2["User"] = 1] = "User";
  CameraDirection2[CameraDirection2["Rear"] = 2] = "Rear";
})(CameraDirection || (CameraDirection = {}));
var Camera = class extends THREE.Camera {
  /**
   * Constructs a new Camera.
   * @param pipeline - The pipeline that this tracker will operate within.
   * @property pipeline - The pipeline that this tracker will operate within.
   * @property zNear - The near clipping plane.
   * @property zFar - The far clipping plane.
   * @property rearCameraSource? - The camera source which will be used for the rear camera.
   * @property userCameraSource? - The camera source which will be used for the user camera.
   */
  constructor(opts) {
    super();
    this.poseMode = CameraPoseMode.Default;
    this.rearCameraMirrorMode = CameraMirrorMode.None;
    this.userCameraMirrorMode = CameraMirrorMode.Poses;
    this._currentMirrorMode = CameraMirrorMode.None;
    this.isPerspectiveCamera = true;
    this.cameraDirection = CameraDirection.None;
    this.hasSetCSSScaleX = false;
    this.renderWidth = 0;
    this.renderHeight = 0;
    this.pipeline = opts instanceof Pipeline2 ? opts : (opts === null || opts === void 0 ? void 0 : opts.pipeline) || getDefaultPipeline();
    this.rawPose = this.pipeline.cameraPoseDefault();
    if (opts && !(opts instanceof Pipeline2)) {
      this.zNear = opts.zNear ? opts.zNear : 0.01;
      this.zFar = opts.zFar ? opts.zFar : 100;
      this.rearCameraSource = this.cameraSourceFromOpts(opts.rearCameraSource);
      this.userCameraSource = this.cameraSourceFromOpts(opts.userCameraSource, true);
      this.backgroundTexture = opts.backgroundTexture ? opts.backgroundTexture : new CameraTexture();
    } else {
      this.rearCameraSource = new CameraSource3(cameraDefaultDeviceID(), this.pipeline);
      this.userCameraSource = new CameraSource3(cameraDefaultDeviceID(true), this.pipeline);
      this.backgroundTexture = new CameraTexture();
    }
    this.matrixAutoUpdate = false;
    document.addEventListener("visibilitychange", () => {
      document.visibilityState === "visible" ? this.resume() : this.pause();
    });
  }
  /**
   * The far clipping plane.
   */
  set far(value) {
    this.zFar = value;
  }
  /**
   * The far clipping plane.
   */
  get far() {
    var _a;
    return (_a = this.zFar) !== null && _a !== void 0 ? _a : 100;
  }
  /**
   * The near clipping plane.
   */
  set near(value) {
    this.zNear = value;
  }
  /**
   * The near clipping plane.
   */
  get near() {
    var _a;
    return (_a = this.zNear) !== null && _a !== void 0 ? _a : 0.01;
  }
  /**
   * Constructs a new CameraSource or HTMLElementSource based on parameters passed in.
   * @param cameraSource - HTML element or camera device ID which will be used as a source
   * @returns CameraSource if cameraSource param is undefined or string, otherwise HTMLElementSource.
   */
  cameraSourceFromOpts(cameraSource, frontFacing = false) {
    return cameraSource instanceof Element ? new HTMLElementSource2(this.pipeline, cameraSource) : new CameraSource3(cameraSource || cameraDefaultDeviceID(frontFacing), this.pipeline);
  }
  /**
   * Pauses the camera source.
   */
  pause() {
    this.userCameraSource.pause();
    this.rearCameraSource.pause();
  }
  /**
   * Starts the camera source.
   *
   * Starting a given source pauses any other sources within the same pipeline.
   */
  resume() {
    switch (this.cameraDirection) {
      case CameraDirection.User:
        this.userCameraSource.start();
        break;
      case CameraDirection.Rear:
        this.rearCameraSource.start();
        break;
      default:
        break;
    }
  }
  /**
   * Starts the camera source.
   * @param userFacing - If true, starts the user facing camera. (i.e selfie).
   */
  start(userFacing) {
    this.cameraDirection = userFacing ? CameraDirection.User : CameraDirection.Rear;
    this.resume();
  }
  /**
   * Stops the camera source.
   */
  stop() {
    this.cameraDirection = CameraDirection.None;
    this.pause();
  }
  /**
   * Sets the pose mode to 'Anchor Origin'.
   *
   * In this case the camera moves and rotates in world space around the anchor at the origin.
   * @param anchor - The anchor that defines the origin.
   */
  setPoseModeAnchorOrigin(anchor) {
    this.poseAnchorOrigin = anchor;
    this.poseMode = CameraPoseMode.AnchorOrigin;
  }
  /**
   * Gets the current mirror mode.
   */
  get currentMirrorMode() {
    return this._currentMirrorMode;
  }
  handleColorSpace(renderer) {
    const rendererAny = renderer;
    const THREEAny = THREE;
    let decoderRequired = false;
    if ((rendererAny === null || rendererAny === void 0 ? void 0 : rendererAny.outputColorSpace) && (THREEAny === null || THREEAny === void 0 ? void 0 : THREEAny.SRGBColorSpace)) {
      decoderRequired = (rendererAny === null || rendererAny === void 0 ? void 0 : rendererAny.outputColorSpace) === (THREEAny === null || THREEAny === void 0 ? void 0 : THREEAny.SRGBColorSpace);
    } else if ((THREEAny === null || THREEAny === void 0 ? void 0 : THREEAny.sRGBEncoding) && (rendererAny === null || rendererAny === void 0 ? void 0 : rendererAny.outputEncoding)) {
      decoderRequired = (rendererAny === null || rendererAny === void 0 ? void 0 : rendererAny.outputEncoding) === (THREEAny === null || THREEAny === void 0 ? void 0 : THREEAny.sRGBEncoding);
    }
    if (!decoderRequired) {
      if (parseInt(THREE.REVISION, 10) <= 152) {
        this.backgroundTexture.encoding = rendererAny.outputEncoding;
      } else {
        this.backgroundTexture.colorSpace = rendererAny.outputColorSpace;
      }
    } else if (!this.inlineDecoder) {
      this.inlineDecoder = new InlineDecoder(this.backgroundTexture);
    }
  }
  /**
   * Processes camera frames and updates `backgroundTexture`.
   * Call this function on your pipeline once an animation frame (e.g. during your `requestAnimationFrame` function).
   * @param renderer - The Three.js WebGL renderer.
   */
  updateFrame(renderer) {
    this.pipeline.processGL();
    this.pipeline.frameUpdate();
    this._currentMirrorMode = this.pipeline.cameraFrameUserFacing() ? this.userCameraMirrorMode : this.rearCameraMirrorMode;
    const { domElement } = renderer;
    if (this.currentMirrorMode !== CameraMirrorMode.CSS && this.hasSetCSSScaleX) {
      domElement.style.transform = "";
      this.hasSetCSSScaleX = false;
    } else if (this.currentMirrorMode === CameraMirrorMode.CSS && !this.hasSetCSSScaleX) {
      domElement.style.transform = "scaleX(-1)";
      this.hasSetCSSScaleX = true;
    }
    this.renderWidth = renderer.domElement.width;
    this.renderHeight = renderer.domElement.height;
    this._updateProjectionMatrix();
    switch (this.poseMode) {
      case CameraPoseMode.Default:
        this.rawPose = this.pipeline.cameraPoseDefault();
        break;
      case CameraPoseMode.Attitude:
        this.rawPose = this.pipeline.cameraPoseWithAttitude(this.currentMirrorMode === CameraMirrorMode.Poses);
        break;
      case CameraPoseMode.AnchorOrigin:
        this.rawPose = this.poseAnchorOrigin ? this.getOriginPose() : this.pipeline.cameraPoseDefault();
        break;
      default:
        this.rawPose = this.pipeline.cameraPoseDefault();
        break;
    }
    this.matrixWorldNeedsUpdate = true;
    this.backgroundTexture.MirrorMode = this.currentMirrorMode;
    this.backgroundTexture.updateFromPipeline(renderer, this.pipeline);
    this.handleColorSpace(renderer);
  }
  // eslint-disable-next-line no-underscore-dangle
  _updateProjectionMatrix() {
    const model = this.pipeline.cameraModel();
    const projection = projectionMatrixFromCameraModel(model, this.renderWidth, this.renderHeight, this.zNear, this.zFar);
    this.projectionMatrix.fromArray(projection);
    if (typeof this.projectionMatrixInverse.invert === "function") {
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    } else {
      this.projectionMatrixInverse.getInverse(this.projectionMatrix);
    }
  }
  updateMatrixWorld(force) {
    this.matrix.fromArray(this.rawPose);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
    super.updateMatrixWorld(force);
  }
  getOriginPose() {
    if (!this.poseAnchorOrigin)
      return this.pipeline.cameraPoseDefault();
    return this.pipeline.cameraPoseWithOrigin(this.poseAnchorOrigin.poseCameraRelative(this.currentMirrorMode === CameraMirrorMode.Poses));
  }
  /**
   * Destroys the camera sources.
   */
  dispose() {
    this.rearCameraSource.destroy();
    this.userCameraSource.destroy();
  }
};

// node_modules/@zappar/zappar-threejs/lib/trackers/imageanchorgroup.js
var ImageAnchorGroup = class extends THREE.Group {
  /**
   * Constructs a new ImageAnchorGroup.
   * @param camera - A ZapparThree.Camera.
   * @param imageTracker - The image tracker which will be used.
   * @param anchorId - Specify this to limit the group to tracking an anchor with the provided ID.
   */
  constructor(camera, imageTracker, anchorId) {
    super();
    this.camera = camera;
    this.imageTracker = imageTracker;
    this.anchorId = anchorId;
    this.isReady = false;
    this.matrixAutoUpdate = false;
  }
  updateMatrixWorld(force) {
    if (!this.currentAnchor || !this.imageTracker.visible.has(this.currentAnchor)) {
      if (this.anchorId) {
        this.currentAnchor = this.imageTracker.anchors.get(this.anchorId);
      } else {
        this.currentAnchor = this.imageTracker.visible.values().next().value;
      }
    }
    if (this.currentAnchor) {
      this.matrix.fromArray(this.currentAnchor.pose(this.camera.rawPose, this.camera.currentMirrorMode === CameraMirrorMode.Poses));
      this.matrix.decompose(this.position, this.quaternion, this.scale);
    }
    super.updateMatrixWorld(force);
  }
};

// node_modules/@zappar/zappar-threejs/lib/loaders/imagetrackerloader.js
var ImageTrackerLoader = class extends THREE.Loader {
  /**
   * Loads an image tracker.
   * @param zpt - A URL to, or ArrayBuffer of, an image target file.
   * @param onLoad - Callback which returns the imageTracker once it's loaded.
   * @param onError - Callback which is called if there's an error loading the target file.
   * @returns The ImageTracker.
   * @see https://docs.zap.works/universal-ar/zapworks-cli/
   */
  load(zpt, onLoad, onProgress, onError) {
    const trk = new ImageTracker3();
    trk.loadTarget(zpt).then(() => {
      onLoad === null || onLoad === void 0 ? void 0 : onLoad(trk);
      this.manager.itemEnd(zpt);
    }).catch((_) => {
      onError === null || onError === void 0 ? void 0 : onError(_);
      this.manager.itemError(zpt);
      this.manager.itemEnd(zpt);
    });
    return trk;
  }
  /**
   * @ignore
   */
  parse() {
  }
};

// node_modules/@zappar/zappar-threejs/lib/trackers/instantworldanchorgroup.js
var InstantWorldAnchorGroup = class extends THREE.Group {
  /**
   * Constructs a new InstantWorldAnchorGroup.
   * @param camera - A ZapparThree.Camera.
   * @param instantTracker - The instant world tracker which will be used.
   */
  constructor(camera, instantTracker) {
    super();
    this.camera = camera;
    this.instantTracker = instantTracker;
    this.matrixAutoUpdate = false;
  }
  /**
   * Sets the point in the user's environment that the anchor tracks from.
   *
   * The parameters passed in to this function correspond to the X, Y and Z coordinates (in camera space) of the point to track.
   * Choosing a position with X and Y coordinates of zero, and a negative Z coordinate,
   * will select a point on a surface directly in front of the center of the screen.
   *
   * @param orientation -  The orientation of the point in space.
   */
  setAnchorPoseFromCameraOffset(x, y, z2, orientation) {
    this.instantTracker.setAnchorPoseFromCameraOffset(x, y, z2, orientation);
  }
  updateMatrixWorld(force) {
    this.matrix.fromArray(this.instantTracker.anchor.pose(this.camera.rawPose, this.camera.currentMirrorMode === CameraMirrorMode.Poses));
    this.matrix.decompose(this.position, this.quaternion, this.scale);
    super.updateMatrixWorld(force);
  }
};

// node_modules/@zappar/zappar-threejs/lib/trackers/faceanchorgroup.js
var FaceAnchorGroup = class extends THREE.Group {
  /**
   * Constructs a new FaceAnchorGroup.
   * @param camera - A ZapparThree.Camera.
   * @param faceTracker - The face tracker which will be used.
   * @param anchorId - Specify this to limit the group to tracking an anchor with the provided ID.
   */
  constructor(camera, faceTracker, anchorId) {
    super();
    this.camera = camera;
    this.faceTracker = faceTracker;
    this.anchorId = anchorId;
    this.isReady = false;
    this.matrixAutoUpdate = false;
  }
  updateMatrixWorld(force) {
    if (!this.currentAnchor || !this.faceTracker.visible.has(this.currentAnchor)) {
      if (this.anchorId) {
        this.currentAnchor = this.faceTracker.anchors.get(this.anchorId);
      } else {
        this.currentAnchor = this.faceTracker.visible.values().next().value;
      }
    }
    if (this.currentAnchor) {
      this.matrix.fromArray(this.currentAnchor.pose(this.camera.rawPose, this.camera.currentMirrorMode === CameraMirrorMode.Poses));
      this.matrix.decompose(this.position, this.quaternion, this.scale);
    }
    super.updateMatrixWorld(force);
  }
};

// node_modules/@zappar/zappar-threejs/lib/trackers/facelandmarkgroup.js
var FaceLandmarkGroup = class extends THREE.Group {
  /**
   * Constructs a new FaceLandmarkGroup.
   * @param camera - A ZapparThree.Camera.
   * @param faceTracker - The face tracker which will be used.
   * @param landmark - The landmark to which the group will be anchored.
   */
  constructor(camera, faceTracker, landmark) {
    super();
    this.camera = camera;
    this.faceTracker = faceTracker;
    this.pose = mat4_exports.create();
    this.landmark = new FaceLandmark2(landmark);
    this.matrixAutoUpdate = false;
  }
  updateMatrixWorld(force) {
    if (!this.currentAnchor || !this.faceTracker.visible.has(this.currentAnchor)) {
      this.currentAnchor = this.faceTracker.visible.values().next().value;
    }
    if (this.currentAnchor) {
      this.landmark.updateFromFaceAnchor(this.currentAnchor, this.camera.currentMirrorMode === CameraMirrorMode.Poses);
      mat4_exports.multiply(this.pose, this.currentAnchor.pose(this.camera.rawPose, this.camera.currentMirrorMode === CameraMirrorMode.Poses), this.landmark.pose);
      this.matrix.fromArray(this.pose);
      this.matrix.decompose(this.position, this.quaternion, this.scale);
    }
    super.updateMatrixWorld(force);
  }
  /**
   * Destroys the face landmark.
   */
  dispose() {
    this.landmark.destroy();
  }
};

// node_modules/@zappar/zappar-threejs/lib/loaders/facetrackerloader.js
var FaceTrackerLoader = class extends THREE.Loader {
  /**
   * Loads face tracking model data.
   * @param customModel - A URL to, or ArrayBuffer of, model data.
   * @param options - A URL or ArrayBuffer of the source mesh data or defines if some face features should be filled with polygons.
   * @param onLoad - Callback which returns the FaceMesh once it's loaded.
   * @param onError - Callback which is called if there's an error loading the mesh.
   * @returns The FaceTracker.
   */
  load(customModel, onLoad, onProgress, onError) {
    const trk = new FaceTracker2();
    const p = customModel ? trk.loadModel(customModel) : trk.loadDefaultModel();
    const itemFilename3 = typeof customModel === "string" ? customModel : "__zappar_threejs_face_tracker_default";
    p.then(() => {
      onLoad === null || onLoad === void 0 ? void 0 : onLoad(trk);
      this.manager.itemEnd(itemFilename3);
    }).catch((_) => {
      onError === null || onError === void 0 ? void 0 : onError(_);
      this.manager.itemError(itemFilename3);
      this.manager.itemEnd(itemFilename3);
    });
    return trk;
  }
  /**
   * @ignore
   */
  parse() {
  }
};

// node_modules/@zappar/zappar-threejs/lib/loaders/facemeshloader.js
var FaceMeshLoader = class extends THREE.Loader {
  /**
   * Loads the data for a face mesh.
   * @param options - A URL or ArrayBuffer of the source mesh data or defines if some face features should be filled with polygons.
   * @param onLoad - Callback which returns the FaceMesh once it's loaded.
   * @param onError - Callback which is called if there's an error loading the mesh.
   * @returns The FaceMesh.
   */
  load(options, onLoad, onProgress, onError) {
    const trk = new FaceMesh2();
    let p;
    const itemFilename3 = `__zappar_threejs_face_mesh_${JSON.stringify(options || "default")}`;
    this.manager.itemStart(itemFilename3);
    if (options) {
      if (typeof options === "string")
        p = trk.load(options);
      else if (options.customModel)
        p = trk.load(options.customModel, options.fillMouth, options.fillEyeLeft, options.fillEyeRight, options.fillNeck);
      else
        p = trk.loadDefaultFace(options.fillMouth, options.fillEyeLeft, options.fillEyeRight);
    } else {
      p = trk.loadDefaultFace();
    }
    p.then(() => {
      onLoad === null || onLoad === void 0 ? void 0 : onLoad(trk);
      this.manager.itemEnd(itemFilename3);
    }).catch((_) => {
      onError === null || onError === void 0 ? void 0 : onError(_);
      this.manager.itemError(itemFilename3);
      this.manager.itemEnd(itemFilename3);
    });
    return trk;
  }
  /**
   * Loads the default face mesh.
   * @param options - Defines if some face features should be filled with polygons.
   * @param onLoad - Callback which returns the FaceMesh once it's loaded.
   * @param onError - Callback which is called if there's an error loading the mesh.
   * @returns The FaceMesh.
   */
  loadFace(options, onLoad, onProgress, onError) {
    const trk = new FaceMesh2();
    let p;
    const itemFilename3 = `__zappar_threejs_face_mesh_face_${JSON.stringify(options || "default")}`;
    if (options) {
      if (options.customModel)
        p = trk.load(options.customModel, options.fillMouth, options.fillEyeLeft, options.fillEyeRight, options.fillNeck);
      else
        p = trk.loadDefaultFace(options.fillMouth, options.fillEyeLeft, options.fillEyeRight);
    } else {
      p = trk.loadDefaultFace();
    }
    p.then(() => {
      onLoad === null || onLoad === void 0 ? void 0 : onLoad(trk);
      this.manager.itemEnd(itemFilename3);
    }).catch((_) => {
      onError === null || onError === void 0 ? void 0 : onError(_);
      this.manager.itemError(itemFilename3);
      this.manager.itemEnd(itemFilename3);
    });
    return trk;
  }
  /**
   * Loads the full head simplified mesh which covers the whole of the user's head, including some neck.
   * It's ideal for drawing into the depth buffer in order to mask out the back of 3D models placed on the user's head.
   * @param options - Defines if some face features should be filled with polygons.
   * @param onLoad - Callback which returns the FaceMesh once it's loaded.
   * @param onError - Callback which is called if there's an error loading the mesh.
   * @returns The FaceMesh.
   */
  loadFullHeadSimplified(options, onLoad, onProgress, onError) {
    const trk = new FaceMesh2();
    let p;
    const itemFilename3 = `__zappar_threejs_face_mesh_full_head_${JSON.stringify(options || "default")}`;
    if (options) {
      if (options.customModel)
        p = trk.load(options.customModel, options.fillMouth, options.fillEyeLeft, options.fillEyeRight, options.fillNeck);
      else
        p = trk.loadDefaultFullHeadSimplified(options.fillMouth, options.fillEyeLeft, options.fillEyeRight, options.fillNeck);
    } else {
      p = trk.loadDefaultFullHeadSimplified();
    }
    p.then(() => {
      onLoad === null || onLoad === void 0 ? void 0 : onLoad(trk);
      this.manager.itemEnd(itemFilename3);
    }).catch((_) => {
      onError === null || onError === void 0 ? void 0 : onError(_);
      this.manager.itemError(itemFilename3);
      this.manager.itemEnd(itemFilename3);
    });
    return trk;
  }
  /**
   * @ignore
   */
  parse() {
  }
};

// node_modules/@zappar/zappar-threejs/lib/geometry/facebuffergeometry.js
var faceMeshSingleton;
var FaceBufferGeometry = class extends THREE.BufferGeometry {
  /**
   * Constructs a new FaceBufferGeometry.
   * @param faceMesh - The face mesh which will be used. If not specified, the default face mesh will be loaded.
   */
  constructor(faceMesh) {
    super();
    this.hasSetIndices = false;
    this.hasSetUVs = false;
    this.recalculateNormals = true;
    this.setIndex([]);
    this.setAttribute("position", new THREE.Float32BufferAttribute([], 3));
    this.setAttribute("normal", new THREE.Float32BufferAttribute([], 3));
    this.setAttribute("uv", new THREE.Float32BufferAttribute([], 2));
    if (!faceMesh) {
      if (!faceMeshSingleton) {
        faceMeshSingleton = new FaceMeshLoader().load();
      }
      faceMesh = faceMeshSingleton;
    }
    this._faceMesh = faceMesh;
  }
  _updateIndices() {
    if (this.hasSetIndices)
      return;
    if (this._faceMesh.indices.length === 0)
      return;
    this.setIndex(new THREE.Uint16BufferAttribute(this._faceMesh.indices, 1));
    this.hasSetIndices = true;
  }
  _updateUVs() {
    if (this.hasSetUVs)
      return;
    if (this._faceMesh.uvs.length === 0)
      return;
    this.setAttribute("uv", new THREE.BufferAttribute(this._faceMesh.uvs, 2));
    this.hasSetUVs = true;
  }
  /**
   * @ignore
   */
  get calculateNormals() {
    return this.recalculateNormals;
  }
  /**
   * @ignore
   */
  set calculateNormals(b) {
    this.recalculateNormals = b;
    if (!this.recalculateNormals) {
      if (typeof this.removeAttribute === "function") {
        this.removeAttribute("normal");
      }
      delete this.normals;
    }
  }
  /**
   * Updates the geometry to the most recent identity and expression output from a face anchor group.
   * @param f - The face anchor group which will be used to update the geometry.
   */
  updateFromFaceAnchorGroup(f) {
    if (this._faceMesh.vertices.length === 0)
      return;
    if (!f.currentAnchor)
      return;
    this.updateFromFaceAnchor(f.currentAnchor);
  }
  /**
   * Updates the geometry to the most recent identity and expression output from a face anchor.
   * @param f - The face anchor which will be used to update the geometry.
   */
  updateFromFaceAnchor(f) {
    this.updateFromIdentityExpression(f.identity, f.expression);
  }
  /**
   * Updates the geometry to the provided identity and expression coefficients.
   * @param identity  - The identity coefficients.
   * @param expression - The expression coefficients.
   */
  updateFromIdentityExpression(identity4, expression) {
    if (this._faceMesh.vertices.length === 0)
      return;
    this._updateIndices();
    this._updateUVs();
    this._faceMesh.updateFromIdentityExpression(identity4, expression);
    if (!this.vertices) {
      this.vertices = new Float32Array(this._faceMesh.vertices.length);
      this.verticesAttribute = new THREE.BufferAttribute(this.vertices, 3);
      this.setAttribute("position", this.verticesAttribute);
    }
    this.vertices.set(this._faceMesh.vertices);
    if (this.verticesAttribute)
      this.verticesAttribute.needsUpdate = true;
    this.computeBoundingSphere();
    if (!this.calculateNormals)
      return;
    if (!this.normals) {
      this.normals = new Float32Array(this._faceMesh.normals.length);
      this.normalsAttribute = new THREE.BufferAttribute(this.normals, 3);
      this.setAttribute("normal", this.normalsAttribute);
    }
    this.normals.set(this._faceMesh.normals);
    if (this.normalsAttribute)
      this.normalsAttribute.needsUpdate = true;
  }
};

// node_modules/@zappar/zappar-threejs/lib/mesh/headmaskmesh.js
var HeadMaskMesh = class extends THREE.Mesh {
  /**
   * Constructs a new head mask mesh.
   * @param onLoad - Callback function which runs when the mesh is loaded.
   * @param onError - Callback which is called if there's an error loading the mesh.
   */
  constructor(onLoad, onError) {
    super();
    this.onLoad = onLoad;
    this.onError = onError;
    this.faceMesh = new FaceMesh2();
    this.faceBufferGeometry = new FaceBufferGeometry(this.faceMesh);
    this.geometry = this.faceBufferGeometry;
    this.material = new THREE.MeshBasicMaterial({
      colorWrite: false
    });
    this.faceMesh.loadDefaultFullHeadSimplified(true, true, true, true).then(() => {
      var _a;
      return (_a = this.onLoad) === null || _a === void 0 ? void 0 : _a.call(this);
    }).catch(() => {
      var _a;
      return (_a = this.onError) === null || _a === void 0 ? void 0 : _a.call(this);
    });
    this.renderOrder = Number.MIN_SAFE_INTEGER;
  }
  /**
   * Updates pose directly from the [[FaceAnchorGroup]] anchor.
   * @param f - The anchor to derive the expression and identity from.
   */
  updateFromFaceAnchorGroup(f) {
    this.faceBufferGeometry.updateFromFaceAnchorGroup(f);
  }
  /**
   * Updates pose directly from the expression and identity in a [[FaceAnchor]].
   * @param f - The anchor to derive the expression and identity from.
   */
  updateFromFaceAnchor(f) {
    this.faceBufferGeometry.updateFromFaceAnchor(f);
  }
  /**
   * Updates pose directly from identity and expression coefficients.
   * @param identity  - The identity coefficients.
   * @param expression - The expression coefficients.
   */
  updateFromIdentityExpression(identity4, expression) {
    this.faceBufferGeometry.updateFromIdentityExpression(identity4, expression);
  }
  /**
   * Destroys the face mesh and disposes of resources.
   */
  dispose() {
    this.faceMesh.destroy();
    this.faceBufferGeometry.dispose();
  }
};

// node_modules/@zappar/zappar-threejs/lib/loaders/headmaskmeshloader.js
var itemFilename = "__zappar_threejs_head_mask_mesh";
var HeadMaskMeshLoader = class extends THREE.Loader {
  /**
   * Loads a HeadMaskMesh.
   * @param onLoad - Callback which returns the HeadMaskMesh once it's loaded.
   * @param onError - Callback which is called if there's an error loading the mesh.
   * @returns The HeadMaskMesh.
   */
  load(onLoad, onProgress, onError) {
    this.manager.itemStart(itemFilename);
    return new HeadMaskMesh(() => {
      onLoad === null || onLoad === void 0 ? void 0 : onLoad();
      this.manager.itemEnd(itemFilename);
    }, () => {
      onError === null || onError === void 0 ? void 0 : onError();
      this.manager.itemError(itemFilename);
      this.manager.itemEnd(itemFilename);
    });
  }
  /**
   * @ignore
   */
  parse() {
  }
};

// node_modules/@zappar/zappar-threejs/lib/loaders/libraryloader.js
var itemFilename2 = "__zappar_threejs_library";
var LibraryLoader = class extends THREE.Loader {
  /**
   * Resolves once the library is loaded and ready to process data.
   * @param onLoad - Callback which runs once the library is fully loaded.
   * @param onError - Callback which is called if there's an error loading library.
   */
  load(onLoad, onProgress, onError) {
    this.manager.itemStart(itemFilename2);
    loadedPromise().then(() => {
      onLoad === null || onLoad === void 0 ? void 0 : onLoad();
      this.manager.itemEnd(itemFilename2);
    }).catch((err) => {
      onError === null || onError === void 0 ? void 0 : onError();
      this.manager.itemError(itemFilename2);
      this.manager.itemEnd(itemFilename2);
    });
  }
  /**
   * @ignore
   */
  parse() {
  }
};

// node_modules/@zappar/zappar-threejs/lib/loaders/loadingmanager.js
var UI = class {
  constructor(style) {
    this.lastLoadPercentage = 0;
    this.divs = {
      inner: document.createElement("div"),
      title: document.createElement("div"),
      progress: document.createElement("div"),
      progressValue: document.createElement("div")
    };
    this.css = {
      container: {
        position: "fixed",
        width: "100%",
        height: "100%",
        top: "0px",
        left: "0px",
        zIndex: "10000",
        backgroundColor: "rgba(0,0,0,0.8)",
        fontFamily: "sans-serif",
        color: "rgba(255,255,255,1)",
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center",
        transition: "opacity 500ms"
      },
      inner: {
        maxWidth: "400px",
        textAlign: "center"
      },
      title: {
        fontSize: "20px"
      },
      progress: {
        background: "rgba(255,255,255, 0.1)",
        justifyContent: "flex-start",
        borderRadius: "100px",
        alignItems: "center",
        position: "relative",
        padding: "0 5px",
        display: "flex",
        height: "15px",
        width: "250px",
        margin: "15px"
      },
      progressValue: {
        boxShadow: "0 10px 40px -10px #fff",
        borderTopLeftRadius: "100px",
        borderBottomLeftRadius: "100px",
        background: "rgba(255,255,255,1)",
        height: "10px",
        width: "0",
        transition: "width 500ms"
      }
    };
    this.updateLoader = (loadPercentage) => {
      if (loadPercentage < this.lastLoadPercentage)
        return;
      this.lastLoadPercentage = loadPercentage;
      const elem = document.getElementById("zappar-loader-progressValue");
      elem.style.width = `${loadPercentage}%`;
      elem.style.borderTopRightRadius = `${loadPercentage}px`;
      elem.style.borderBottomRightRadius = `${loadPercentage}px`;
      elem.addEventListener("transitionend", () => {
        if (loadPercentage === 100) {
          this.containerDiv.style.opacity = "0";
          this.containerDiv.addEventListener("transitionend", (ev) => {
            if (ev.propertyName === "opacity") {
              this.dispose();
            }
          });
        }
      });
    };
    this.dispose = () => {
      this.containerDiv.remove();
    };
    this.customStyle = style;
    this.containerDiv = document.createElement("div");
  }
  initialize() {
    for (const key in this.divs) {
      this.divs[key].id = `zappar-loader-${key}`;
    }
    this.refreshStyle();
    this.divs.inner.appendChild(this.divs.title);
    this.divs.inner.appendChild(this.divs.progress);
    this.divs.progress.appendChild(this.divs.progressValue);
    this.containerDiv.appendChild(this.divs.inner);
    this.divs.title.innerHTML = "Loading...";
    document.body.append(this.containerDiv);
  }
  refreshStyle() {
    var _a, _b, _c, _d, _e;
    Object.assign(this.css.container, (_a = this.customStyle) === null || _a === void 0 ? void 0 : _a.container);
    Object.assign(this.css.inner, (_b = this.customStyle) === null || _b === void 0 ? void 0 : _b.inner);
    Object.assign(this.css.title, (_c = this.customStyle) === null || _c === void 0 ? void 0 : _c.title);
    Object.assign(this.css.progress, (_d = this.customStyle) === null || _d === void 0 ? void 0 : _d.progress);
    Object.assign(this.css.progressValue, (_e = this.customStyle) === null || _e === void 0 ? void 0 : _e.progressValue);
    Object.assign(this.containerDiv.style, this.css.container);
    Object.assign(this.divs.inner.style, this.css.inner);
    Object.assign(this.divs.title.style, this.css.title);
    Object.assign(this.divs.progress.style, this.css.progress);
    Object.assign(this.divs.progressValue.style, this.css.progressValue);
  }
};
var DefaultLoaderUI = class extends UI {
  /**
   * Constructs a new DefaultLoaderUI.
   * @param options - The styling of the UI.
   * @param onload - The callback function to be called when assets are loaded.
   */
  constructor(options) {
    super(options === null || options === void 0 ? void 0 : options.style);
    THREE.DefaultLoadingManager.onStart = () => {
      this.initialize();
    };
    THREE.DefaultLoadingManager.onLoad = () => {
      var _a;
      (_a = options === null || options === void 0 ? void 0 : options.onLoad) === null || _a === void 0 ? void 0 : _a.call(options);
    };
    THREE.DefaultLoadingManager.onProgress = (_url, itemsLoaded, itemsTotal) => {
      this.updateLoader(itemsLoaded / itemsTotal * 100);
    };
  }
};
var LoadingManager = class extends THREE.LoadingManager {
  /**
   * Constructs a new LoadingManager.
   * @param options - Styling may be defined here, as well as any event callbacks.
   */
  constructor(options) {
    super(() => {
      var _a;
      return (_a = options === null || options === void 0 ? void 0 : options.onLoad) === null || _a === void 0 ? void 0 : _a.call(options);
    }, (url, loaded2, total) => {
      var _a;
      this.ui.customStyle = options === null || options === void 0 ? void 0 : options.style;
      this.ui.refreshStyle();
      (_a = options === null || options === void 0 ? void 0 : options.onProgress) === null || _a === void 0 ? void 0 : _a.call(options, url, loaded2, total);
      this.ui.updateLoader(loaded2 / total * 100);
    }, options === null || options === void 0 ? void 0 : options.onError);
    this.ui = new UI();
    this.onStartCallback = void 0;
    this.onStart = () => {
      this.ui.initialize();
      if (this.onStartCallback)
        this.onStartCallback();
    };
    this._onStart = (callback) => {
      this.onStartCallback = callback;
    };
    this.dispose = () => {
      this.ui.dispose();
    };
    new LibraryLoader(this).load();
  }
};

// node_modules/@zappar/zappar-threejs/lib/cameraenvironmentmap.js
var CameraEnvironmentMap = class {
  /**
   * Constructs a new Camera Environment Map.
   */
  constructor() {
    this.cubeMapScene = new THREE.Scene();
    this.renderTarget = new THREE.WebGLCubeRenderTarget(256, {
      format: THREE.RGBAFormat,
      generateMipmaps: true,
      minFilter: THREE.LinearMipmapLinearFilter
    });
    this.cubeCamera = new THREE.CubeCamera(0.1, 1e3, this.renderTarget);
    this.sphereMaterial = new THREE.MeshBasicMaterial({ side: THREE.DoubleSide });
    this.sphereGroup = new THREE.Group();
    this.environmentMap = this.renderTarget.texture;
    this.cubeMapScene.add(this.cubeCamera);
    const sphere = new THREE.Mesh(new THREE.SphereGeometry(10, 16, 12), this.sphereMaterial);
    sphere.rotation.set(0, -0.5 * Math.PI, 0);
    this.sphereGroup.add(sphere);
    this.cubeMapScene.add(this.sphereGroup);
  }
  /**
   * Destroy the resources held by this object.
   */
  dispose() {
    this.renderTarget.dispose();
    this.sphereMaterial.dispose();
  }
  /**
   * Update the contents of the environment map with the latest texture from the camera.
   *
   * Call this each frame after you call `update` on your Zappar camera, but before you render the scene.
   * @param renderer - Your renderer object
   * @param zapparCamera - The Zappar camera you're using to render your scene
   */
  update(renderer, zapparCamera) {
    if (parseInt(THREE.REVISION, 10) < 152)
      this.environmentMap.encoding = renderer.outputEncoding;
    else
      this.environmentMap.colorSpace = renderer.outputColorSpace;
    this.sphereMaterial.map = zapparCamera.backgroundTexture;
    this.sphereGroup.quaternion.copy(zapparCamera.quaternion);
    this.cubeCamera.update(renderer, this.cubeMapScene);
  }
};

// node_modules/@zappar/zappar-threejs/lib/geometry/targetimagepreviewbuffergeometry.js
var TargetImagePreviewBufferGeometry = class extends THREE.BufferGeometry {
  /**
   * Constructs a new TargetImagePreviewBufferGeometry.
   * @param imageTarget - The image target which will be used.
   */
  constructor(imageTarget) {
    super();
    this.imageTarget = imageTarget;
    this.hasSetIndices = false;
    this.hasSetUVs = false;
    this.recalculateNormals = true;
    if (this.imageTarget.preview.vertices.length === 0) {
      throw new Error("No vertices found in the image target.");
    }
    const vertexCount = this.imageTarget.preview.vertices.length / 3;
    this.vertices = new Float32Array(vertexCount * 3);
    this.vertices.set(this.imageTarget.preview.vertices);
    this.setAttribute("position", new THREE.BufferAttribute(this.vertices, 3));
    this.setAttribute("normal", new THREE.Float32BufferAttribute(vertexCount * 3, 3));
    this._updateUVs();
    this._updateIndices();
    this.computeBoundingSphere();
    this.computeVertexNormals();
    this.attributes.position.needsUpdate = true;
    this.attributes.normal.needsUpdate = true;
    if (this.attributes.uv)
      this.attributes.uv.needsUpdate = true;
  }
  /**
   * @ignore
   */
  _updateIndices() {
    var _a;
    if (this.hasSetIndices)
      return;
    if (((_a = this.imageTarget) === null || _a === void 0 ? void 0 : _a.preview.indices.length) > 0) {
      this.setIndex(new THREE.Uint16BufferAttribute(this.imageTarget.preview.indices, 1));
      this.hasSetIndices = true;
    }
  }
  /**
   * @ignore
   */
  _updateUVs() {
    if (this.hasSetUVs)
      return;
    if (this.imageTarget.preview.uvs.length > 0) {
      this.setAttribute("uv", new THREE.BufferAttribute(new Float32Array(this.imageTarget.preview.uvs), 2));
      this.hasSetUVs = true;
    }
  }
  /**
   * @ignore
   */
  get calculateNormals() {
    return this.recalculateNormals;
  }
};

// node_modules/@zappar/zappar-threejs/lib/mesh/targetimagepreviewmesh.js
var TargetImagePreviewMesh = class extends THREE.Mesh {
  constructor(target, material) {
    if (!material) {
      const map = new THREE.TextureLoader().load(target.image.src);
      map.colorSpace = THREE.SRGBColorSpace;
      material = new THREE.MeshBasicMaterial({
        map
      });
    }
    super(new TargetImagePreviewBufferGeometry(target), material);
  }
};

// node_modules/@zappar/zappar-threejs/lib/index.js
console.log(`Zappar for ThreeJS v${VERSION}`);
export {
  BarcodeFinder2 as BarcodeFinder,
  Camera,
  CameraEnvironmentMap,
  CameraMirrorMode,
  CameraPoseMode,
  CameraSource3 as CameraSource,
  DefaultLoaderUI,
  FaceAnchorGroup,
  FaceBufferGeometry,
  FaceLandmark2 as FaceLandmark,
  FaceLandmarkGroup,
  face_landmark_name_t as FaceLandmarkName,
  FaceMesh2 as FaceMesh,
  FaceMeshLoader,
  FaceTracker2 as FaceTracker,
  FaceTrackerLoader,
  HTMLElementSource3 as HTMLElementSource,
  HeadMaskMesh,
  HeadMaskMeshLoader,
  ImageAnchorGroup,
  ImageTracker3 as ImageTracker,
  ImageTrackerLoader,
  InstantWorldAnchorGroup,
  InstantWorldTracker2 as InstantWorldTracker,
  LibraryLoader,
  LoadingManager,
  log_level_t as LogLevel,
  Pipeline2 as Pipeline,
  SequenceSource2 as SequenceSource,
  TargetImagePreviewBufferGeometry,
  TargetImagePreviewMesh,
  browserIncompatible,
  browserIncompatibleUI,
  cookiesPermitted,
  getDefaultPipeline,
  glContextLost,
  glContextSet,
  loaded,
  loadedPromise,
  onFrameUpdate,
  permissionDenied,
  permissionDeniedUI2 as permissionDeniedUI,
  permissionGranted,
  permissionRequest,
  permissionRequestUI2 as permissionRequestUI,
  setLogLevel2 as setLogLevel
};
//# sourceMappingURL=@zappar_zappar-threejs.js.map
